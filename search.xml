<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>DP-MachineLearning</title>
      <link href="/2018/06/11/DP-MachineLearning/"/>
      <url>/2018/06/11/DP-MachineLearning/</url>
      <content type="html"><![CDATA[<h1 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h1><ol><li><a href="https://arxiv.org/pdf/1606.05053.pdf" target="_blank" rel="noopener">2016-Nguyen</a> introduces gradient descent with local dp.</li><li></li></ol><p>[2016-Nguyen] Collecting and Analyzing Data from Smart Device Users with Local Differential Privacy</p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP - Related Paper</title>
      <link href="/2018/06/10/DP-Related-Paper/"/>
      <url>/2018/06/10/DP-Related-Paper/</url>
      <content type="html"><![CDATA[<h1 id="survey"><a href="#survey" class="headerlink" title="survey"></a>survey</h1><ul><li>[ ]  <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6582713" target="_blank" rel="noopener">Signal Processing and Machine Learning with Differential Privacy</a></li><li>[ ] </li></ul><h1 id="epsilon-delta-differential-privacy"><a href="#epsilon-delta-differential-privacy" class="headerlink" title="($\epsilon,\delta$)-differential privacy"></a>($\epsilon,\delta$)-differential privacy</h1><ul><li>[ ]  <a href="https://link.springer.com/content/pdf/10.1007%2F11761679_29.pdf" target="_blank" rel="noopener">Our Data, Ourselves: Privacy Via Distributed Noise Generation</a></li></ul><h1 id="delta-probability-privacy"><a href="#delta-probability-privacy" class="headerlink" title="$\delta$-probability privacy"></a>$\delta$-probability privacy</h1><ul><li>[ ]  <a href="http://www.cse.psu.edu/~duk17/papers/PrivacyOnTheMap.pdf" target="_blank" rel="noopener">Privacy: Theory meets practice on the map</a></li></ul><h1 id="Sensitivity"><a href="#Sensitivity" class="headerlink" title="Sensitivity"></a>Sensitivity</h1><ul><li>[ ]  <a href="https://link.springer.com/content/pdf/10.1007%2F11681878_14.pdf" target="_blank" rel="noopener">Calibrating Noise to Sensitivity in Private Data Analysis</a></li><li>[ ] </li></ul><h1 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h1><ul><li>[ ]  <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5670947" target="_blank" rel="noopener">Boosting and Differential Privacy</a></li></ul><h1 id="Mechanism"><a href="#Mechanism" class="headerlink" title="Mechanism"></a>Mechanism</h1><ul><li>[ ]  <a href="https://link.springer.com/content/pdf/10.1007%2F978-3-319-67786-6_6.pdf" target="_blank" rel="noopener">Differentially Private Empirical Risk Minimization with Input Perturbation</a></li><li>[ ] </li></ul>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ML - Naive Bayes</title>
      <link href="/2018/06/10/ML-Naive-Bayes/"/>
      <url>/2018/06/10/ML-Naive-Bayes/</url>
      <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=XcwH9JGfZOU" target="_blank" rel="noopener">How Naive Bayes Classifier Works</a></p><p>The Naive Bayesian classifier is based on Bayes’ theorem with the independence assumptions between predictors. </p>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ML - K-Nearest Neighbors</title>
      <link href="/2018/06/10/ML-K-Nearest-Neighbors/"/>
      <url>/2018/06/10/ML-K-Nearest-Neighbors/</url>
      <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=UqYde-LULfs" target="_blank" rel="noopener">How kNN algorithm works</a></p><p><a href="https://www.youtube.com/watch?v=k_7gMp5wh5A" target="_blank" rel="noopener">k nearest neighbor (kNN): how it works</a></p><p><a href="https://www.youtube.com/watch?v=v6278Cjf_qA" target="_blank" rel="noopener">How K-Nearest Neighbors (kNN) Classifier Works</a></p><p>kNN (k-Nearest Neighbors) is a classification algorithm. It is a simple algorithm that stores all available cases and classifies new cases based on a similarity measure (e.g., distance functions).</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>For a new case to be classified, we calculate the distance between this case and each training sample. And we rank the distance in an ascending way and pick the top-k samples with smallest distance with the new case as its k-nearest neighbour. And this case is classified by a majority vote of its neighbors, with the case being assigned to the class most common amongst its K nearest neighbors. If K = 1, then the case is simply assigned to the class of its nearest neighbor. </p><h3 id="distance"><a href="#distance" class="headerlink" title="distance"></a>distance</h3><p><img src="/2018/06/10/ML-K-Nearest-Neighbors/Screen Shot 2018-06-10 at 11.48.30 PM.png" alt="Screen Shot 2018-06-10 at 11.48.30 PM"></p><p>It should also be noted that all three distance measures are valid for continuous variables. In the instance of <strong>categorical variables</strong> the Hamming distance must be used. </p><blockquote><p>Say we have a categorical attribute gender and its domain is $\{male, female\}$. And for a new case $x$ and its gender is $male$. For all the training sample, we calculate the gender distance between each sample and the new case. If their gender is same, then the distance is 0; else the distance is 1.  </p></blockquote><h3 id="normalization"><a href="#normalization" class="headerlink" title="normalization"></a>normalization</h3><p>Because the distance of categorical attribute is either 0 or 1, standardization of the numerical variables between 0 and 1 is needed when there is a mixture of numerical and categorical variables in the dataset.</p><h3 id="K-choice"><a href="#K-choice" class="headerlink" title="K choice"></a>K choice</h3><p>Choosing the optimal value for K is best done by first inspecting the data. In general, a large K value is more precise as it reduces the overall noise but there is no guarantee. Cross-validation is another way to retrospectively determine a good K value by using an independent dataset to validate the K value. Historically, the optimal K for most datasets has been between 3-10. That produces much better results than 1NN.</p><h2 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h2><p>Say we have the training sample database concerning credit default as follows, Age and Loan are two numerical variables (predictors) and Default is the target.        </p><div class="table-container"><table><thead><tr><th style="text-align:center">Age</th><th style="text-align:center">Loan</th><th style="text-align:center">Default</th></tr></thead><tbody><tr><td style="text-align:center">25</td><td style="text-align:center">$40,000</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">35</td><td style="text-align:center">$60,000</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">$80,000</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">$20,000</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">35</td><td style="text-align:center">$120,000</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">52</td><td style="text-align:center">$18,000</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">$95,000</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">40</td><td style="text-align:center">$62,000</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">60</td><td style="text-align:center">$100,000</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">$220,000</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">$150,000</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><p>Now we have an unknown case (Age=48 and Loan=$142,000). And we want to predict the credit default for this case using Euclidean distance. So using the following formula to calculate the distance:</p><script type="math/tex; mode=display">d =\sqrt{(x_1-y_1)^2+(x_2-y_2)^2}</script><p>We can get the following:</p><p><img src="/2018/06/10/ML-K-Nearest-Neighbors/Screen Shot 2018-06-11 at 12.29.41 AM.png" alt="Screen Shot 2018-06-11 at 12.29.41 AM"></p><p>With k=3, there are two Default=Y and one Default=N out of the three closest neighbors. So the prediction for this case is Default=Y.</p><h2 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h2><p>One major drawback in calculating distance measures directly from the training set is in the case where variables have different measurement scales or there is a mixture of numerical and categorical variables. For example, if one variable is based on annual income in dollars, and the other is based on age in years then income will have a much higher influence on the distance calculated. One solution is to standardize the training set as shown below.</p><script type="math/tex; mode=display">X_s=\frac{X-X_{min}}{X_{max}-X_{min}}</script><p><img src="/2018/06/10/ML-K-Nearest-Neighbors/Screen Shot 2018-06-11 at 12.34.40 AM.png" alt="Screen Shot 2018-06-11 at 12.34.40 AM"></p>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TWICE</title>
      <link href="/2018/06/08/TWICE/"/>
      <url>/2018/06/08/TWICE/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Latex</title>
      <link href="/2018/06/08/Latex/"/>
      <url>/2018/06/08/Latex/</url>
      <content type="html"><![CDATA[<ol><li><p>公式换行使等号对齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\begin&#123;equation&#125;</div><div class="line">\begin&#123;aligned&#125;</div><div class="line">Y&amp;=2*(x+3)\\</div><div class="line">&amp;=2*x+6</div><div class="line">\end&#123;aligned&#125;</div><div class="line">\end&#123;equation&#125;</div></pre></td></tr></table></figure></li></ol><script type="math/tex; mode=display">   \begin{equation}   \begin{aligned}   Y&=2*(x+3)\\   &=2*x+6   \end{aligned}   \end{equation}</script><ol><li><p>联立方程组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">t^*=</div><div class="line">\left\&#123;</div><div class="line">\begin&#123;align&#125; </div><div class="line">x&amp;=eq1 &amp; \text&#123;if x=1&#125;\\</div><div class="line">y&amp;=eq2 &amp;\text&#123;if x=2&#125;</div><div class="line">\end&#123;align&#125;</div><div class="line">\right.</div></pre></td></tr></table></figure><script type="math/tex; mode=display">t^*=\left\{\begin{align} x&=eq1 & \text{if x=1}\\y&=eq2 &\text{if x=2}\end{align}\right.</script></li></ol>]]></content>
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ML - Pandas</title>
      <link href="/2018/06/08/ML-Pandas/"/>
      <url>/2018/06/08/ML-Pandas/</url>
      <content type="html"><![CDATA[<p>本文参考<a href="https://www.yiibai.com/pandas/python_pandas_data_structures.html" target="_blank" rel="noopener">1</a></p><p><a href="https://www.yiibai.com/pandas/python_pandas_window_functions.html" target="_blank" rel="noopener">last</a></p><p>pandas导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div></pre></td></tr></table></figure><a id="more"></a><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Pandas处理以下三种数据结构：系列（Series），数据帧（DataFrame）,面板（Panel）</p><p>系列是具有均匀数据的一维数组结构，尺寸大小不变但数据可变</p><p>数据帧(<em>DataFrame</em>)是一个具有异构数据的二维数组，尺寸大小可变且数据可变</p><p>面板是具有异构数据的三维数据结构，尺寸大小可变且数据可变</p><h3 id="系列（Series"><a href="#系列（Series" class="headerlink" title="系列（Series)"></a>系列（Series)</h3><p>系列(<code>Series</code>)是能够保存任何类型的数据(整数，字符串，浮点数，Python对象等)的一维标记数组，轴标签统称为索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Pandas系列可以使用以下构造函数创建</span></div><div class="line">pandas.Series( data, index, dtype, copy)</div><div class="line"><span class="comment"># data - 数据采取各种形式，如：ndarray，list，constants</span></div><div class="line"><span class="comment"># index - 索引值必须是唯一的和散列的，与数据的长度相同。 默认np.arange(n)如果没有索引被传递。</span></div><div class="line"><span class="comment"># dtype - dtype用于数据类型。如果没有，将推断数据类型</span></div><div class="line"><span class="comment"># copy - 复制数据，默认为false</span></div></pre></td></tr></table></figure><h4 id="创建系列"><a href="#创建系列" class="headerlink" title="创建系列"></a>创建系列</h4><h5 id="创建一个空的系列"><a href="#创建一个空的系列" class="headerlink" title="创建一个空的系列"></a>创建一个空的系列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">s = pd.Series()</div><div class="line">print(s)<span class="comment">#Series([], dtype: float64)</span></div></pre></td></tr></table></figure><h5 id="ndarray创建一个系列"><a href="#ndarray创建一个系列" class="headerlink" title="ndarray创建一个系列"></a>ndarray创建一个系列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">data = np.array([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</div><div class="line">s = pd.Series(data)</div><div class="line">print(s)<span class="comment">#索引从0开始</span></div><div class="line"><span class="comment">#0    a</span></div><div class="line"><span class="comment">#1    b</span></div><div class="line"><span class="comment">#2    c</span></div><div class="line"><span class="comment">#3    d</span></div><div class="line"><span class="comment">#dtype: object</span></div><div class="line"></div><div class="line">s = pd.Series(data,index=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>])</div><div class="line">print(s)<span class="comment">#自定义索引</span></div><div class="line"><span class="comment">#100    a</span></div><div class="line"><span class="comment">#101    b</span></div><div class="line"><span class="comment">#102    c</span></div><div class="line"><span class="comment">#103    d</span></div><div class="line"><span class="comment">#dtype: object</span></div></pre></td></tr></table></figure><h5 id="从字典创建一个系列"><a href="#从字典创建一个系列" class="headerlink" title="从字典创建一个系列"></a>从字典创建一个系列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#字典(dict)可以作为输入传递，如果没有指定索引，则按排序顺序取得字典键以构造索引。 如果传递了索引，索引中与标签对应的数据中的值将被拉出。</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">data = &#123;<span class="string">'a'</span>:<span class="number">0</span>,<span class="string">'b'</span>:<span class="number">1</span>,<span class="string">'c'</span>:<span class="number">2</span>&#125;</div><div class="line">s = pd.Series(data)</div><div class="line">print(s)</div><div class="line"><span class="comment"># a    0</span></div><div class="line"><span class="comment"># b    1</span></div><div class="line"><span class="comment"># c    2</span></div><div class="line"><span class="comment"># dtype: int64</span></div><div class="line"></div><div class="line">s = pd.Series(data,index=[<span class="string">'b'</span>,<span class="string">'def1'</span>,<span class="string">'a'</span>,<span class="string">'def2'</span>,<span class="string">'c'</span>])</div><div class="line">print(s) <span class="comment">#索引顺序保持不变，缺少的元素使用NaN(不是数字)填充。</span></div><div class="line"><span class="comment"># b       1.0</span></div><div class="line"><span class="comment"># def1    NaN</span></div><div class="line"><span class="comment"># a       0.0</span></div><div class="line"><span class="comment"># def2    NaN</span></div><div class="line"><span class="comment"># c       2.0</span></div><div class="line"><span class="comment"># dtype: float64</span></div></pre></td></tr></table></figure><h5 id="从标量创建一个系列"><a href="#从标量创建一个系列" class="headerlink" title="从标量创建一个系列"></a>从标量创建一个系列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#如果数据是标量值，则必须提供索引。将重复该值以匹配索引的长度。</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">s = pd.Series(<span class="number">5</span>,index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">print(s)</div><div class="line"><span class="comment"># 0    5</span></div><div class="line"><span class="comment"># 1    5</span></div><div class="line"><span class="comment"># 2    5</span></div><div class="line"><span class="comment"># 3    5</span></div><div class="line"><span class="comment"># dtype: int64</span></div></pre></td></tr></table></figure><h4 id="系列访问"><a href="#系列访问" class="headerlink" title="系列访问"></a>系列访问</h4><h5 id="使用位置index访问"><a href="#使用位置index访问" class="headerlink" title="使用位置index访问"></a>使用位置index访问</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>])</div><div class="line">print(s[<span class="number">0</span>]) <span class="comment">#输出1</span></div><div class="line">print(s[:<span class="number">3</span>])<span class="comment">#检索系列中的前三个元素</span></div><div class="line"><span class="comment"># a    1</span></div><div class="line"><span class="comment"># b    2</span></div><div class="line"><span class="comment"># c    3</span></div><div class="line">print(s[<span class="number">-3</span>:])<span class="comment">#检索最后三个元素</span></div><div class="line"><span class="comment"># c    3</span></div><div class="line"><span class="comment"># d    4</span></div><div class="line"><span class="comment"># e    5</span></div></pre></td></tr></table></figure><h5 id="使用标签检索"><a href="#使用标签检索" class="headerlink" title="使用标签检索"></a>使用标签检索</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>])</div><div class="line">print(s[<span class="string">'b'</span>]) <span class="comment">#输出2</span></div><div class="line"></div><div class="line"><span class="comment">#使用索引标签值列表检索多个元素。</span></div><div class="line">print(s[[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>]]) </div><div class="line"><span class="comment"># a    1</span></div><div class="line"><span class="comment"># c    3</span></div><div class="line"><span class="comment"># e    5</span></div></pre></td></tr></table></figure><h3 id="数据帧-DataFrame"><a href="#数据帧-DataFrame" class="headerlink" title="数据帧(DataFrame)"></a>数据帧(DataFrame)</h3><p>数据帧(DataFrame)是二维数据结构，即数据以行和列的表格方式排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pandas中的DataFrame可以使用以下构造函数创建 </span></div><div class="line">pandas.DataFrame( data, index, columns, dtype, copy)</div><div class="line"><span class="comment"># data - 数据采取各种形式，如:ndarray，series，map，lists，dict，constant和另一个DataFrame。</span></div><div class="line"><span class="comment"># index - 对于行标签，要用于结果帧的索引是可选缺省值np.arrange(n)，如果没有传递索引值。</span></div><div class="line"><span class="comment"># columns - 对于列标签，可选的默认语法是 - np.arange(n)</span></div><div class="line"><span class="comment"># dtype - 每列的数据类型。</span></div><div class="line"><span class="comment"># copy - 如果默认值为False，则此命令(或任何它)用于复制数据。</span></div></pre></td></tr></table></figure><h4 id="创建数据帧"><a href="#创建数据帧" class="headerlink" title="创建数据帧"></a>创建数据帧</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">df = pd.DataFrame()</div></pre></td></tr></table></figure><h5 id="通过列表创建"><a href="#通过列表创建" class="headerlink" title="通过列表创建"></a>通过列表创建</h5><p>可以使用单个列表或列表列表创建数据帧(<em>DataFrame</em>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">df = pd.DataFrame(data)</div><div class="line">print(df)</div><div class="line"><span class="comment">#    0</span></div><div class="line"><span class="comment"># 0  1</span></div><div class="line"><span class="comment"># 1  2</span></div><div class="line"><span class="comment"># 2  3</span></div><div class="line"><span class="comment"># 3  4</span></div><div class="line"><span class="comment"># 4  5</span></div><div class="line"></div><div class="line">data = [[<span class="string">'Alex'</span>,<span class="number">10</span>],[<span class="string">'Bob'</span>,<span class="number">12</span>],[<span class="string">'Dan'</span>,<span class="number">13</span>]]</div><div class="line">df = pd.DataFrame(data,columns=[<span class="string">'Name'</span>,<span class="string">'Age'</span>])<span class="comment">#dtype=float将参数age类型改为浮点</span></div><div class="line">print(df)</div><div class="line"><span class="comment">#    Name  Age</span></div><div class="line"><span class="comment"># 0  Alex   10</span></div><div class="line"><span class="comment"># 1   Bob   12</span></div><div class="line"><span class="comment"># 2   Dan   13</span></div></pre></td></tr></table></figure><h5 id="通过ndarrays-Lists的字典创建"><a href="#通过ndarrays-Lists的字典创建" class="headerlink" title="通过ndarrays/Lists的字典创建"></a>通过ndarrays/Lists的字典创建</h5><p>所有的<code>ndarrays</code>必须具有相同的长度。如果传递了索引(<code>index</code>)，则索引的长度应等于数组的长度。</p><p>如果没有传递索引，则默认情况下，索引将为<code>range(n)</code>，其中<code>n</code>为数组长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">data = &#123;<span class="string">'Name'</span>:[<span class="string">'Tom'</span>,<span class="string">'Jack'</span>,<span class="string">'Steve'</span>,<span class="string">'Ricky'</span>],<span class="string">'Age'</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</div><div class="line">df = pd.DataFrame(data)</div><div class="line">print(df) <span class="comment">## 观察值0,1,2,3。它们是分配给每个使用函数range(n)的默认索引。</span></div><div class="line"><span class="comment">#    Age   Name</span></div><div class="line"><span class="comment"># 0   28    Tom</span></div><div class="line"><span class="comment"># 1   34   Jack</span></div><div class="line"><span class="comment"># 2   29  Steve</span></div><div class="line"><span class="comment"># 3   42  Ricky</span></div><div class="line"></div><div class="line">df = pd.DataFrame(data,index=[<span class="string">'rank1'</span>,<span class="string">'rank2'</span>,<span class="string">'rank3'</span>,<span class="string">'rank4'</span>])</div><div class="line">print(df) <span class="comment">## index参数为每行分配一个索引。</span></div><div class="line"><span class="comment">#        Age   Name</span></div><div class="line"><span class="comment"># rank1   28    Tom</span></div><div class="line"><span class="comment"># rank2   34   Jack</span></div><div class="line"><span class="comment"># rank3   29  Steve</span></div><div class="line"><span class="comment"># rank4   42  Ricky</span></div></pre></td></tr></table></figure><h5 id="通过字典创建"><a href="#通过字典创建" class="headerlink" title="通过字典创建"></a>通过字典创建</h5><p>字典列表可作为输入数据传递以用来创建数据帧(<em>DataFrame</em>)，字典键默认为列名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">data = [&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;,&#123;<span class="string">'a'</span>:<span class="number">5</span>,<span class="string">'b'</span>:<span class="number">10</span>,<span class="string">'c'</span>:<span class="number">20</span>&#125;]</div><div class="line">df = pd.DataFrame(data)</div><div class="line">print(df)</div><div class="line"><span class="comment">#    a   b     c</span></div><div class="line"><span class="comment"># 0  1   2   NaN</span></div><div class="line"><span class="comment"># 1  5  10  20.0</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">data = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;,&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">20</span>&#125;]</div><div class="line"></div><div class="line"><span class="comment">#With two column indices, values same as dictionary keys</span></div><div class="line">df1 = pd.DataFrame(data, index=[<span class="string">'first'</span>, <span class="string">'second'</span>], columns=[<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"></div><div class="line"><span class="comment">#With two column indices with one index with other name</span></div><div class="line">df2 = pd.DataFrame(data, index=[<span class="string">'first'</span>, <span class="string">'second'</span>], columns=[<span class="string">'a'</span>, <span class="string">'b1'</span>])</div><div class="line">print(df1)</div><div class="line"><span class="comment">#         a   b</span></div><div class="line"><span class="comment"># first   1   2</span></div><div class="line"><span class="comment"># second  5  10</span></div><div class="line">print(df2)</div><div class="line"><span class="comment">#         a  b1</span></div><div class="line"><span class="comment"># first   1 NaN</span></div><div class="line"><span class="comment"># second  5 NaN</span></div></pre></td></tr></table></figure><h5 id="通过系列创建"><a href="#通过系列创建" class="headerlink" title="通过系列创建"></a>通过系列创建</h5><p>字典的系列可以传递以形成一个DataFrame。 所得到的索引是通过的所有系列索引的并集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</div><div class="line">      <span class="string">'two'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;</div><div class="line"></div><div class="line">df = pd.DataFrame(d)</div><div class="line">print(df)</div><div class="line"><span class="comment">#    one  two</span></div><div class="line"><span class="comment"># a  1.0    1</span></div><div class="line"><span class="comment"># b  2.0    2</span></div><div class="line"><span class="comment"># c  3.0    3</span></div><div class="line"><span class="comment"># d  NaN    4</span></div></pre></td></tr></table></figure><h4 id="数据帧访问"><a href="#数据帧访问" class="headerlink" title="数据帧访问"></a>数据帧访问</h4><h5 id="列选择"><a href="#列选择" class="headerlink" title="列选择"></a>列选择</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</div><div class="line">      <span class="string">'two'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;</div><div class="line"></div><div class="line">df = pd.DataFrame(d)</div><div class="line"><span class="keyword">print</span> (df [<span class="string">'one'</span>])</div></pre></td></tr></table></figure><h5 id="列添加"><a href="#列添加" class="headerlink" title="列添加"></a>列添加</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</div><div class="line">      <span class="string">'two'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;</div><div class="line"></div><div class="line">df = pd.DataFrame(d)</div><div class="line"></div><div class="line"><span class="comment"># Adding a new column to an existing DataFrame object with column label by passing new series</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"Adding a new column by passing as Series:"</span>)</div><div class="line">df[<span class="string">'three'</span>]=pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment"># Adding a new column by passing as Series:</span></div><div class="line"><span class="comment">#    one  two  three</span></div><div class="line"><span class="comment"># a  1.0    1   10.0</span></div><div class="line"><span class="comment"># b  2.0    2   20.0</span></div><div class="line"><span class="comment"># c  3.0    3   30.0</span></div><div class="line"><span class="comment"># d  NaN    4    NaN</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"Adding a new column using the existing columns in DataFrame:"</span>)</div><div class="line">df[<span class="string">'four'</span>]=df[<span class="string">'one'</span>]+df[<span class="string">'three'</span>]</div><div class="line"></div><div class="line">print(df)</div><div class="line"><span class="comment"># Adding a new column using the existing columns in DataFrame:</span></div><div class="line"><span class="comment">#    one  two  three  four</span></div><div class="line"><span class="comment"># a  1.0    1   10.0  11.0</span></div><div class="line"><span class="comment"># b  2.0    2   20.0  22.0</span></div><div class="line"><span class="comment"># c  3.0    3   30.0  33.0</span></div><div class="line"><span class="comment"># d  NaN    4    NaN   NaN</span></div></pre></td></tr></table></figure><h5 id="列删除"><a href="#列删除" class="headerlink" title="列删除"></a>列删除</h5><p>列可以删除或弹出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</div><div class="line">     <span class="string">'two'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]),</div><div class="line">     <span class="string">'three'</span> : pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])&#125;</div><div class="line"></div><div class="line">df = pd.DataFrame(d)</div><div class="line"><span class="keyword">print</span> (<span class="string">"Our dataframe is:"</span>)</div><div class="line"><span class="keyword">print</span> (df)</div><div class="line"><span class="comment"># Our dataframe is:</span></div><div class="line"><span class="comment">#    one  three  two</span></div><div class="line"><span class="comment"># a  1.0   10.0    1</span></div><div class="line"><span class="comment"># b  2.0   20.0    2</span></div><div class="line"><span class="comment"># c  3.0   30.0    3</span></div><div class="line"><span class="comment"># d  NaN    NaN    4</span></div><div class="line"></div><div class="line"><span class="comment"># using del function</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"Deleting the first column using DEL function:"</span>)</div><div class="line"><span class="keyword">del</span> df[<span class="string">'one'</span>]</div><div class="line">print(df)</div><div class="line"><span class="comment"># Deleting the first column using DEL function:</span></div><div class="line"><span class="comment">#    three  two</span></div><div class="line"><span class="comment"># a   10.0    1</span></div><div class="line"><span class="comment"># b   20.0    2</span></div><div class="line"><span class="comment"># c   30.0    3</span></div><div class="line"><span class="comment"># d    NaN    4</span></div><div class="line"></div><div class="line"><span class="comment"># using pop function</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"Deleting another column using POP function:"</span>)</div><div class="line">df.pop(<span class="string">'two'</span>)</div><div class="line">print(df)</div><div class="line"><span class="comment"># Deleting another column using POP function:</span></div><div class="line"><span class="comment">#    three</span></div><div class="line"><span class="comment"># a   10.0</span></div><div class="line"><span class="comment"># b   20.0</span></div><div class="line"><span class="comment"># c   30.0</span></div><div class="line"><span class="comment"># d    NaN</span></div></pre></td></tr></table></figure><h5 id="行选择"><a href="#行选择" class="headerlink" title="行选择"></a>行选择</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#通过将行标签传递给loc()函数来选择行。</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</div><div class="line">     <span class="string">'two'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;</div><div class="line"></div><div class="line">df = pd.DataFrame(d)</div><div class="line">print(df.loc[<span class="string">'b'</span>])</div><div class="line"><span class="comment"># one    2.0</span></div><div class="line"><span class="comment"># two    2.0</span></div><div class="line"><span class="comment"># Name: b, dtype: float64</span></div><div class="line"></div><div class="line"><span class="comment">#可以通过将整数位置传递给iloc()函数来选择行</span></div><div class="line">print(df.iloc[<span class="number">2</span>])</div><div class="line"><span class="comment"># one    3.0</span></div><div class="line"><span class="comment"># two    3.0</span></div><div class="line"><span class="comment"># Name: b, dtype: float64</span></div></pre></td></tr></table></figure><h5 id="行切片"><a href="#行切片" class="headerlink" title="行切片"></a>行切片</h5><p>可以使用<code>:</code>运算符选择多行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</div><div class="line">    <span class="string">'two'</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;</div><div class="line"></div><div class="line">df = pd.DataFrame(d)</div><div class="line">print(df[<span class="number">2</span>:<span class="number">4</span>])</div><div class="line"><span class="comment">#    one  two</span></div><div class="line"><span class="comment"># c  3.0    3</span></div><div class="line"><span class="comment"># d  NaN    4</span></div></pre></td></tr></table></figure><h5 id="附加行"><a href="#附加行" class="headerlink" title="附加行"></a>附加行</h5><p>使用<code>append()</code>函数将新行添加到DataFrame</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], columns = [<span class="string">'a'</span>,<span class="string">'b'</span>])</div><div class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], columns = [<span class="string">'a'</span>,<span class="string">'b'</span>])</div><div class="line"></div><div class="line">df = df.append(df2)</div><div class="line">print(df)</div><div class="line"><span class="comment">#    a  b</span></div><div class="line"><span class="comment"># 0  1  2</span></div><div class="line"><span class="comment"># 1  3  4</span></div><div class="line"><span class="comment"># 0  5  6</span></div><div class="line"><span class="comment"># 1  7  8</span></div></pre></td></tr></table></figure><h5 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h5><p>使用索引标签从DataFrame中删除或删除行。 如果标签重复，则会删除多行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], columns = [<span class="string">'a'</span>,<span class="string">'b'</span>])</div><div class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], columns = [<span class="string">'a'</span>,<span class="string">'b'</span>])</div><div class="line"></div><div class="line">df = df.append(df2)</div><div class="line"></div><div class="line"><span class="comment"># Drop rows with label 0</span></div><div class="line">df = df.drop(<span class="number">0</span>)</div><div class="line">print(df)</div><div class="line"><span class="comment">#    a  b</span></div><div class="line"><span class="comment"># 1  3  4</span></div><div class="line"><span class="comment"># 1  7  8</span></div></pre></td></tr></table></figure><h3 id="面板-Panel"><a href="#面板-Panel" class="headerlink" title="面板(Panel)"></a>面板(Panel)</h3><h1 id="Pandas基本功能"><a href="#Pandas基本功能" class="headerlink" title="Pandas基本功能"></a>Pandas基本功能</h1><h2 id="系列基本功能"><a href="#系列基本功能" class="headerlink" title="系列基本功能"></a>系列基本功能</h2><p><img src="/2018/06/08/ML-Pandas/Screen Shot 2018-06-08 at 11.56.57 PM.png" alt="Screen Shot 2018-06-08 at 11.56.57 PM"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment">#Create a series with 100 random numbers</span></div><div class="line">s = pd.Series(np.random.randn(<span class="number">4</span>))</div></pre></td></tr></table></figure><h3 id="axes"><a href="#axes" class="headerlink" title="axes"></a>axes</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"This axes are:"</span>)</div><div class="line">print(s.axes)</div><div class="line"><span class="comment"># This axes are:</span></div><div class="line"><span class="comment"># [RangeIndex(start=0, stop=4, step=1)]</span></div></pre></td></tr></table></figure><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p>返回布尔值，表示对象是否为空。返回<code>True</code>则表示对象为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"Is the Object empty?"</span>)</div><div class="line">print(s.empty)</div><div class="line"><span class="comment"># Is the Object empty?</span></div><div class="line"><span class="comment"># False</span></div></pre></td></tr></table></figure><h3 id="ndim"><a href="#ndim" class="headerlink" title="ndim"></a>ndim</h3><p>返回对象的维数。根据定义，一个系列是一个<code>1D</code>数据结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> (<span class="string">"The dimensions of the object:"</span>)</div><div class="line">print(s.ndim)</div><div class="line"><span class="comment"># The dimensions of the object:</span></div><div class="line"><span class="comment"># 1</span></div></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>返回系列的大小(长度)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> (<span class="string">"The size of the object:"</span>)</div><div class="line"><span class="keyword">print</span> (s.size)</div><div class="line"><span class="comment"># The size of the object:</span></div><div class="line"><span class="comment"># 2</span></div></pre></td></tr></table></figure><h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> (<span class="string">"The actual data series is:"</span>)</div><div class="line"><span class="keyword">print</span> (s.values)</div><div class="line"><span class="comment"># The actual data series is:</span></div><div class="line"><span class="comment"># [-0.15974783  0.75598442 -0.05964617 -0.91200952]</span></div></pre></td></tr></table></figure><h3 id="head-tail"><a href="#head-tail" class="headerlink" title="head-tail"></a>head-tail</h3><p><code>head()</code>返回前<code>n</code>行(观察索引值)。要显示的元素的默认数量为<code>5</code>，但可以传递自定义这个数字值。</p><p><code>tail()</code>返回最后<code>n</code>行(观察索引值)。 要显示的元素的默认数量为<code>5</code>，但可以传递自定义数字值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> (<span class="string">"The original series is:"</span>)</div><div class="line"><span class="keyword">print</span> (s)</div><div class="line"><span class="comment"># The original series is:</span></div><div class="line"><span class="comment"># 0    0.209476</span></div><div class="line"><span class="comment"># 1    0.136436</span></div><div class="line"><span class="comment"># 2   -1.387964</span></div><div class="line"><span class="comment"># 3   -0.102560</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"The first two rows of the data series:"</span>)</div><div class="line"><span class="keyword">print</span> (s.head(<span class="number">2</span>))</div><div class="line"><span class="comment"># The first two rows of the data series:</span></div><div class="line"><span class="comment"># 0    0.209476</span></div><div class="line"><span class="comment"># 1    0.136436</span></div></pre></td></tr></table></figure><h2 id="DataFrame基本功能"><a href="#DataFrame基本功能" class="headerlink" title="DataFrame基本功能"></a>DataFrame基本功能</h2><p><img src="/2018/06/08/ML-Pandas/Screen Shot 2018-06-09 at 12.15.51 AM.png" alt="Screen Shot 2018-06-09 at 12.15.51 AM"></p><h1 id="Pandas描述性统计"><a href="#Pandas描述性统计" class="headerlink" title="Pandas描述性统计"></a>Pandas描述性统计</h1><p><img src="/2018/06/08/ML-Pandas/Screen Shot 2018-06-10 at 10.34.06 AM.png" alt="Screen Shot 2018-06-10 at 10.34.06 AM"></p><blockquote><ul><li>类似于：<code>sum()</code>，<code>cumsum()</code>函数能与数字和字符(或)字符串数据元素一起工作，不会产生任何错误。字符聚合从来都比较少被使用，虽然这些函数不会引发任何异常。</li><li>当DataFrame包含字符或字符串数据时，像<code>abs()</code>，<code>cumprod()</code>这样的函数会抛出异常。</li></ul></blockquote><p>创建一个数据帧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment">#Create a Dictionary of series</span></div><div class="line">d = &#123;<span class="string">'Name'</span>:pd.Series([<span class="string">'Tom'</span>,<span class="string">'James'</span>,<span class="string">'Ricky'</span>,<span class="string">'Vin'</span>,<span class="string">'Steve'</span>,<span class="string">'Minsu'</span>,<span class="string">'Jack'</span>,</div><div class="line">   <span class="string">'Lee'</span>,<span class="string">'David'</span>,<span class="string">'Gasper'</span>,<span class="string">'Betina'</span>,<span class="string">'Andres'</span>]),</div><div class="line">   <span class="string">'Age'</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</div><div class="line">   <span class="string">'Rating'</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</div><div class="line"></div><div class="line"><span class="comment">#Create a DataFrame</span></div><div class="line">df = pd.DataFrame(d)</div><div class="line">print(df)</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Age</th><th style="text-align:center">Name</th><th style="text-align:center">Rating</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">25</td><td style="text-align:center">Tom</td><td style="text-align:center">4.23</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">26</td><td style="text-align:center">James</td><td style="text-align:center">3.24</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">25</td><td style="text-align:center">Ricky</td><td style="text-align:center">3.98</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">23</td><td style="text-align:center">Vin</td><td style="text-align:center">2.56</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">30</td><td style="text-align:center">Steve</td><td style="text-align:center">3.20</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">29</td><td style="text-align:center">Minsu</td><td style="text-align:center">4.60</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">23</td><td style="text-align:center">Jack</td><td style="text-align:center">3.80</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">34</td><td style="text-align:center">Lee</td><td style="text-align:center">3.78</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">40</td><td style="text-align:center">David</td><td style="text-align:center">2.98</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">30</td><td style="text-align:center">Gasper</td><td style="text-align:center">4.80</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">51</td><td style="text-align:center">Betina</td><td style="text-align:center">4.10</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">46</td><td style="text-align:center">Andres</td><td style="text-align:center">3.65</td></tr></tbody></table></div><h2 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h2><p>返回所请求轴的值的总和。 默认情况下，轴为索引(<code>axis=0</code>)，即对列sum</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(df.sum())</div><div class="line"><span class="comment"># Age                                                     382</span></div><div class="line"><span class="comment"># Name      TomJamesRickyVinSteveMinsuJackLeeDavidGasperBe...</span></div><div class="line"><span class="comment"># Rating                                                44.92</span></div><div class="line"><span class="comment"># dtype: object</span></div></pre></td></tr></table></figure><p><strong>axis=1</strong>,则对行sum</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">print(df.sum(<span class="number">1</span>))</div><div class="line"><span class="comment"># 0     29.23</span></div><div class="line"><span class="comment"># 1     29.24</span></div><div class="line"><span class="comment"># 2     28.98</span></div><div class="line"><span class="comment"># 3     25.56</span></div><div class="line"><span class="comment"># 4     33.20</span></div><div class="line"><span class="comment"># 5     33.60</span></div><div class="line"><span class="comment"># 6     26.80</span></div><div class="line"><span class="comment"># 7     37.78</span></div><div class="line"><span class="comment"># 8     42.98</span></div><div class="line"><span class="comment"># 9     34.80</span></div><div class="line"><span class="comment"># 10    55.10</span></div><div class="line"><span class="comment"># 11    49.65</span></div></pre></td></tr></table></figure><h2 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h2><p>与sum()用法一样，默认是对列求均值；mean(1)则是对每一行求均值。</p><h2 id="std"><a href="#std" class="headerlink" title="std()"></a>std()</h2><p>返回数字列的Bressel标准偏差。</p><h2 id="数据汇总"><a href="#数据汇总" class="headerlink" title="数据汇总"></a>数据汇总</h2><p><strong>describe()</strong>函数是用来计算有关DataFrame列的统计信息的摘要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">print(df.describe())</div><div class="line"><span class="comment">#              Age     Rating</span></div><div class="line"><span class="comment"># count  12.000000  12.000000</span></div><div class="line"><span class="comment"># mean   31.833333   3.743333</span></div><div class="line"><span class="comment"># std     9.232682   0.661628</span></div><div class="line"><span class="comment"># min    23.000000   2.560000</span></div><div class="line"><span class="comment"># 25%    25.000000   3.230000</span></div><div class="line"><span class="comment"># 50%    29.500000   3.790000</span></div><div class="line"><span class="comment"># 75%    35.500000   4.132500</span></div><div class="line"><span class="comment"># max    51.000000   4.800000</span></div></pre></td></tr></table></figure><p><strong>include</strong>是用于传递关于什么列需要考虑用于总结的必要信息的参数。获取值列表; 默认情况下是”数字值”。</p><ul><li><code>object</code> - 汇总字符串列</li><li><code>number</code> - 汇总数字列</li><li><code>all</code> - 将所有列汇总在一起(不应将其作为列表值传递)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">print(df.describe(include=[<span class="string">'object'</span>]))</div><div class="line"><span class="comment">#          Name</span></div><div class="line"><span class="comment"># count      12</span></div><div class="line"><span class="comment"># unique     12</span></div><div class="line"><span class="comment"># top     James</span></div><div class="line"><span class="comment"># freq        1</span></div></pre></td></tr></table></figure><h1 id="Pandas函数"><a href="#Pandas函数" class="headerlink" title="Pandas函数"></a>Pandas函数</h1><p>以下三种方法是要将自己或其他库的函数应用于Pandas对象，使用适当的方法取决于函数是否期望在整个DataFrame，行或列或元素上进行操作。</p><ul><li>pipe() : 表明智函数应用</li><li>apply() : 行或列函数应用</li><li>applymap() : 元素函数应用</li></ul><h2 id="pipe表格函数"><a href="#pipe表格函数" class="headerlink" title="pipe表格函数"></a>pipe表格函数</h2><p>可以通过将函数和适当数量的参数作为管道参数来执行自定义操作。 因此，对整个DataFrame执行操作。例如，为DataFrame中的所有元素相加一个值<code>2</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(ele1,ele2)</span>:</span></div><div class="line">   <span class="keyword">return</span> ele1+ele2</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">5</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line">df.pipe(adder,<span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> (df)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  0.298525 -0.950629  0.164956</span></div><div class="line"><span class="comment"># 1  0.518124  0.952160  0.882564</span></div><div class="line"><span class="comment"># 2  1.215512  2.330336 -1.078768</span></div><div class="line"><span class="comment"># 3 -0.672469  0.139257  0.871575</span></div><div class="line"><span class="comment"># 4 -1.038358  1.132721 -0.705976</span></div><div class="line">print(df.pipe(adder,<span class="number">2</span>)) <span class="comment">#对所有元素加2</span></div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  2.298525  1.049371  2.164956</span></div><div class="line"><span class="comment"># 1  2.518124  2.952160  2.882564</span></div><div class="line"><span class="comment"># 2  3.215512  4.330336  0.921232</span></div><div class="line"><span class="comment"># 3  1.327531  2.139257  2.871575</span></div><div class="line"><span class="comment"># 4  0.961642  3.132721  1.294024</span></div></pre></td></tr></table></figure><h2 id="appy行或列智能函数应用"><a href="#appy行或列智能函数应用" class="headerlink" title="appy行或列智能函数应用"></a>appy行或列智能函数应用</h2><p>可以使用<code>apply()</code>方法沿<code>DataFrame</code>或<code>Panel</code>的轴应用任意函数，它与描述性统计方法一样，采用可选的轴参数。 默认情况下，操作按列执行，将每列列为数组。指定axis=1,则按照行执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(ele1,ele2)</span>:</span></div><div class="line">   <span class="keyword">return</span> ele1+ele2</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">5</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line"><span class="keyword">print</span> (df)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  0.080134 -0.848024 -0.801573</span></div><div class="line"><span class="comment"># 1 -1.464748 -0.257665 -0.799735</span></div><div class="line"><span class="comment"># 2  0.260537 -0.944930 -0.119062</span></div><div class="line"><span class="comment"># 3  2.061183 -0.904605  0.099470</span></div><div class="line"><span class="comment"># 4  0.114762 -0.927484  0.561150</span></div><div class="line">print(df.apply(np.mean)) <span class="comment">#print(df.apply(np.mean,axis=1))</span></div><div class="line"><span class="comment"># col1    0.210374</span></div><div class="line"><span class="comment"># col2   -0.776542</span></div><div class="line"><span class="comment"># col3   -0.211950</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(ele1,ele2)</span>:</span></div><div class="line">   <span class="keyword">return</span> ele1+ele2</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">5</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line"><span class="keyword">print</span> (df)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  0.869596  0.284294  1.302871</span></div><div class="line"><span class="comment"># 1  0.761678  1.430786 -0.708223</span></div><div class="line"><span class="comment"># 2 -0.020315  0.643858  1.274853</span></div><div class="line"><span class="comment"># 3  0.124935  0.165798  1.003215</span></div><div class="line"><span class="comment"># 4 -0.201225  1.139868  1.455647</span></div><div class="line">print(df.apply(<span class="keyword">lambda</span> x:x.max()-x.min()))<span class="comment">#lambda x:定义了一个函数</span></div><div class="line"><span class="comment"># col1    1.070822</span></div><div class="line"><span class="comment"># col2    1.264987</span></div><div class="line"><span class="comment"># col3    2.163870</span></div><div class="line"><span class="keyword">print</span> (df) <span class="comment">#apply不改变df的数据</span></div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  0.869596  0.284294  1.302871</span></div><div class="line"><span class="comment"># 1  0.761678  1.430786 -0.708223</span></div><div class="line"><span class="comment"># 2 -0.020315  0.643858  1.274853</span></div><div class="line"><span class="comment"># 3  0.124935  0.165798  1.003215</span></div><div class="line"><span class="comment"># 4 -0.201225  1.139868  1.455647</span></div></pre></td></tr></table></figure><h2 id="applymap元素智能函数"><a href="#applymap元素智能函数" class="headerlink" title="applymap元素智能函数"></a>applymap元素智能函数</h2><p>并不是所有的函数都可以向量化(也不是返回另一个数组的NumPy数组，也不是任何值)，在DataFrame上的方法<code>applymap()</code>和类似地在Series上的<code>map()</code>接受任何Python函数，并且返回单个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">5</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line"></div><div class="line"><span class="comment"># My custom function</span></div><div class="line">print(df)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0 -0.645335 -0.014233 -0.228133</span></div><div class="line"><span class="comment"># 1  0.343590  1.726889 -0.303263</span></div><div class="line"><span class="comment"># 2 -0.179465  0.859529  0.736120</span></div><div class="line"><span class="comment"># 3 -0.459130 -0.487665 -0.078175</span></div><div class="line"><span class="comment"># 4  0.256705  1.299887  0.151205</span></div><div class="line">print(df[<span class="string">'col1'</span>].map(<span class="keyword">lambda</span> x:x*<span class="number">100</span>))<span class="comment">#因为是对列操作，所以map</span></div><div class="line"><span class="comment"># 0   -64.533532</span></div><div class="line"><span class="comment"># 1    34.359000</span></div><div class="line"><span class="comment"># 2   -17.946528</span></div><div class="line"><span class="comment"># 3   -45.913013</span></div><div class="line"><span class="comment"># 4    25.670518</span></div><div class="line"></div><div class="line">print(df.applymap(<span class="keyword">lambda</span> x:x*<span class="number">100</span>))</div><div class="line"><span class="comment">#          col1        col2        col3</span></div><div class="line"><span class="comment"># 0  -69.502940  -16.032075  -55.610105</span></div><div class="line"><span class="comment"># 1   28.380491   23.122472  102.260899</span></div><div class="line"><span class="comment"># 2  -71.143064  -12.581149  145.453437</span></div><div class="line"><span class="comment"># 3  145.381364 -128.505845  -58.202885</span></div><div class="line"><span class="comment"># 4   10.271497  -26.350430   56.805339</span></div></pre></td></tr></table></figure><h1 id="Pandas重建索引"><a href="#Pandas重建索引" class="headerlink" title="Pandas重建索引"></a>Pandas重建索引</h1><p>重新索引会更改DataFrame的行标签和列标签。重新索引意味着符合数据以匹配特定轴上的一组给定的标签。</p><p>可以通过索引来实现多个操作 -</p><ul><li>重新排序现有数据以匹配一组新的标签。</li><li>在没有标签数据的标签位置插入缺失值(NA)标记。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">N=<span class="number">20</span></div><div class="line"></div><div class="line">df = pd.DataFrame(&#123;</div><div class="line">   <span class="string">'A'</span>: pd.date_range(start=<span class="string">'2016-01-01'</span>,periods=N,freq=<span class="string">'D'</span>),</div><div class="line">   <span class="string">'x'</span>: np.linspace(<span class="number">0</span>,stop=N<span class="number">-1</span>,num=N),</div><div class="line">   <span class="string">'y'</span>: np.random.rand(N),</div><div class="line">   <span class="string">'C'</span>: np.random.choice([<span class="string">'Low'</span>,<span class="string">'Medium'</span>,<span class="string">'High'</span>],N).tolist(),</div><div class="line">   <span class="string">'D'</span>: np.random.normal(<span class="number">100</span>, <span class="number">10</span>, size=(N)).tolist()</div><div class="line">&#125;)</div><div class="line"></div><div class="line">print(df)</div><div class="line"><span class="comment">#             A       C           D     x         y</span></div><div class="line"><span class="comment"># 0  2016-01-01    High  106.422798   0.0  0.670789</span></div><div class="line"><span class="comment"># 1  2016-01-02  Medium   90.168862   1.0  0.868026</span></div><div class="line"><span class="comment"># 2  2016-01-03    High   96.854027   2.0  0.974715</span></div><div class="line"><span class="comment"># 3  2016-01-04    High   98.622810   3.0  0.944312</span></div><div class="line"><span class="comment"># 4  2016-01-05  Medium  105.046802   4.0  0.922507</span></div><div class="line"><span class="comment"># 5  2016-01-06     Low  115.478319   5.0  0.091310</span></div><div class="line"><span class="comment"># 6  2016-01-07     Low   91.814775   6.0  0.397314</span></div><div class="line"><span class="comment"># 7  2016-01-08    High   95.030925   7.0  0.545544</span></div><div class="line"><span class="comment"># 8  2016-01-09  Medium  102.620742   8.0  0.214454</span></div><div class="line"><span class="comment"># 9  2016-01-10  Medium  102.370108   9.0  0.933056</span></div><div class="line"><span class="comment"># 10 2016-01-11  Medium   91.638636  10.0  0.464718</span></div><div class="line"><span class="comment"># 11 2016-01-12  Medium   83.425189  11.0  0.267500</span></div><div class="line"><span class="comment"># 12 2016-01-13  Medium  113.570416  12.0  0.899810</span></div><div class="line"><span class="comment"># 13 2016-01-14     Low  129.166525  13.0  0.818797</span></div><div class="line"><span class="comment"># 14 2016-01-15  Medium  105.074786  14.0  0.786602</span></div><div class="line"><span class="comment"># 15 2016-01-16    High  102.818441  15.0  0.451534</span></div><div class="line"><span class="comment"># 16 2016-01-17  Medium   95.567230  16.0  0.739450</span></div><div class="line"><span class="comment"># 17 2016-01-18    High  112.581924  17.0  0.550433</span></div><div class="line"><span class="comment"># 18 2016-01-19    High  114.526018  18.0  0.993903</span></div><div class="line"><span class="comment"># 19 2016-01-20     Low  111.224149  19.0  0.328954</span></div><div class="line"></div><div class="line"><span class="comment">#reindex the DataFrame</span></div><div class="line">df_reindexed = df.reindex(index=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>], columns=[<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>])</div><div class="line"></div><div class="line"><span class="keyword">print</span> (df_reindexed)</div><div class="line"><span class="comment">#            A     C   B</span></div><div class="line"><span class="comment"># 0 2016-01-01  High NaN</span></div><div class="line"><span class="comment"># 2 2016-01-03  High NaN</span></div><div class="line"><span class="comment"># 5 2016-01-06   Low NaN</span></div></pre></td></tr></table></figure><h2 id="重建索引与其他对象对齐"><a href="#重建索引与其他对象对齐" class="headerlink" title="重建索引与其他对象对齐"></a>重建索引与其他对象对齐</h2><p>有时可能希望采取一个对象和重新索引，其轴被标记为与另一个对象相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">7</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line"></div><div class="line">print(df1)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  1.690225 -0.237625  0.682889</span></div><div class="line"><span class="comment"># 1  0.529209  0.531100 -1.973715</span></div><div class="line"><span class="comment"># 2  1.363789 -0.070481  1.149173</span></div><div class="line"><span class="comment"># 3  0.963786  0.378348  0.543242</span></div><div class="line"><span class="comment"># 4 -1.181315  0.453184  1.335767</span></div><div class="line"><span class="comment"># 5 -1.260020 -0.042963  0.210953</span></div><div class="line"><span class="comment"># 6 -0.218576 -1.195482 -1.600476</span></div><div class="line"><span class="comment"># 7  0.347295  0.677118 -2.225262</span></div><div class="line"><span class="comment"># 8  1.349135  0.672671  1.647481</span></div><div class="line"><span class="comment"># 9  2.080021  1.322867  1.502295</span></div><div class="line">print(df2)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0 -0.500110  1.379281 -0.323381</span></div><div class="line"><span class="comment"># 1 -0.498182  0.365029  0.161133</span></div><div class="line"><span class="comment"># 2 -0.598007 -0.010500 -1.304982</span></div><div class="line"><span class="comment"># 3  0.701804 -0.097031 -0.770933</span></div><div class="line"><span class="comment"># 4  1.406598 -0.765083  0.557169</span></div><div class="line"><span class="comment"># 5  0.171932  0.518117 -0.263640</span></div><div class="line"><span class="comment"># 6  0.792754  0.424461  0.602631</span></div><div class="line">df1 = df1.reindex_like(df2)</div><div class="line"><span class="keyword">print</span> (df1)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  1.690225 -0.237625  0.682889</span></div><div class="line"><span class="comment"># 1  0.529209  0.531100 -1.973715</span></div><div class="line"><span class="comment"># 2  1.363789 -0.070481  1.149173</span></div><div class="line"><span class="comment"># 3  0.963786  0.378348  0.543242</span></div><div class="line"><span class="comment"># 4 -1.181315  0.453184  1.335767</span></div><div class="line"><span class="comment"># 5 -1.260020 -0.042963  0.210953</span></div><div class="line"><span class="comment"># 6 -0.218576 -1.195482 -1.600476</span></div></pre></td></tr></table></figure><blockquote><p>注意 - 在这里，<code>df1</code>数据帧(<em>DataFrame</em>)被更改并重新编号，如<code>df2</code>。 列名称应该匹配，否则将为整个列标签添加<code>NAN</code>。</p></blockquote><h2 id="填充时重新加注"><a href="#填充时重新加注" class="headerlink" title="填充时重新加注"></a>填充时重新加注</h2><p><code>reindex()</code>采用可选参数方法，它是一个填充方法，其值如下：</p><ul><li><code>pad/ffill</code> - 向前填充值</li><li><code>bfill/backfill</code> - 向后填充值</li><li><code>nearest</code> - 从最近的索引值填充</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line"></div><div class="line"><span class="comment"># Padding NAN's</span></div><div class="line"><span class="keyword">print</span> (df2.reindex_like(df1))</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  1.598405  1.451217  1.383048</span></div><div class="line"><span class="comment"># 1 -0.695038 -1.105388 -0.774673</span></div><div class="line"><span class="comment"># 2       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 3       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 4       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 5       NaN       NaN       NaN</span></div><div class="line"></div><div class="line"><span class="comment"># Now Fill the NAN's with preceding Values</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"Data Frame with Forward Fill:"</span>)</div><div class="line"><span class="keyword">print</span> (df2.reindex_like(df1,method=<span class="string">'ffill'</span>))</div><div class="line"><span class="comment"># Data Frame with Forward Fill:</span></div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  1.598405  1.451217  1.383048</span></div><div class="line"><span class="comment"># 1 -0.695038 -1.105388 -0.774673</span></div><div class="line"><span class="comment"># 2 -0.695038 -1.105388 -0.774673</span></div><div class="line"><span class="comment"># 3 -0.695038 -1.105388 -0.774673</span></div><div class="line"><span class="comment"># 4 -0.695038 -1.105388 -0.774673</span></div><div class="line"><span class="comment"># 5 -0.695038 -1.105388 -0.774673</span></div></pre></td></tr></table></figure><blockquote><p>注 - 最后四行被填充了。</p></blockquote><h3 id="重建索引时的填充限制"><a href="#重建索引时的填充限制" class="headerlink" title="重建索引时的填充限制"></a>重建索引时的填充限制</h3><p>限制参数在重建索引时提供对填充的额外控制。限制指定连续匹配的最大计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line"></div><div class="line"><span class="comment"># Padding NAN's</span></div><div class="line"><span class="keyword">print</span> (df2.reindex_like(df1))</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  0.424747 -0.060944 -1.374431</span></div><div class="line"><span class="comment"># 1  0.897544  0.922728 -0.951170</span></div><div class="line"><span class="comment"># 2       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 3       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 4       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 5       NaN       NaN       NaN</span></div><div class="line"></div><div class="line"><span class="comment"># Now Fill the NAN's with preceding Values</span></div><div class="line"><span class="keyword">print</span> (<span class="string">"Data Frame with Forward Fill limiting to 1:"</span>)</div><div class="line"><span class="keyword">print</span> (df2.reindex_like(df1,method=<span class="string">'ffill'</span>,limit=<span class="number">1</span>))</div><div class="line"><span class="comment"># Data Frame with Forward Fill limiting to 1:</span></div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  0.424747 -0.060944 -1.374431</span></div><div class="line"><span class="comment"># 1  0.897544  0.922728 -0.951170</span></div><div class="line"><span class="comment"># 2  0.897544  0.922728 -0.951170</span></div><div class="line"><span class="comment"># 3       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 4       NaN       NaN       NaN</span></div><div class="line"><span class="comment"># 5       NaN       NaN       NaN</span></div></pre></td></tr></table></figure><blockquote><p>注意 - 只有第<code>7</code>行由前<code>6</code>行填充。 然后，其它行按原样保留。</p></blockquote><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p><code>rename()</code>方法允许基于一些映射(字典或者系列)或任意函数来重新标记一个轴。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line"><span class="keyword">print</span> (df1)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0 -0.162633  0.487238  0.376467</span></div><div class="line"><span class="comment"># 1 -0.370538 -1.132116  0.320140</span></div><div class="line"><span class="comment"># 2 -1.611416  1.934140  0.223959</span></div><div class="line"><span class="comment"># 3  0.220631  0.303568 -1.636330</span></div><div class="line"><span class="comment"># 4  1.412771 -0.428163 -1.034903</span></div><div class="line"><span class="comment"># 5 -0.804933 -1.000358  0.886100</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"After renaming the rows and columns:"</span>)</div><div class="line"><span class="keyword">print</span> (df1.rename(columns=&#123;<span class="string">'col1'</span> : <span class="string">'c1'</span>, <span class="string">'col2'</span> : <span class="string">'c2'</span>&#125;,index = &#123;<span class="number">0</span> : <span class="string">'apple'</span>, <span class="number">1</span> : <span class="string">'banana'</span>, <span class="number">2</span> : <span class="string">'durian'</span>&#125;))</div><div class="line"><span class="comment"># After renaming the rows and columns:</span></div><div class="line"><span class="comment">#               c1        c2      col3</span></div><div class="line"><span class="comment"># apple  -0.162633  0.487238  0.376467</span></div><div class="line"><span class="comment"># banana -0.370538 -1.132116  0.320140</span></div><div class="line"><span class="comment"># durian -1.611416  1.934140  0.223959</span></div><div class="line"><span class="comment"># 3       0.220631  0.303568 -1.636330</span></div><div class="line"><span class="comment"># 4       1.412771 -0.428163 -1.034903</span></div><div class="line"><span class="comment"># 5      -0.804933 -1.000358  0.886100</span></div></pre></td></tr></table></figure><h1 id="Pandas迭代"><a href="#Pandas迭代" class="headerlink" title="Pandas迭代"></a>Pandas迭代</h1><p><code>Pandas</code>对象之间的基本迭代的行为取决于类型。当迭代一个系列时，它被视为数组式，基本迭代产生这些值。其他数据结构，如：<code>DataFrame</code>和<code>Panel</code>，遵循类似惯例迭代对象的键。</p><p>简而言之，基本迭代(对于<code>i</code>在对象中)产生 -</p><ul><li><em>Series</em> - 值</li><li><em>DataFrame</em> - 列标签</li><li><em>Pannel</em> - 项目标签</li></ul><h2 id="DataFrame迭代"><a href="#DataFrame迭代" class="headerlink" title="DataFrame迭代"></a>DataFrame迭代</h2><p>要遍历数据帧(DataFrame)中的行，可以使用以下函数 -</p><ul><li><code>iteritems()</code> - 迭代<code>(key，value)</code>对</li><li><code>iterrows()</code> - 将行迭代为(索引，系列)对</li><li><code>itertuples()</code> - 以<code>namedtuples</code>的形式迭代行</li></ul><blockquote><p>注意 - 不要尝试在迭代时修改任何对象。迭代是用于读取，迭代器返回原始对象(视图)的副本，因此更改将不会反映在原始对象上。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">N=<span class="number">5</span></div><div class="line"></div><div class="line">df = pd.DataFrame(&#123;</div><div class="line">    <span class="string">'A'</span>: pd.date_range(start=<span class="string">'2016-01-01'</span>,periods=N,freq=<span class="string">'D'</span>),</div><div class="line">    <span class="string">'x'</span>: np.linspace(<span class="number">0</span>,stop=N<span class="number">-1</span>,num=N),</div><div class="line">    <span class="string">'y'</span>: np.random.rand(N),</div><div class="line">    <span class="string">'C'</span>: np.random.choice([<span class="string">'Low'</span>,<span class="string">'Medium'</span>,<span class="string">'High'</span>],N).tolist(),</div><div class="line">    <span class="string">'D'</span>: np.random.normal(<span class="number">100</span>, <span class="number">10</span>, size=(N)).tolist()</div><div class="line">    &#125;)</div><div class="line">print(df)</div><div class="line"><span class="comment">#            A       C           D    x         y</span></div><div class="line"><span class="comment"># 0 2016-01-01  Medium   68.074794  0.0  0.155689</span></div><div class="line"><span class="comment"># 1 2016-01-02     Low  102.783422  1.0  0.499028</span></div><div class="line"><span class="comment"># 2 2016-01-03     Low   99.767849  2.0  0.072982</span></div><div class="line"><span class="comment"># 3 2016-01-04     Low  121.020377  3.0  0.912389</span></div><div class="line"><span class="comment"># 4 2016-01-05  Medium  108.772650  4.0  0.624642</span></div><div class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df:</div><div class="line">   <span class="keyword">print</span> (col)</div><div class="line"><span class="comment"># A</span></div><div class="line"><span class="comment"># C</span></div><div class="line"><span class="comment"># D</span></div><div class="line"><span class="comment"># x</span></div><div class="line"><span class="comment"># y</span></div></pre></td></tr></table></figure><h3 id="iteritems"><a href="#iteritems" class="headerlink" title="iteritems()"></a>iteritems()</h3><p>将每个列作为键，将值与值作为键和列值迭代为Series对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),columns=[<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0 -0.087990 -0.049726  0.572913</span></div><div class="line"><span class="comment"># 1  0.859409  0.695247 -1.382812</span></div><div class="line"><span class="comment"># 2  0.275735 -0.528393 -0.814816</span></div><div class="line"><span class="comment"># 3  0.020638 -0.448942 -1.757958</span></div><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> df.iteritems():</div><div class="line">   <span class="keyword">print</span> (key,<span class="string">"---"</span>,value)</div><div class="line"><span class="comment"># col1 --- 0   -0.087990</span></div><div class="line"><span class="comment"># 1    0.859409</span></div><div class="line"><span class="comment"># 2    0.275735</span></div><div class="line"><span class="comment"># 3    0.020638</span></div><div class="line"><span class="comment"># Name: col1, dtype: float64</span></div><div class="line"><span class="comment"># col2 --- 0   -0.049726</span></div><div class="line"><span class="comment"># 1    0.695247</span></div><div class="line"><span class="comment"># 2   -0.528393</span></div><div class="line"><span class="comment"># 3   -0.448942</span></div><div class="line"><span class="comment"># Name: col2, dtype: float64</span></div><div class="line"><span class="comment"># col3 --- 0    0.572913</span></div><div class="line"><span class="comment"># 1   -1.382812</span></div><div class="line"><span class="comment"># 2   -0.814816</span></div><div class="line"><span class="comment"># 3   -1.757958</span></div><div class="line"><span class="comment"># Name: col3, dtype: float64</span></div></pre></td></tr></table></figure><h3 id="iterrows"><a href="#iterrows" class="headerlink" title="iterrows()"></a>iterrows()</h3><p><code>iterrows()</code>返回迭代器，产生每个索引值以及包含每行数据的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),columns = [<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0  0.674005  0.042299  0.211592</span></div><div class="line"><span class="comment"># 1  1.080131  1.020547 -1.596309</span></div><div class="line"><span class="comment"># 2 -0.717016 -0.323693  0.697079</span></div><div class="line"><span class="comment"># 3  0.158146  0.936253 -0.103222</span></div><div class="line"><span class="keyword">for</span> row_index,row <span class="keyword">in</span> df.iterrows():</div><div class="line">   <span class="keyword">print</span> (row_index,<span class="string">"---"</span>,row)</div><div class="line"><span class="comment"># 0 --- col1    0.674005</span></div><div class="line"><span class="comment"># col2    0.042299</span></div><div class="line"><span class="comment"># col3    0.211592</span></div><div class="line"><span class="comment"># Name: 0, dtype: float64</span></div><div class="line"><span class="comment"># 1 --- col1    1.080131</span></div><div class="line"><span class="comment"># col2    1.020547</span></div><div class="line"><span class="comment"># col3   -1.596309</span></div><div class="line"><span class="comment"># Name: 1, dtype: float64</span></div><div class="line"><span class="comment"># 2 --- col1   -0.717016</span></div><div class="line"><span class="comment"># col2   -0.323693</span></div><div class="line"><span class="comment"># col3    0.697079</span></div><div class="line"><span class="comment"># Name: 2, dtype: float64</span></div><div class="line"><span class="comment"># 3 --- col1    0.158146</span></div><div class="line"><span class="comment"># col2    0.936253</span></div><div class="line"><span class="comment"># col3   -0.103222</span></div><div class="line"><span class="comment"># Name: 3, dtype: float64</span></div></pre></td></tr></table></figure><h3 id="itertuples"><a href="#itertuples" class="headerlink" title="itertuples()"></a>itertuples()</h3><p><code>itertuples()</code>方法将为<code>DataFrame</code>中的每一行返回一个产生一个命名元组的迭代器。元组的第一个元素将是行的相应索引值，而剩余的值是行值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),columns = [<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#        col1      col2      col3</span></div><div class="line"><span class="comment"># 0 -3.525917  0.557613 -0.740162</span></div><div class="line"><span class="comment"># 1 -0.672476 -0.932059  0.638660</span></div><div class="line"><span class="comment"># 2 -0.138301  0.783534 -0.699881</span></div><div class="line"><span class="comment"># 3 -1.003695 -0.485473 -0.651522</span></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</div><div class="line">    <span class="keyword">print</span> (row)</div><div class="line"><span class="comment"># Pandas(Index=0, col1=-3.525917244517192, col2=0.5576131753319682, col3=-0.7401618735482571)</span></div><div class="line"><span class="comment"># Pandas(Index=1, col1=-0.6724761731790204, col2=-0.9320585818750085, col3=0.6386597998390104)</span></div><div class="line"><span class="comment"># Pandas(Index=2, col1=-0.13830132314512975, col2=0.7835337994714413, col3=-0.6998806104325761)</span></div><div class="line"><span class="comment"># Pandas(Index=3, col1=-1.003694634971743, col2=-0.4854728772237874, col3=-0.651522414077405)</span></div></pre></td></tr></table></figure><h1 id="Pandas排序"><a href="#Pandas排序" class="headerlink" title="Pandas排序"></a>Pandas排序</h1><p><em>Pandas</em>有两种排序方式，它们分别是 -</p><ul><li>按标签</li><li>按实际值</li></ul><h2 id="以标签排序"><a href="#以标签排序" class="headerlink" title="以标签排序"></a>以标签排序</h2><p>使用<code>sort_index()</code>方法，通过传递<code>axis</code>参数和排序顺序，可以对<code>DataFrame</code>进行排序。 默认情况下，按照升序对行标签进行排序。</p><p>通过传递<code>axis</code>参数值为<code>0</code>或<code>1</code>，可以对列标签进行排序。 默认情况下，<code>axis = 0</code>，逐行排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">unsorted_df=pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>],columns=[<span class="string">'col2'</span>,<span class="string">'col1'</span>])</div><div class="line"><span class="keyword">print</span> (unsorted_df)</div><div class="line"><span class="comment">#        col2      col1</span></div><div class="line"><span class="comment"># 1  1.013623  0.889024</span></div><div class="line"><span class="comment"># 4  1.058798 -0.076676</span></div><div class="line"><span class="comment"># 6 -0.277161  0.665921</span></div><div class="line"><span class="comment"># 2  0.019196  0.636835</span></div><div class="line"><span class="comment"># 3  0.776214 -0.178358</span></div><div class="line"><span class="comment"># 5  0.112524  3.321190</span></div><div class="line"><span class="comment"># 9 -1.172484 -1.609542</span></div><div class="line"><span class="comment"># 8  0.081354  0.878184</span></div><div class="line"><span class="comment"># 0 -1.336118 -0.085982</span></div><div class="line"><span class="comment"># 7  1.398648  0.750015</span></div><div class="line"></div><div class="line">sorted_df=unsorted_df.sort_index() <span class="comment"># sorted_df = unsorted_df.sort_index(ascending=False)降序排序</span></div><div class="line"><span class="keyword">print</span> (sorted_df)</div><div class="line"><span class="comment">#        col2      col1</span></div><div class="line"><span class="comment"># 0 -1.336118 -0.085982</span></div><div class="line"><span class="comment"># 1  1.013623  0.889024</span></div><div class="line"><span class="comment"># 2  0.019196  0.636835</span></div><div class="line"><span class="comment"># 3  0.776214 -0.178358</span></div><div class="line"><span class="comment"># 4  1.058798 -0.076676</span></div><div class="line"><span class="comment"># 5  0.112524  3.321190</span></div><div class="line"><span class="comment"># 6 -0.277161  0.665921</span></div><div class="line"><span class="comment"># 7  1.398648  0.750015</span></div><div class="line"><span class="comment"># 8  0.081354  0.878184</span></div><div class="line"><span class="comment"># 9 -1.172484 -1.609542</span></div></pre></td></tr></table></figure><h2 id="以值排序"><a href="#以值排序" class="headerlink" title="以值排序"></a>以值排序</h2><p>像索引排序一样，<code>sort_values()</code>是按值排序的方法。它接受一个<code>by</code>参数，它将使用要与其排序值的<code>DataFrame</code>的列名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">unsorted_df = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">'col2'</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]&#125;)</div><div class="line">print(unsorted_df)</div><div class="line"><span class="comment">#    col1  col2</span></div><div class="line"><span class="comment"># 0     2     1</span></div><div class="line"><span class="comment"># 1     1     3</span></div><div class="line"><span class="comment"># 2     1     2</span></div><div class="line"><span class="comment"># 3     1     4</span></div><div class="line">sorted_df = unsorted_df.sort_values(by=<span class="string">'col1'</span>)</div><div class="line"><span class="keyword">print</span> (sorted_df) <span class="comment"># col1值被排序，相应的col2值和行索引将随col1一起改变。</span></div><div class="line"><span class="comment">#    col1  col2</span></div><div class="line"><span class="comment"># 1     1     3</span></div><div class="line"><span class="comment"># 2     1     2</span></div><div class="line"><span class="comment"># 3     1     4</span></div><div class="line"><span class="comment"># 0     2     1</span></div></pre></td></tr></table></figure><p>通过<code>by</code>参数指定需要列值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sorted_df = unsorted_df.sort_values(by=[<span class="string">'col1'</span>,<span class="string">'col2'</span>])</div><div class="line"><span class="keyword">print</span> (sorted_df)</div><div class="line"><span class="comment">#    col1  col2</span></div><div class="line"><span class="comment"># 2     1     2</span></div><div class="line"><span class="comment"># 1     1     3</span></div><div class="line"><span class="comment"># 3     1     4</span></div><div class="line"><span class="comment"># 0     2     1</span></div></pre></td></tr></table></figure><blockquote><p>先对col1列排序，使该列有序，同时col2也对应变化为3，2，4，1.接着对col2列排序，这时对前一列相同的值情况下再排序，即3，2，4排序为2，3，4.这样前一列还是有序的</p></blockquote><h1 id="Pandas索引和数据选择"><a href="#Pandas索引和数据选择" class="headerlink" title="Pandas索引和数据选择"></a>Pandas索引和数据选择</h1><p><img src="/2018/06/08/ML-Pandas/Screen Shot 2018-06-11 at 3.17.18 PM.png" alt="Screen Shot 2018-06-11 at 3.17.18 PM"></p><h2 id="loc"><a href="#loc" class="headerlink" title=".loc()"></a>.loc()</h2><p><code>.loc()</code>具有多种访问方式，如 -</p><ul><li>单个标量标签</li><li>标签列表</li><li>切片对象</li><li>一个布尔数组</li></ul><p><code>loc</code>需要两个单/列表/范围运算符，用<code>&quot;,&quot;</code>分隔。第一个表示行，第二个表示列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#import the pandas library and aliasing as pd</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">8</span>, <span class="number">4</span>),</div><div class="line">index = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>], columns = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># a  1.411390  0.307114 -0.988168 -1.757327</span></div><div class="line"><span class="comment"># b  1.723277 -0.494447  1.372176  0.486670</span></div><div class="line"><span class="comment"># c  1.511763  0.132625 -1.242458  0.457793</span></div><div class="line"><span class="comment"># d  0.709051  0.361528  0.366901 -0.565920</span></div><div class="line"><span class="comment"># e -0.030279  1.160672  0.275871 -1.063416</span></div><div class="line"><span class="comment"># f -0.265881 -0.087183  0.313044  1.348987</span></div><div class="line"><span class="comment"># g  1.049137 -1.490819  1.085902  0.857283</span></div><div class="line"><span class="comment"># h -2.894211  0.086263  0.474841 -0.876164</span></div><div class="line"></div><div class="line"><span class="comment">#select all rows for a specific column</span></div><div class="line"><span class="keyword">print</span> (df.loc[:,<span class="string">'A'</span>])</div><div class="line"><span class="comment"># a    1.411390</span></div><div class="line"><span class="comment"># b    1.723277</span></div><div class="line"><span class="comment"># c    1.511763</span></div><div class="line"><span class="comment"># d    0.709051</span></div><div class="line"><span class="comment"># e   -0.030279</span></div><div class="line"><span class="comment"># f   -0.265881</span></div><div class="line"><span class="comment"># g    1.049137</span></div><div class="line"><span class="comment"># h   -2.894211</span></div><div class="line"></div><div class="line"><span class="comment"># Select all rows for multiple columns, say list[]</span></div><div class="line"><span class="keyword">print</span> (df.loc[:,[<span class="string">'A'</span>,<span class="string">'C'</span>]])</div><div class="line"><span class="comment">#           A         C</span></div><div class="line"><span class="comment"># a  1.411390 -0.988168</span></div><div class="line"><span class="comment"># b  1.723277  1.372176</span></div><div class="line"><span class="comment"># c  1.511763 -1.242458</span></div><div class="line"><span class="comment"># d  0.709051  0.366901</span></div><div class="line"><span class="comment"># e -0.030279  0.275871</span></div><div class="line"><span class="comment"># f -0.265881  0.313044</span></div><div class="line"><span class="comment"># g  1.049137  1.085902</span></div><div class="line"><span class="comment"># h -2.894211  0.474841</span></div><div class="line"></div><div class="line"><span class="comment"># Select few rows for multiple columns, say list[]</span></div><div class="line"><span class="keyword">print</span> (df.loc[[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'f'</span>,<span class="string">'h'</span>],[<span class="string">'A'</span>,<span class="string">'C'</span>]])</div><div class="line"><span class="comment">#           A         C</span></div><div class="line"><span class="comment"># a  1.411390 -0.988168</span></div><div class="line"><span class="comment"># b  1.723277  1.372176</span></div><div class="line"><span class="comment"># f -0.265881  0.313044</span></div><div class="line"><span class="comment"># h -2.894211  0.474841</span></div><div class="line"></div><div class="line"><span class="comment"># Select range of rows for all columns</span></div><div class="line"><span class="keyword">print</span> (df.loc[<span class="string">'a'</span>:<span class="string">'c'</span>])</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># a  1.411390  0.307114 -0.988168 -1.757327</span></div><div class="line"><span class="comment"># b  1.723277 -0.494447  1.372176  0.486670</span></div><div class="line"><span class="comment"># c  1.511763  0.132625 -1.242458  0.457793</span></div><div class="line"></div><div class="line"><span class="comment"># for getting values with a boolean array</span></div><div class="line"><span class="keyword">print</span> (df.loc[<span class="string">'a'</span>]&gt;<span class="number">0</span>) <span class="comment">#选择行‘a’，并判断这一行的每一个值是否大于0</span></div><div class="line"><span class="comment"># A     True</span></div><div class="line"><span class="comment"># B     True</span></div><div class="line"><span class="comment"># C    False</span></div><div class="line"><span class="comment"># D    False</span></div></pre></td></tr></table></figure><h2 id="iloc"><a href="#iloc" class="headerlink" title=".iloc()"></a>.iloc()</h2><p><em>Pandas</em>提供了各种方法，以获得纯整数索引。像python和numpy一样，第一个位置是基于<code>0</code>的索引。</p><p>各种访问方式如下 -</p><ul><li>整数</li><li>整数列表</li><li>系列值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">8</span>, <span class="number">4</span>), columns = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 0 -1.097794 -0.343903 -0.545227  0.693677</span></div><div class="line"><span class="comment"># 1  0.748052 -0.800368  0.391323  0.079908</span></div><div class="line"><span class="comment"># 2  1.395456 -0.622070  0.431188  0.321310</span></div><div class="line"><span class="comment"># 3 -0.133916  0.723562 -2.708785  1.397269</span></div><div class="line"><span class="comment"># 4  0.998216  0.229914  1.551281 -0.279701</span></div><div class="line"><span class="comment"># 5 -0.747833 -0.557234 -0.309676 -0.222850</span></div><div class="line"><span class="comment"># 6  1.034332  0.240854  0.730528 -0.825282</span></div><div class="line"><span class="comment"># 7 -0.095764 -0.899946 -0.616187  2.121193</span></div><div class="line"></div><div class="line"><span class="comment"># select all rows for a specific column</span></div><div class="line"><span class="keyword">print</span> (df.iloc[:<span class="number">4</span>])</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 0 -1.097794 -0.343903 -0.545227  0.693677</span></div><div class="line"><span class="comment"># 1  0.748052 -0.800368  0.391323  0.079908</span></div><div class="line"><span class="comment"># 2  1.395456 -0.622070  0.431188  0.321310</span></div><div class="line"><span class="comment"># 3 -0.133916  0.723562 -2.708785  1.397269</span></div><div class="line"></div><div class="line"><span class="comment"># Integer slicing</span></div><div class="line"><span class="keyword">print</span> (df.iloc[:<span class="number">4</span>])</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 0 -1.097794 -0.343903 -0.545227  0.693677</span></div><div class="line"><span class="comment"># 1  0.748052 -0.800368  0.391323  0.079908</span></div><div class="line"><span class="comment"># 2  1.395456 -0.622070  0.431188  0.321310</span></div><div class="line"><span class="comment"># 3 -0.133916  0.723562 -2.708785  1.397269</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (df.iloc[<span class="number">1</span>:<span class="number">5</span>, <span class="number">2</span>:<span class="number">4</span>])</div><div class="line"><span class="comment">#           C         D</span></div><div class="line"><span class="comment"># 1  0.391323  0.079908</span></div><div class="line"><span class="comment"># 2  0.431188  0.321310</span></div><div class="line"><span class="comment"># 3 -2.708785  1.397269</span></div><div class="line"><span class="comment"># 4  1.551281 -0.279701</span></div><div class="line"></div><div class="line"><span class="comment"># Slicing through list of values</span></div><div class="line"><span class="keyword">print</span> (df.iloc[[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">3</span>]])</div><div class="line"><span class="comment">#           B         D</span></div><div class="line"><span class="comment"># 1 -0.800368  0.079908</span></div><div class="line"><span class="comment"># 3  0.723562  1.397269</span></div><div class="line"><span class="comment"># 5 -0.557234 -0.222850</span></div><div class="line"><span class="keyword">print</span> (df.iloc[<span class="number">1</span>:<span class="number">3</span>, :])</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 1  0.748052 -0.800368  0.391323  0.079908</span></div><div class="line"><span class="comment"># 2  1.395456 -0.622070  0.431188  0.321310</span></div><div class="line"><span class="keyword">print</span> (df.iloc[:,<span class="number">1</span>:<span class="number">3</span>])</div><div class="line"><span class="comment">#           B         C</span></div><div class="line"><span class="comment"># 0 -0.343903 -0.545227</span></div><div class="line"><span class="comment"># 1 -0.800368  0.391323</span></div><div class="line"><span class="comment"># 2 -0.622070  0.431188</span></div><div class="line"><span class="comment"># 3  0.723562 -2.708785</span></div><div class="line"><span class="comment"># 4  0.229914  1.551281</span></div><div class="line"><span class="comment"># 5 -0.557234 -0.309676</span></div><div class="line"><span class="comment"># 6  0.240854  0.730528</span></div><div class="line"><span class="comment"># 7 -0.899946 -0.616187</span></div></pre></td></tr></table></figure><h2 id="ix"><a href="#ix" class="headerlink" title=".ix()"></a>.ix()</h2><p>除了基于纯标签和整数之外，<em>Pandas</em>还提供了一种使用<code>.ix()</code>运算符进行选择和子集化对象的混合方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">4</span>), columns = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 0  1.992586 -1.018359 -0.726185 -0.602579</span></div><div class="line"><span class="comment"># 1  0.112121  0.634097 -1.000867 -0.196700</span></div><div class="line"><span class="comment"># 2 -1.727799  0.033016 -0.250457 -0.009763</span></div><div class="line"><span class="comment"># 3 -0.253342  0.512558 -0.284954 -0.775973</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (df.ix[:<span class="number">2</span>]) <span class="comment">#前3行</span></div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 0  1.992586 -1.018359 -0.726185 -0.602579</span></div><div class="line"><span class="comment"># 1  0.112121  0.634097 -1.000867 -0.196700</span></div><div class="line"><span class="comment"># 2 -1.727799  0.033016 -0.250457 -0.009763</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (df.ix[:,<span class="string">'A'</span>]) <span class="comment">#'A'列</span></div><div class="line"><span class="comment"># 0    1.992586</span></div><div class="line"><span class="comment"># 1    0.112121</span></div><div class="line"><span class="comment"># 2   -1.727799</span></div><div class="line"><span class="comment"># 3   -0.253342</span></div></pre></td></tr></table></figure><h2 id="多轴索引"><a href="#多轴索引" class="headerlink" title="多轴索引"></a>多轴索引</h2><p>使用基本索引运算符<code>[]</code> </p><p><img src="/2018/06/08/ML-Pandas/Screen Shot 2018-06-12 at 9.18.14 AM.png" alt="Screen Shot 2018-06-12 at 9.18.14 AM"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">4</span>), columns = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 0 -0.118619 -0.180957  1.119985  0.786177</span></div><div class="line"><span class="comment"># 1  1.948019  2.303557 -1.179559 -0.068304</span></div><div class="line"><span class="comment"># 2  2.138096  1.280755  2.486576 -0.089437</span></div><div class="line"><span class="comment"># 3 -0.998829  0.371025  0.644868  0.166721</span></div><div class="line"></div><div class="line">print(df[<span class="string">'A'</span>])</div><div class="line"><span class="comment"># 0   -0.118619</span></div><div class="line"><span class="comment"># 1    1.948019</span></div><div class="line"><span class="comment"># 2    2.138096</span></div><div class="line"><span class="comment"># 3   -0.998829</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (df[[<span class="string">'A'</span>,<span class="string">'B'</span>]])</div><div class="line"><span class="comment">#           A         B</span></div><div class="line"><span class="comment"># 0 -0.118619 -0.180957</span></div><div class="line"><span class="comment"># 1  1.948019  2.303557</span></div><div class="line"><span class="comment"># 2  2.138096  1.280755</span></div><div class="line"><span class="comment"># 3 -0.998829  0.371025</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (df[<span class="number">1</span>:<span class="number">2</span>])</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 1  1.948019  2.303557 -1.179559 -0.068304</span></div></pre></td></tr></table></figure><p>可以使用属性运算符<code>.</code>来选择列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">4</span>), columns = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</div><div class="line">print(df)</div><div class="line"><span class="comment">#           A         B         C         D</span></div><div class="line"><span class="comment"># 0  3.115677 -0.164456  0.404479 -0.612033</span></div><div class="line"><span class="comment"># 1 -0.820360 -1.395105  0.189704 -0.449740</span></div><div class="line"><span class="comment"># 2  1.354399  1.575434 -1.080091 -0.219215</span></div><div class="line"><span class="comment"># 3 -0.435956 -0.751293  0.828191  1.198294</span></div><div class="line"></div><div class="line">print(df.A)</div><div class="line"><span class="comment"># 0    3.115677</span></div><div class="line"><span class="comment"># 1   -0.820360</span></div><div class="line"><span class="comment"># 2    1.354399</span></div><div class="line"><span class="comment"># 3   -0.435956</span></div></pre></td></tr></table></figure><h1 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h1><h2 id="pct-change-函数"><a href="#pct-change-函数" class="headerlink" title="pct_change()函数"></a>pct_change()函数</h2><p>系列，DatFrames和Panel都有<code>pct_change()</code>函数。此函数将每个元素与其前一个元素进行比较，并计算变化百分比。</p><p>认情况下，<code>pct_change()</code>对列进行操作; 如果想应用到行上，那么可使用<code>axis = 1</code>参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>])<span class="comment"># [x,y]:(y-x)/x </span></div><div class="line"><span class="keyword">print</span> (s.pct_change())</div><div class="line"><span class="comment"># 0         NaN</span></div><div class="line"><span class="comment"># 1    1.000000</span></div><div class="line"><span class="comment"># 2    0.500000</span></div><div class="line"><span class="comment"># 3    0.333333</span></div><div class="line"><span class="comment"># 4    0.250000</span></div><div class="line"><span class="comment"># 5   -0.200000</span></div><div class="line"></div><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">2</span>))</div><div class="line"><span class="keyword">print</span> (df.pct_change())</div><div class="line"><span class="comment">#            0         1</span></div><div class="line"><span class="comment"># 0        NaN       NaN</span></div><div class="line"><span class="comment"># 1  -1.475974 -0.719708</span></div><div class="line"><span class="comment"># 2  -0.533308 -2.573370</span></div><div class="line"><span class="comment"># 3  -0.119521 -2.599591</span></div><div class="line"><span class="comment"># 4  14.990426 -1.470710</span></div></pre></td></tr></table></figure><h2 id="cov-协方差"><a href="#cov-协方差" class="headerlink" title="cov()协方差"></a>cov()协方差</h2><p>协方差适用于系列数据。Series对象有一个方法<code>cov</code>用来计算序列对象之间的协方差。<code>NA</code>将被自动排除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">s1 = pd.Series(np.random.randn(<span class="number">10</span>))</div><div class="line">s2 = pd.Series(np.random.randn(<span class="number">10</span>))</div><div class="line"><span class="keyword">print</span> (s1.cov(s2))<span class="comment"># -0.6094391964528769</span></div></pre></td></tr></table></figure><p>当应用于<code>DataFrame</code>时，协方差方法计算所有列之间的协方差(<code>cov</code>)值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">frame = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">5</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line"><span class="keyword">print</span> (frame[<span class="string">'a'</span>].cov(frame[<span class="string">'b'</span>]))</div><div class="line"><span class="comment"># -0.05532965605044696</span></div><div class="line"><span class="keyword">print</span> (frame.cov()) <span class="comment">#协方差矩阵</span></div><div class="line"><span class="comment">#           a         b         c         d         e</span></div><div class="line"><span class="comment"># a  0.605689 -0.055330 -0.449482  0.110269 -0.093332</span></div><div class="line"><span class="comment"># b -0.055330  0.910118 -0.330857  0.207272 -0.415138</span></div><div class="line"><span class="comment"># c -0.449482 -0.330857  0.881411 -0.347100  0.251697</span></div><div class="line"><span class="comment"># d  0.110269  0.207272 -0.347100  0.437272  0.021039</span></div><div class="line"><span class="comment"># e -0.093332 -0.415138  0.251697  0.021039  0.561143</span></div></pre></td></tr></table></figure><blockquote><p>注 - 观察第一个语句中<code>a</code>和<code>b</code>列之间的<code>cov</code>结果值，与由DataFrame上的<code>cov</code>返回的值相同。</p></blockquote><h2 id="相关性函数"><a href="#相关性函数" class="headerlink" title="相关性函数"></a>相关性函数</h2><p>相关性显示了任何两个数值(系列)之间的线性关系。有多种方法来计算<code>pearson</code>(默认)，<code>spearman</code>和<code>kendall</code>之间的相关性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">frame = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">5</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line"></div><div class="line"><span class="keyword">print</span> (frame[<span class="string">'a'</span>].corr(frame[<span class="string">'b'</span>]))</div><div class="line"><span class="comment"># -0.10411289414403013</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (frame.corr())</div><div class="line"><span class="comment">#           a         b         c         d         e</span></div><div class="line"><span class="comment"># a  1.000000 -0.104113 -0.136458  0.732508  0.372643</span></div><div class="line"><span class="comment"># b -0.104113  1.000000  0.098084 -0.074208  0.275227</span></div><div class="line"><span class="comment"># c -0.136458  0.098084  1.000000  0.280941  0.592759</span></div><div class="line"><span class="comment"># d  0.732508 -0.074208  0.280941  1.000000  0.572732</span></div><div class="line"><span class="comment"># e  0.372643  0.275227  0.592759  0.572732  1.000000</span></div></pre></td></tr></table></figure><blockquote><p>如果DataFrame中存在任何非数字列，则会自动排除。</p></blockquote><h2 id="数据排名"><a href="#数据排名" class="headerlink" title="数据排名"></a>数据排名</h2><p>数据排名为元素数组中的每个元素生成排名，不是比大小哦。在关系的情况下，分配平均等级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">s = pd.Series(np.random.np.random.randn(<span class="number">5</span>), index=list(<span class="string">'abcde'</span>))</div><div class="line">print(s)</div><div class="line"><span class="comment"># a    0.198131</span></div><div class="line"><span class="comment"># b    0.544257</span></div><div class="line"><span class="comment"># c   -0.253626</span></div><div class="line"><span class="comment"># d    0.163365</span></div><div class="line"><span class="comment"># e    0.105286</span></div><div class="line">s[<span class="string">'d'</span>] = s[<span class="string">'b'</span>] <span class="comment"># so there's a tie</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (s.rank()) <span class="comment">#根据值得东西分配等级，因为有两个值相等，分别是（5级+4级）/2 = 4.5级</span></div><div class="line"><span class="comment"># a    3.0</span></div><div class="line"><span class="comment"># b    4.5</span></div><div class="line"><span class="comment"># c    1.0</span></div><div class="line"><span class="comment"># d    4.5</span></div><div class="line"><span class="comment"># e    2.0</span></div></pre></td></tr></table></figure><p><img src="/2018/06/08/ML-Pandas/Screen Shot 2018-06-12 at 9.40.29 AM.png" alt="Screen Shot 2018-06-12 at 9.40.29 AM"></p>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ML - SciPy</title>
      <link href="/2018/06/07/ML-SciPy/"/>
      <url>/2018/06/07/ML-SciPy/</url>
      <content type="html"><![CDATA[<p>Scipy基于Numpy，提供了大量科学算法，它的不同子模块相应于不同的应用，本文参考了<a href="https://www.jianshu.com/p/1a3db06e786d" target="_blank" rel="noopener">1</a></p><ol><li>文件IO（scipy.io）：数据输入输出</li><li>特殊函数（scipy.special）：特殊函数是先验函数，常用的有伽马函数scipy.special.gamma()</li><li>线性代数运算（scipy.linalg）</li><li>快速傅里叶变化（scipy.fftpack）</li><li>优化和拟合（scipy.optimize）：提供了函数最小值(标量或多维)、曲线拟合和寻找等式的根的有用算法。</li><li>统计和随机数（scipy.stats）</li><li>数值积分（scipy.integrate Fusy）</li></ol><p>模块导入的标准方式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> io <span class="comment">#其他模块类似</span></div></pre></td></tr></table></figure><a id="more"></a><h2 id="文件输入-输出：scipy-io"><a href="#文件输入-输出：scipy-io" class="headerlink" title="文件输入/输出：scipy.io"></a>文件输入/输出：scipy.io</h2><h3 id="导入和保存matlab文件"><a href="#导入和保存matlab文件" class="headerlink" title="导入和保存matlab文件"></a>导入和保存matlab文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> io <span class="keyword">as</span> spio</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">a = np.ones((<span class="number">3</span>,<span class="number">3</span>)) <span class="comment">#3*3的全1矩阵</span></div><div class="line">spio.savemat(<span class="string">'file.mat'</span>,&#123;<span class="string">'a'</span>:a&#125;) <span class="comment">#以字典形式保存</span></div><div class="line">data = spio.loadmat(<span class="string">'file.mat'</span>,struct_as_record=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><h3 id="图片读取"><a href="#图片读取" class="headerlink" title="图片读取"></a>图片读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> misc</div><div class="line"></div><div class="line">x = misc.imread(<span class="string">"scipy.png"</span>)</div></pre></td></tr></table></figure><h3 id="txt-csv"><a href="#txt-csv" class="headerlink" title="txt/csv"></a>txt/csv</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">numpy.loadtxt()</div><div class="line">numpy.savetxt()</div><div class="line">numpy.genfromtxt() <span class="comment">#智能导入文本</span></div><div class="line">numpy.recfromcsv() <span class="comment">#智能导入csv文件</span></div><div class="line"></div><div class="line"><span class="comment">#高速，有效率但numpy特有的二进制格式：</span></div><div class="line">numpy.save() </div><div class="line">numpy.load()</div></pre></td></tr></table></figure><h2 id="线性代数运算：scipy-linalg"><a href="#线性代数运算：scipy-linalg" class="headerlink" title="线性代数运算：scipy.linalg"></a>线性代数运算：scipy.linalg</h2><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</div><div class="line"></div><div class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</div><div class="line">re = linalg.det(x) <span class="comment">#-2.0</span></div></pre></td></tr></table></figure><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</div><div class="line"></div><div class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</div><div class="line">re = linalg.inv(x)</div></pre></td></tr></table></figure><h3 id="奇异值分解SVD"><a href="#奇异值分解SVD" class="headerlink" title="奇异值分解SVD"></a>奇异值分解SVD</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</div><div class="line"></div><div class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</div><div class="line">uarr,spec,vharr = linalg.svd(x)</div><div class="line"></div><div class="line"><span class="comment">###原始矩阵可以由svd的输出用np.dot点乘重新组合得到</span></div><div class="line">sarr = np.diag(spec)</div><div class="line">svd_mat = uarr.dot(sarr).dot(vharr)</div><div class="line">re = np.allclose(svd_mat,x) <span class="comment">#True</span></div></pre></td></tr></table></figure><h2 id="快速傅里叶变换：scipy-fftpack"><a href="#快速傅里叶变换：scipy-fftpack" class="headerlink" title="快速傅里叶变换：scipy.fftpack"></a>快速傅里叶变换：scipy.fftpack</h2><h2 id="优化和拟合：scipy-optimize"><a href="#优化和拟合：scipy-optimize" class="headerlink" title="优化和拟合：scipy.optimize"></a>优化和拟合：scipy.optimize</h2><h3 id="标量函数最小值"><a href="#标量函数最小值" class="headerlink" title="标量函数最小值"></a>标量函数最小值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x**<span class="number">2</span> + <span class="number">10</span>*np.sin(x)</div><div class="line">x = np.arange(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">0.1</span>)</div><div class="line">plt.plot(x,f(x))</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/2018/06/07/ML-SciPy/image-20180608001714621.png" alt="image-20180608001714621"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">####从上面图像可以看出x在-1.3附近有个全局最小值，在3.8附近有个局部最小</span></div><div class="line"><span class="comment">####从初始点使用梯度下降法求解，BFGS算法</span></div><div class="line">re = optimize.fmin_bfgs(f,<span class="number">0</span>) <span class="comment">##必须定义成函数</span></div><div class="line">print(re)</div><div class="line"><span class="comment">#Optimization terminated successfully.</span></div><div class="line"><span class="comment">#Current function value: -7.945823</span></div><div class="line"><span class="comment">#Iterations: 5</span></div><div class="line"><span class="comment">#Function evaluations: 18</span></div><div class="line"><span class="comment">#Gradient evaluations: 6</span></div><div class="line"><span class="comment">#[-1.30644012]</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#这个方法一个可能的问题在于，如果函数有局部最小值，算法会因初始点不同找到这些局部最小而不是全局最小:</span></div><div class="line">re = optimize.fmin_bfgs(f,<span class="number">3</span>) <span class="comment">#[3.83746709]</span></div><div class="line"><span class="comment">#如果我们不知道全局最小值的邻近值来选定初始点，我们需要借助于耗费资源些的全局优化。为了找到全局最小点，最简单的算法是蛮力算法^2，该算法求出给定格点的每个函数值。</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x**<span class="number">2</span> + <span class="number">10</span>*np.sin(x)</div><div class="line">x = np.arange(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">0.1</span>)</div><div class="line"></div><div class="line">grid = (<span class="number">-10</span>,<span class="number">10</span>,<span class="number">0.1</span>)</div><div class="line">re = optimize.brute(f,(grid,)) <span class="comment">##[-1.30641113]</span></div><div class="line"></div><div class="line"><span class="comment">##为了找到局部最小，我们把变量限制在(0, 10)之间，使用scipy.optimize.fminbound():</span></div><div class="line">re_local = optimize.fminbound(f,<span class="number">0</span>,<span class="number">10</span>) <span class="comment">##3.8374671194983834</span></div></pre></td></tr></table></figure><h3 id="标量函数的根"><a href="#标量函数的根" class="headerlink" title="标量函数的根"></a>标量函数的根</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#为了寻找根，例如令f(x)=0的点，对以上的用来示例的函数f我们可以使用scipy.optimize.fsolve()</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x**<span class="number">2</span> + <span class="number">10</span>*np.sin(x)</div><div class="line">x = np.arange(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">0.1</span>)</div><div class="line"></div><div class="line">root = optimize.fsolve(f,<span class="number">1</span>)<span class="comment">#初始猜测是1</span></div><div class="line">print(root) <span class="comment">#[0.]</span></div><div class="line"></div><div class="line"><span class="comment">#注意仅仅一个根被找到。检查f的图像在-2.5附近有第二个根。我们可以通过调整我们的初始猜测找到这一确切值</span></div><div class="line">root = optimize.fsolve(f,<span class="number">-2.5</span>)</div><div class="line">print(root)<span class="comment">#[-2.47948183]</span></div></pre></td></tr></table></figure><h3 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x**<span class="number">2</span> + <span class="number">10</span>*np.sin(x)</div><div class="line">xdata = np.linspace(<span class="number">-10</span>,<span class="number">10</span>,num=<span class="number">20</span>)</div><div class="line"><span class="comment">#得到污染的数据</span></div><div class="line">ydata = f(xdata) + np.random.randn(xdata.size)</div><div class="line"><span class="comment">#我们知道xdata-ydata大致服从y=x^2 + sin(x),但是噪声的引入而又偏差，我们需要拟合找出系数a和b，即y=a*x^2 + b*sin(x)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x,a,b)</span>:</span></div><div class="line">    <span class="keyword">return</span> a*x**<span class="number">2</span>+b*np.sin(x)</div><div class="line">guess = [<span class="number">2</span>,<span class="number">2</span>]</div><div class="line">params, params_covariance = optimize.curve_fit(f2,xdata,ydata,guess)</div><div class="line"><span class="comment"># params = [0.98996991 9.87613168]</span></div><div class="line"><span class="comment"># params_covariance = [[1.23238891e-05 1.30651701e-11] [1.30651701e-11 6.29408152e-02]]</span></div></pre></td></tr></table></figure><h2 id="统计和随机数：-scipy-stats"><a href="#统计和随机数：-scipy-stats" class="headerlink" title="统计和随机数： scipy.stats"></a>统计和随机数： scipy.stats</h2><h3 id="直方图和概率密度函数"><a href="#直方图和概率密度函数" class="headerlink" title="直方图和概率密度函数"></a>直方图和概率密度函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#给定一个随机过程的观察值，它们的直方图是随机过程的pdf(概率密度函数)的估计器</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">a = np.random.normal(size=<span class="number">1000</span>)</div><div class="line">bins = np.arange(<span class="number">-4</span>,<span class="number">5</span>) <span class="comment"># bins=[-4, -3, -2, -1,  0,  1,  2,  3,  4]</span></div><div class="line"></div><div class="line">histogram = np.histogram(a,bins=bins,normed=<span class="keyword">True</span>)[<span class="number">0</span>]</div><div class="line">bins = <span class="number">0.5</span>*(bins[<span class="number">1</span>:]+bins[:<span class="number">-1</span>]) <span class="comment">#bins=[-3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,  3.5]</span></div><div class="line"></div><div class="line">b = stats.norm.pdf(bins)</div><div class="line"></div><div class="line">plt.plot(bins,histogram,color=<span class="string">'g'</span>)</div><div class="line">plt.plot(bins,b,color=<span class="string">'b'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/2018/06/07/ML-SciPy/image-20180608005630507.png" alt="image-20180608005630507"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#如果我们知道随机过程属于给定的随机过程族，比如正态过程。我们可以对观测值进行最大似然拟合来估计基本分布参数。这里我们对观测值拟合一个正态过程：</span></div><div class="line">loc,std = stats.norm.fit(a) <span class="comment">#loc= 0.007411672576925874 std= 1.005072454096087</span></div></pre></td></tr></table></figure><h3 id="百分位"><a href="#百分位" class="headerlink" title="百分位"></a>百分位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#中位数,又叫作50百分位点，因为有50%的观测值在它之下,是来观测值之下一半之上一半的值。</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">a = np.random.normal(size=<span class="number">1000</span>)</div><div class="line"></div><div class="line">med = np.median(a)</div><div class="line">med = stats.scoreatpercentile(a,<span class="number">50</span>) <span class="comment">#百分位是CDF的一个估计器</span></div></pre></td></tr></table></figure><h2 id="数值积分：scipy-integrate-Fusy"><a href="#数值积分：scipy-integrate-Fusy" class="headerlink" title="数值积分：scipy.integrate Fusy"></a>数值积分：scipy.integrate Fusy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> quad</div><div class="line"></div><div class="line">re,err = quad(np.sin,<span class="number">0</span>,np.pi/<span class="number">2</span>)</div><div class="line"><span class="comment">#re=0.9999999999999999, err=1.1102230246251564e-14</span></div></pre></td></tr></table></figure><p>上述计算$\int_{0}^{\frac{\pi}{2}}sin(x)dx=1$</p>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ML - Sklearn</title>
      <link href="/2018/06/07/ML-Sklearn/"/>
      <url>/2018/06/07/ML-Sklearn/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ML - Frequent Itemset Mining</title>
      <link href="/2018/06/05/ML%20-%20Frequent%20Itemset%20Mining/"/>
      <url>/2018/06/05/ML%20-%20Frequent%20Itemset%20Mining/</url>
      <content type="html"><![CDATA[<p>An association rule is a pattern that states when an event occurs, another event occurs with certain probability. Association relus find all sets of items that have support count greater than the mimimum support; then using the large itemsets to generate the desired rules that have confidence greater than the minimum confidence. For frequent itemset mining, we use Apriori algorithm.</p><p>The following details are from <a href="https://www.youtube.com/watch?v=Hk1zFOMLTrw" target="_blank" rel="noopener">The Apriori Algorithm … How The Apriori Algorithm Works</a>.</p><a id="more"></a><h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><blockquote><ol><li><p>A set of all items in a store $I=\{i_1,i_2,…,i_m\}$</p></li><li><p>A set of all transactions (Transaction Database T)</p><p>$T={t_1,t_2,…,t_n}$</p></li><li><p>Each $t_i$ is a set of items s.t. $t\subseteq I$</p></li><li><p>Each transaction $t_i$ has a transaction ID(TID)</p></li></ol></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2018/06/05/ML - Frequent Itemset Mining/Screen Shot 2018-06-05 at 4.44.19 PM.png" alt="Screen Shot 2018-06-05 at 4.44.19 PM"></p><h2 id="Apriori-Algorithm"><a href="#Apriori-Algorithm" class="headerlink" title="Apriori Algorithm"></a>Apriori Algorithm</h2><p><img src="/2018/06/05/ML - Frequent Itemset Mining/Screen Shot 2018-06-09 at 11.38.24 PM.png" alt="Screen Shot 2018-06-09 at 11.38.24 PM"></p><p><img src="/2018/06/05/ML - Frequent Itemset Mining/Screen Shot 2018-06-09 at 11.39.28 PM.png" alt="Screen Shot 2018-06-09 at 11.39.28 PM"></p><p><img src="/2018/06/05/ML - Frequent Itemset Mining/Screen Shot 2018-06-09 at 11.40.39 PM.png" alt="Screen Shot 2018-06-09 at 11.40.39 PM"></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Say we have a transaction database and the minimum support count is $sc=2$.</p><div class="table-container"><table><thead><tr><th style="text-align:center">TID</th><th style="text-align:center">Items</th></tr></thead><tbody><tr><td style="text-align:center">100</td><td style="text-align:center">1 , 3 , 4</td></tr><tr><td style="text-align:center">200</td><td style="text-align:center">2 , 3 , 5</td></tr><tr><td style="text-align:center">300</td><td style="text-align:center">1, 2, 3, 5</td></tr><tr><td style="text-align:center">400</td><td style="text-align:center">2, 5</td></tr><tr><td style="text-align:center">500</td><td style="text-align:center">1, 3, 5</td></tr></tbody></table></div><p><strong>Step One : 1-itemset</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Itemset</th><th style="text-align:center">Support</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">4</td></tr></tbody></table></div><p>so we delete itemset = 4 because its support is less than 2, after prunning:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Itemset</th><th style="text-align:center">Support</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">4</td></tr></tbody></table></div><p><strong>Step 2 : 2-itemset</strong></p><p>we build 2-itemset based on 1-itemset, where we get {1,2},{1,3},{1,5},{2,3},{2,5},}{3,5}</p><div class="table-container"><table><thead><tr><th style="text-align:center">Itemset</th><th style="text-align:center">Support</th></tr></thead><tbody><tr><td style="text-align:center">{1,2}</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">{1,3}</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">{1,5}</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">{2,3}</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">{2,5}</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">{3,5}</td><td style="text-align:center">3</td></tr></tbody></table></div><p>delete itemset { 1,2 } because its support is 1.</p><div class="table-container"><table><thead><tr><th style="text-align:center">Itemset</th><th style="text-align:center">Support</th></tr></thead><tbody><tr><td style="text-align:center">{1,3}</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">{1,5}</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">{2,3}</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">{2,5}</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">{3,5}</td><td style="text-align:center">3</td></tr></tbody></table></div><p><strong>Step 3 : 3-itemset</strong></p><p>we build 3-itemset based on 2-itemset, where we get{1,3,5},{1,2,3},{1,2,5},{2,3,5}</p><p>Before counting each itemset’s support, we do some prunning.</p><p>For {1,3,5} : {1,3},{1,5},{3,5}, and according to the fact that any frequent itemsets’ subset must be frequent itemset, so {1,3,5} may be frequent itemset because all of its subsets are frequent itemset.</p><p>For {1,2,3} : {1,2},{1,3},{2,3}. Because {1,2} is not frequent itemset, {1,2,3} is not frequent itemset and we don’t need to calculate its support.</p><p>Same rule to {1,2,5} and {2,3,5}, we can say that {1,2,5} is not frequent itemset but {2,3,5} may be frequent itemset.</p><div class="table-container"><table><thead><tr><th style="text-align:center">Itemset</th><th style="text-align:center">Support</th></tr></thead><tbody><tr><td style="text-align:center">{1,3,5}</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">{2,3,5}</td><td style="text-align:center">2</td></tr></tbody></table></div><p><strong>Step 4 : 4-itemset</strong></p><p>we get 4-itemset : {1,2,3,5}.</p><p>Prune ：{1,2,3},{1,2,5},{1,3,5},{2,3,5}. because {1,2,5} and {1,2,3} are not frequent itemsets, {1,2,3,5} is not frequent itemset.</p><p>Then we end up with empty. We return 3-itemset {1,3,5} and {2,3,5} for rule generation.</p><h2 id="Association-rule-generation"><a href="#Association-rule-generation" class="headerlink" title="Association rule generation"></a>Association rule generation</h2><p>Now we have the list of frequent itemsets</p><div class="table-container"><table><thead><tr><th style="text-align:center">Itemset</th><th style="text-align:center">Support</th></tr></thead><tbody><tr><td style="text-align:center">{1,3,5}</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">{2,3,5}</td><td style="text-align:center">2</td></tr></tbody></table></div><p>Generate all nonempty subsets for each frequent itemset $I$</p><blockquote><ul><li>For {1,3,5}, we have {1},{3},{5},{1,3},{1,5},{3,5}</li><li>For {2,3,5}, we have {2},{3},{5},{2,3},{2,5},{3,5}</li></ul></blockquote><p>For every subset $s$ of frequent itemset $I$, with the minimum confidence threshold, we generate the rule:</p><script type="math/tex; mode=display">s\to(I-s) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if \ \ \ \  \ \frac{sc(I)}{sc(s)}\ge min\_conf</script><blockquote><p>Let us assume the minimum confidence threshold is 60%,</p><p>For frequent itemset {1,3,5}:</p><ul><li>Rule1: $\{1\}\to \{3,5\}$, confidence = $\frac{sc\{1,3,5\}}{sc\{1\}}=\frac{2}{3}=66.66\%$ <strong>Selected</strong></li><li>Rule2: $\{3\}\to \{1,5\}$, confidence = $\frac{sc\{1,3,5\}}{sc\{3\}}=\frac{2}{4}=50\%$ <strong>Rejected</strong></li><li>Rule3: $\{5\}\to \{1,3\}$, confidence = $\frac{sc\{1,3,5\}}{sc\{5\}}=\frac{2}{4}=50\%$ <strong>Rejected</strong></li><li>Rule4: $\{1,3\}\to \{5\}$, confidence = $\frac{sc\{1,3,5\}}{sc\{1,3\}}=\frac{2}{3}=66.66\%$ <strong>Selected</strong></li><li>Rule5: $\{1,5\}\to \{3\}$, confidence = $\frac{sc\{1,3,5\}}{sc\{1,5\}}=\frac{2}{2}=100\%$ <strong>Selected</strong></li><li>Rule6: $\{3,5\}\to \{1\}$, confidence = $\frac{sc\{1,3,5\}}{sc\{3,5\}}=\frac{2}{3}=66.66\%$ <strong>Selected</strong></li></ul><p>Same operations on {2,3,5}.</p></blockquote>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Algorithm - Bloom Filter</title>
      <link href="/2018/06/04/Algorithm-Bloom-Filter/"/>
      <url>/2018/06/04/Algorithm-Bloom-Filter/</url>
      <content type="html"><![CDATA[<p>文字参考自<a href="https://blog.csdn.net/hguisu/article/details/7866173" target="_blank" rel="noopener">海量数据处理算法—Bloom Filter</a>.</p><p>Bloom Filter（BF）是一种空间效率很高的随机数据结构，它是一个判断元素是否存在集合的快速的概率算法。Bloom Filter有可能会出现错误判断，但不会漏掉判断。也就是Bloom Filter判断元素不再集合，那肯定不在。如果判断元素存在集合中，有一定的概率判断错误。因此，Bloom Filter不适合那些“零错误”的应用场合。</p><a id="more"></a><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><blockquote><p>计算某元素x是否在一个集合中，首先能想到的方法就是将所有的已知元素保存起来构成一个集合R，然后用元素x跟这些R中的元素一一比较来判断是否存在于集合R中；我们可以采用链表等数据结构来实现。但是，随着集合R中元素的增加，其占用的内存将越来越大。</p><p>于是，我们会想到用Hash table的数据结构，运用一个足够好的Hash函数将一个值映射到二进制位数组（位图数组）中的某一位。如果该位已经被置为1，那么表示该值已经存在。</p><p>Hash存在一个冲突（碰撞）的问题，两个值用同一个Hash得到的可能有相同的index。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p></blockquote><h2 id="算法模块"><a href="#算法模块" class="headerlink" title="算法模块"></a>算法模块</h2><ol><li><p><strong>数据结构</strong></p><p>Bloom Filter使用一个<strong>m</strong>比特的数组来保存信息，初始状态时，Bloom Filter是一个包含m位的位数组，每一位都置为0，即BF整个数组的元素都设置为0。</p><p><img src="/2018/06/04/Algorithm-Bloom-Filter/Screen Shot 2018-06-04 at 4.43.28 PM.png" alt="Screen Shot 2018-06-04 at 4.43.28 PM"></p></li><li><p><strong>元素添加</strong></p><p>为了表达S={x1, x2,…,xn}这样一个n个元素的集合，Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。</p><p>当我们往Bloom Filter中增加任意一个元素x时候，我们使用k个哈希函数得到k个哈希值，也会是在数组中的下标index，然后将数组中对应的比特位设置为1。</p><p>如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，k=3，且有两个哈希函数选中同一个位置（从左边数第五位，即第二个“1“处）。   </p><p><img src="/2018/06/04/Algorithm-Bloom-Filter/Screen Shot 2018-06-04 at 4.45.44 PM.png" alt="Screen Shot 2018-06-04 at 4.45.44 PM"></p></li><li><p><strong>元素查找</strong></p><p>在判断y是否属于这个集合时，我们只需要对y使用k个哈希函数得到k个哈希值，如果所有hashi(y)的位置都是1（1≤i≤k），即k个位置都被设置为1了，那么我们就认为y是集合中的元素，否则就认为y不是集合中的元素。下图中y1就不是集合中的元素（因为y1有一处指向了“0”位）。y2或者属于这个集合，或者刚好是一个false positive误判。</p><p><img src="/2018/06/04/Algorithm-Bloom-Filter/Screen Shot 2018-06-04 at 4.45.51 PM.png" alt="Screen Shot 2018-06-04 at 4.45.51 PM"></p></li></ol><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a><a href="http://huangjacky.github.io/post/python-bloom-filter/" target="_blank" rel="noopener">Python实现</a></h2><ol><li><p>安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pybloom</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pybloom <span class="keyword">import</span> BloomFilter, ScalableBloomFilter</div><div class="line">bf = BloomFilter(capacity=<span class="number">10000</span>, error_rate=<span class="number">0.001</span>)</div><div class="line">bf.add(<span class="string">'test'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'test'</span> <span class="keyword">in</span> bf</div><div class="line">sbf = ScalableBloomFilter(mode=ScalableBloomFilter.SMALL_SET_GROWTH)</div><div class="line">sbf.add(<span class="string">'dddd'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'ddd'</span> <span class="keyword">in</span> sbf</div></pre></td></tr></table></figure><p>BloomFilter是一个定容的过滤器，<strong>error_rate</strong>是指最大的误报率是0.1%，而ScalableBloomFilter是一个不定容量的布隆过滤器，它可以不断添加元素。<strong>add</strong>方法是添加元素，如果元素已经在布隆过滤器中，就返回true，如果不在返回fasle并将该元素添加到过滤器中。判断一个元素是否在过滤器中，只需要使用<strong>in</strong>运算符即可了。</p></li></ol>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ML - Expectation Maximization Algorithm</title>
      <link href="/2018/06/03/ML-Expectation-Maximization-Algorithm/"/>
      <url>/2018/06/03/ML-Expectation-Maximization-Algorithm/</url>
      <content type="html"><![CDATA[<p>下文资料参考了<a href="https://www.cnblogs.com/zlslch/p/6965374.html" target="_blank" rel="noopener">EM(期望最大化)算法初步认识</a></p><p><strong>极大似然估计</strong>，是参数估计的方法之一。其基本思想是已知样本符合某种概率分布，但是分布的参数未知，于是通过采样的随机样本估计参数。其基本步骤是：</p><ol><li>求出似然函数：该样本集的概率，即每个样本出现的概率连积</li><li>对似然函数取对数：将连乘变连加</li><li>求导：使对数似然函数取最大值的参数便是结果</li><li>求解方程：得到的参数即为所求。</li></ol><p><strong>期望最大算法</strong>，是一种从不完全数据或有数据丢失的数据集（存在隐含变量）中求解概率模型参数的最大似然估计方法。在每一次的迭代过程中，主要分为两步：即求期望(Expectation)步骤和最大化(Maximization)步骤。</p><a id="more"></a><h1 id="极大似然估计-Maximum-Likelihood"><a href="#极大似然估计-Maximum-Likelihood" class="headerlink" title="极大似然估计(Maximum Likelihood)"></a>极大似然估计(Maximum Likelihood)</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>假设需要调查学校的男生身高分布，于是采用采样的方法在校园里随机的访问了100个男生。于是统计抽样得到了100个男生的身高，假设他们的身高服从正态分布，但是这个分布的均值$\mu$和方差$\delta^2$是未知的，即这两个参数是需要估计的，记作$\theta=[\mu,\delta]$。</p><p>用数学的语言来说就是：在学校的男生中，独立地按照概率密度函数$p(x|\theta)$抽样了100个人的身高，组成样本集$X$,我们想通过样本集$X$来估计未知参数$\theta$。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>由于每个样本都是独立地从$p(x|\theta)$中抽取的，换句话说这100个男生中的任何一个，都是随机抽取的，从我的角度来看这些男生之间是没有关系的。那么，我从学校那么多男生中为什么就恰好抽到了这100个人呢？抽到这100个人的概率是多少呢？因为这些男生（的身高）是服从同一个高斯分布$p(x|\theta)$的。那么我抽到男生A（的身高）的概率是$p(x_A|\theta)$，抽到男生B的概率是$p(x_B|\theta)$，那因为他们是独立的，所以很明显，我同时抽到男生A和男生B的概率是$p(x_A|\theta)\times{p(x_B|\theta)}$，同理，我同时抽到这100个男生的概率就是他们各自概率的乘积了。用数学家的口吻说就是从分布是$p(x|\theta)$的总体样本中抽取到这100个样本的概率，也就是样本集X中各个样本的联合概率，用下式表示：</p><p><img src="/2018/06/03/ML-Expectation-Maximization-Algorithm/Screen Shot 2018-06-03 at 4.37.55 PM.png" alt="Screen Shot 2018-06-03 at 4.37.55 PM"></p><p>这个概率反映了，在概率密度函数的参数是$theta$时，得到X这组样本的概率。因为这里X是已知的，也就是说我抽取到的这100个人的身高可以测出来，则每一种身高在该100个样本中可以计算$p(x_i;\theta)=\frac{身高为x_i的人数$}{100}$。而$\theta$是未知了，则上面这个公式只有θ是未知数，所以它是$\theta$的函数。这个函数放映的是在不同的参数$\theta$取值下，取得当前这个样本集的可能性，因此称为参数$\theta$相对于样本集X的似然函数（likehood function）。记为$L(\theta)$。</p></blockquote><h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><blockquote><ol><li><p>似然函数思想：抽取的样本的概率最大</p><p>下课了，一群男女同学分别去厕所了。然后，你想知道课间是男生上厕所的人多还是女生上厕所的人比较多，然后你就跑去蹲在男厕和女厕的门口。蹲了五分钟，你跑过来告诉我，课间女生上厕所的人比较多。我问你是怎么知道的。你说：“5分钟了，出来的是女生，女生啊，那么女生出来的概率肯定是最大的了，或者说比男生要大，那么女厕所的人肯定比男厕所的人多”。看到了没，你已经运用最大似然估计了。你通过观察到女生先出来，那么什么情况下，女生会先出来呢？肯定是女生出来的概率最大的时候了，那什么时候女生出来的概率最大啊，那肯定是女厕所比男厕所多人的时候了，这个就是你估计到的参数了。</p><p>回到男生身高那个例子。在学校那么男生中，我一抽就抽到这100个男生（表示身高），而不是其他人，那是不是表示在整个学校中，这100个人（的身高）出现的概率最大啊。那么这个概率怎么表示？就是上面那个似然函数$L(\theta)$。所以，我们就只需要找到一个参数θ，其对应的似然函数$L(\theta)$最大，也就是说抽到这100个男生（的身高）概率最大。这个叫做$\theta$的最大似然估计量，记为：</p><script type="math/tex; mode=display">\hat{\theta}=arg maxL(\theta)</script><p>可以看到$L(\theta)$是连乘的，所以为了便于分析，还可以定义对数似然函数，将其变成连加的：</p><p><img src="/2018/06/03/ML-Expectation-Maximization-Algorithm/Screen Shot 2018-06-03 at 4.44.37 PM.png" alt="Screen Shot 2018-06-03 at 4.44.37 PM"></p><p>这样使似然函数取得最大值的$\theta$便是我们的估计。这里就回到了求最值的问题了。怎么求一个函数的最值？当然是求导，然后让导数为0，那么解这个方程得到的$\theta$就是了（当然，前提是函数$L(\theta)$连续可微）。那如果θ是包含多个参数的向量那怎么处理啊？当然是求$L(\theta)$对所有参数的偏导数，也就是梯度了，那么n个未知的参数，就有n个方程，方程组的解就是似然函数的极值点了，当然就得到这n个参数了。</p></li></ol></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://www.youtube.com/watch?v=cXHvC_FGx24" target="_blank" rel="noopener">SciPy.minimize</a></p><ol><li><p><a href="https://cosx.org/2009/07/maximum-likelihood-estimation-in-r" target="_blank" rel="noopener">题目</a></p><p>采用geyser 数据，该数据采集自美国黄石公园内的一个名叫 Old Faithful 的喷泉。“waiting”就是喷泉两次喷发的间隔时间，“duration”当然就是指每次喷发的持续时间。在这里，我们只用到 “waiting” 数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">waiting  duration</div><div class="line"><span class="number">1</span>        <span class="number">80</span> <span class="number">4.0166667</span></div><div class="line"><span class="number">2</span>        <span class="number">71</span> <span class="number">2.1500000</span></div><div class="line"><span class="number">3</span>        <span class="number">57</span> <span class="number">4.0000000</span></div><div class="line"><span class="number">4</span>        <span class="number">80</span> <span class="number">4.0000000</span></div><div class="line"><span class="number">5</span>        <span class="number">75</span> <span class="number">4.0000000</span></div><div class="line">......</div></pre></td></tr></table></figure><p><img src="/2018/06/03/ML-Expectation-Maximization-Algorithm/Screen Shot 2018-06-03 at 8.29.59 PM.png" alt="Screen Shot 2018-06-03 at 8.29.59 PM"></p><p><img src="/2018/06/03/ML-Expectation-Maximization-Algorithm/Screen Shot 2018-06-03 at 8.30.27 PM.png" alt="Screen Shot 2018-06-03 at 8.30.27 PM"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats <span class="comment">#获取正态分布</span></div><div class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize <span class="comment">#目标优化</span></div><div class="line"></div><div class="line"><span class="comment">#####数据存储于.txt文件中</span></div><div class="line">data = np.loadtxt(<span class="string">'data'</span>)</div><div class="line">values = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</div><div class="line">    values.append(i[<span class="number">2</span>])</div><div class="line">values = np.array(values)</div><div class="line"></div><div class="line"><span class="comment">#####定义极大似然函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">objective_func</span><span class="params">(params)</span>:</span><span class="comment">#优化函数，总共优化5个参数</span></div><div class="line">    prob = params[<span class="number">0</span>]</div><div class="line">    mu1 = params[<span class="number">1</span>]</div><div class="line">    sigma1 = params[<span class="number">2</span>]</div><div class="line">    mu2 = params[<span class="number">3</span>]</div><div class="line">    sigma2 = params[<span class="number">4</span>]</div><div class="line">    norm_dis1 = stats.norm.pdf(values,loc=mu1,scale=sigma1) <span class="comment">#将x轴数据输入，输出该样本的正态分布的概率密度</span></div><div class="line">    norm_dis2 = stats.norm.pdf(values,loc=mu2,scale=sigma2)</div><div class="line">    f = prob*norm_dis1+(<span class="number">1</span>-prob)*norm_dis2</div><div class="line">    L = np.sum(np.log(f))</div><div class="line">    <span class="keyword">return</span> -L <span class="comment">#minimize函数求解最小值，但是我们要最大化，所以加一个“-”</span></div><div class="line"></div><div class="line"><span class="comment">#####求解</span></div><div class="line">param = np.array([<span class="number">0.5</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">80</span>,<span class="number">10</span>]) <span class="comment">#参数初始化,根据数据直方分布图猜测</span></div><div class="line">results = minimize(objective_func, param, method=<span class="string">'nelder-mead'</span>)</div><div class="line">paramss = results.x <span class="comment">#[0.36088303 54.61479245  5.87121392 80.09109663  5.86777145]</span></div><div class="line">prob = paramss[<span class="number">0</span>]</div><div class="line">mu1 = paramss[<span class="number">1</span>]</div><div class="line">sigma1 = paramss[<span class="number">2</span>]</div><div class="line">mu2 = paramss[<span class="number">3</span>]</div><div class="line">sigma2 = paramss[<span class="number">4</span>]</div><div class="line"></div><div class="line"><span class="comment">#####数据可视化</span></div><div class="line">x = np.linspace(<span class="number">40</span>,<span class="number">120</span>,<span class="number">100</span>)</div><div class="line">f = prob*stats.norm.pdf(x,loc=mu1,scale=sigma1) + (<span class="number">1</span>-prob)*stats.norm.pdf(x,loc=mu2,scale=sigma2)</div><div class="line">plt.plot(x,f,color=<span class="string">'r'</span>) <span class="comment">#将估计的参数函数代入原密度函数。</span></div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/2018/06/03/ML-Expectation-Maximization-Algorithm/Screen Shot 2018-06-03 at 8.44.22 PM.png" alt="Screen Shot 2018-06-03 at 8.44.22 PM"></p></li></ol><h1 id="期望最大算法"><a href="#期望最大算法" class="headerlink" title="期望最大算法()"></a>期望最大算法()</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><blockquote><p>回到上面那个身高分布估计的问题。现在，通过抽取得到的那100个男生的身高和已知的其身高服从高斯分布，我们通过最大化其似然函数，就可以得到了对应高斯分布的参数$\theta=[\mu,\sigma]^T$了。那么，对于我们学校的女生的身高分布也可以用同样的方法得到了。</p><p>如果对学生抽样时，男生和女生混合在一起，200个人（的身高）里面随便给我指一个人（的身高），我都无法确定这个人（的身高）是男生（的身高）还是女生（的身高）。也就是说你不知道抽取的那200个人里面的每一个人到底是从男生的那个身高分布里面抽取的，还是女生的那个身高分布抽取的。用数学的语言就是，抽取得到的每个样本都不知道是从哪个分布抽取的。这个时候，对于每一个样本或者你抽取到的人，就有两个东西需要猜测或者估计的了，一是这个人是男的还是女的？二是男生和女生对应的身高的高斯分布的参数是多少？只有当我们知道了哪些人属于同一个高斯分布的时候，我们才能够对这个分布的参数作出靠谱的预测，例如刚开始的最大似然所说的，但现在两种高斯分布的人混在一块了，我们又不知道哪些人属于第一个高斯分布，哪些属于第二个，所以就没法估计这两个分布的参数。反过来，只有当我们对这两个分布的参数作出了准确的估计的时候，才能知道到底哪些人属于第一个分布，那些人属于第二个分布。</p></blockquote><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><blockquote><p>EM的意思是“Expectation Maximization”，在我们上面这个问题里面，我们是先随便猜一下男生（身高）的正态分布的参数：如均值和方差是多少。例如男生的均值是1米7，方差是0.1米（当然了，刚开始肯定没那么准），然后计算出每个人更可能属于第一个还是第二个正态分布中的（例如，这个人的身高是1米8，那很明显，他最大可能属于男生的那个分布），这个是属于Expectation一步。有了每个人的归属，或者说我们已经大概地按上面的方法将这200个人分为男生和女生两部分，我们就可以根据之前说的最大似然那样，通过这些被大概分为男生的n个人来重新估计第一个分布的参数，女生的那个分布同样方法重新估计。这个是Maximization。然后，当我们更新了这两个分布的时候，每一个属于这两个分布的概率又变了，那么我们就再需要调整E步……如此往复，直到参数基本不再发生变化为止。</p><p>这里把每个人（样本）的完整描述看做是三元组yi={xi,zi1,zi2}，其中，xi是第i个样本的观测值，也就是对应的这个人的身高，是可以观测到的值。zi1和zi2表示男生和女生这两个高斯分布中哪个被用来产生值xi，就是说这两个值标记这个人到底是男生还是女生（的身高分布产生的）。这两个值我们是不知道的，是隐含变量。确切的说，zij在xi由第j个高斯分布产生时值为1，否则为0。例如一个样本的观测值为1.8，然后他来自男生的那个高斯分布，那么我们可以将这个样本表示为{1.8, 1, 0}。如果zi1和zi2的值已知，也就是说每个人我已经标记为男生或者女生了，那么我们就可以利用上面说的最大似然算法来估计他们各自高斯分布的参数。但是它们未知，因此我们只能用EM算法。</p></blockquote><h2 id="EM算法推导"><a href="#EM算法推导" class="headerlink" title="EM算法推导"></a><a href="https://www.youtube.com/watch?v=REypj2sy_5U" target="_blank" rel="noopener">EM算法推导</a></h2><blockquote><p>假设我们知道了样本$X=\{x_1,x_2,…,x_n\}$的分布，比如正态分布，那么我们需要估计的参数就是均值$\mu$和方差$\sigma^2$，即：</p><script type="math/tex; mode=display">\mu=\frac{x_1+x_2+...+x_n}{n}\\\sigma^2=\frac{(x_1-\mu)^2+(x_2-\mu)^2+...+(x_n-\mu)^2}{n}</script><p>这样我们就可以估计样本分布参数了。</p><p>但是对于给定的样本$X=\{x_1,x_2,…,x_n\}$,假设它们来自于两个正态分布$N_1(\mu_1,\sigma_1^2)$和$N_2(\mu_2,\sigma_2^2)$，但是我们不知道每一个样本$x_i$具体来自于哪一个分布，所以我们的额外需要估计的一个参数$\pi$，即每一个样本点来自于分布1的概率向量，那么每一个样本点来自于样本2的概率就是$1-\pi$。</p><p>假设我们知道了两个分布，即两个正态分布的参数已知，那么对于每一个样本$x_i$，我们假设这个样本来自于$N_1$，那么我们可以计算出该样本的概率$\pi(i)=P_{N_1}(x_i)$；同理，我们也可以计算出该样本属于$N_2$的概率$P_{N_2}(x_i)$。这样，直觉上，概率越大，样本点越可能属于对应的那个分布。对所有的样本点进行这样的概率比较，我们就可以将样本点分成两类，一个是更可能属于分布1的样本点$X_{N_1}$，一个是更可能属于分布2的样本点$X_{N_2}$。这样，我们就可以使用<script type="math/tex">X_{N_1}</script>中的点去更新$N_1$中的参数：</p><script type="math/tex; mode=display">\mu_1=\frac{\pi(1)x_1+\pi(2)x_2+...+\pi(n)x_n}{\pi(1)+\pi(2)+...+\pi(n)}\\\sigma_1^2=\frac{\pi(1)(x_1-\mu)^2+\pi(2)(x_2-\mu)^2+...+\pi(n)(x_n-\mu)^2}{\pi(1)+\pi(2)+...+\pi(n)}</script><p>同理，对于分布2的参数估计：</p><script type="math/tex; mode=display">\mu_2=\frac{(1-pi(1))x_1+(1-\pi(2))x_2+...+(1-\pi(n))x_n}{(1-\pi(1))+(1-\pi(2))+...+(1-\pi(n))}\\\sigma_2^2=\frac{(1-\pi(1))(x_1-\mu)^2+(1-\pi(2))(x_2-\mu)^2+...+(1-\pi(n))(x_n-\mu)^2}{(1-\pi(1))+(1-\pi(2))+...+(1-\pi(n))}</script></blockquote><h2 id="例子1：双硬币问题"><a href="#例子1：双硬币问题" class="headerlink" title="例子1：双硬币问题"></a><a href="https://blog.csdn.net/lilynothing/article/details/64443563" target="_blank" rel="noopener">例子1：双硬币问题</a></h2><ol><li><p><strong>问题</strong></p><p>假设有两枚硬币A、B，以相同的概率随机选择一个硬币，进行如下的抛硬币实验：共做5次实验，每次实验独立的抛十次，结果如图中a所示，例如某次实验产生了H、T、T、T、H、H、T、H、T、H，H代表正面朝上。  假设试验数据记录员可能是实习生，业务不一定熟悉，造成a和b两种情况  a表示实习生记录了详细的试验数据，我们可以观测到试验数据中每次选择的是A还是B  b表示实习生忘了记录每次试验选择的是A还是B，我们无法观测实验数据中选择的硬币是哪个  问在两种情况下分别如何估计两个硬币正面出现的概率？</p><p>对于已知是A硬币还是B硬币抛出的结果的时候，可以直接采用概率的求法来进行求解。对于含有隐变量的情况，也就是不知道到底是A硬币抛出的结果还是B硬币抛出的结果的时候，就需要采用EM算法进行求解了。如下图：</p><p><img src="/2018/06/03/ML-Expectation-Maximization-Algorithm/20170321142254904.jpeg" alt="20170321142254904"></p></li><li><p><strong>分析</strong></p><p>对于已知样本来源，那么我们需要估计的参数，对于硬币A，其正面概率$\theta_A$，那么其反面概率即$1-\theta_A$；对于硬币B， 其正面概率$\theta_B$，那么其反面概率即$1-\theta_B$；那么$\theta_A=\frac{正面样本数}{硬币A的样本数}=\frac{24}{24+6}=0.8$</p><p>那么对于不知道样本来源，我们先假设$\theta_A=0.6，\theta_B=0.5$,这样我们需要去估计每一个样本来自于硬币A的概率分布$\pi$，即由贝叶斯法则：</p><script type="math/tex; mode=display">\pi(A|i)=\frac{p(A)p(i|A)}{p(i)}</script><p>比如对于第一行的第一个硬币结果是H，那么$p(i|A)=0.6$，即硬币A产生正面的概率是0.6；$p(A)=\frac{1}{2}$，即选择硬币A的概率是0.5；$p(i)=p(A)p(i|A)+p(B)p(i|B)$，即硬币A和B均可以产生正面。</p><p>那么$\pi(1)=0.55$，即如果是正面向上的样本点，它有0.55可能性来自于样本A。同理可以计算出反面向上的样本点来自于A的概率是0.44，则所有样本点的$\pi=(H,T,T,T,H,…,H,T,H)=(0.55,0.44,0.44,0.44,0.55,…,0.55,0.44,0.55)$</p><p>那么更新$\theta_A,\theta_B$:</p><script type="math/tex; mode=display">\theta_A=\frac{正面次数}{总次数}=\frac{0.55*(5+9+8+4+7)}{0.55*33+0.44*17}=0.71\\\theta_B=\frac{(1-0.55)*(33)}{(1-0.55)*33+(1-0.44)*17}=0.61</script></li><li><p><strong>代码</strong></p></li></ol>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - Local Privacy</title>
      <link href="/2018/06/02/DP-Application%20-%20Local-Privacy/"/>
      <url>/2018/06/02/DP-Application%20-%20Local-Privacy/</url>
      <content type="html"><![CDATA[<p>Local differential privacy (LDP) techniques collects randomized answers from each user, with guarantees of plausible deniability; meanwhile, the aggregator can still build accurate models and predictors by analyzing large amounts of such randomized data.</p><p>Unlike other models of differential privacy, which publish randomized aggregates but still collect the exact sensitive data, LDP avoids collecting exact personal information in the first place, thus providing a stronger assurance to the users and to the aggregator.</p><p>The well-established Laplace mechanism and exponential mechanism are no longer suitable to the local setting in which a user may have only a single element to release. But unlike the laplace mechanism where we can use the noisy output directly, we need to do some estimation on the randomized output to get the estimator in LDP.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-11 at 10.16.20 PM.png" alt="Screen Shot 2018-06-11 at 10.16.20 PM"></p><a id="more"></a><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-04 at 11.16.07 AM.png" alt="Screen Shot 2018-06-04 at 11.16.07 AM"></p><blockquote><ol><li>According to the above definition, the aggregator, who receives the perturbed tuple $t*$ , cannot distinguish whether the true tuple is $t$ or another tuple $t$ with high confidence (controlled by parameter $\epsilon$), regardless of the background information of the aggregator.</li><li>There is no neighbour databases in the local-DP; instead, for a local user, all pairs of his values should be undistinguished by using the mechanism.</li><li>While LDP provides rigorous privacy protection in the local setting, its drawback is on the utility side. In real-world applications, where the universe size $Dom(f)$ is large, achieving a reasonable trade-off between privacy and utility under LDP is almost a chimera. For example, in location protection, $Dom(f)$ is all possible locations of a user, which could be extremely large.</li></ol></blockquote><h2 id="Mechanism"><a href="#Mechanism" class="headerlink" title="Mechanism"></a>Mechanism</h2><p><a href="https://arxiv.org/pdf/1602.07387.pdf" target="_blank" rel="noopener">2016-Peter</a></p><h3 id="Binary-Values"><a href="#Binary-Values" class="headerlink" title="Binary Values"></a>Binary Values</h3><h4 id="W-RR-Categorical-data"><a href="#W-RR-Categorical-data" class="headerlink" title="W-RR-Categorical data"></a>W-RR-Categorical data</h4><ol><li><p><strong>Probelm setting</strong></p><p>In the binary attribute setting, say each user has a data $x, x\in\{0,1\}$。Now the user ranodmly sends his data $x=0 \ or \  x=1$ with a probability.  </p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen%20Shot%202018-06-05%20at%209.06.11%20PM.png" alt="Screen Shot 2018-06-05 at 9.06.11 PM"></p><p>Now we want $P$ to ensure Local-DP and at the same time achieve a good utility.</p></li><li><p><strong>Analysis</strong></p><p>Without loss of generality, we assume the randomized response still favors the true value, i.e., $p_{00},p_{11}\gt{0.5}$；At the same time, $\frac{p_{00}}{p_{01}}\le{e^\epsilon}$ to ensure differential privacy.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-05 at 9.12.44 PM 2.png" alt="Screen Shot 2018-06-05 at 9.12.44 PM 2"></p></li><li><p><strong>Conclusion</strong></p><p>So based on above proof, we can get the transit matrix:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen%20Shot%202018-06-05%20at%209.15.49%20PM.png" alt="Screen Shot 2018-06-05 at 9.15.49 PM"></p><blockquote><ol><li>W-RR (Warner’s randomized response model) is optimal for binary distribution minimax estimation.</li><li>For all binary distributions $p$, all loss functions $l$, and all privacy levels $\epsilon$, $Q_{WRR}$ is the optimal solution to the private minimax distribution estimation problem.</li></ol></blockquote></li><li><p><strong>Utility</strong></p><blockquote><ul><li><p>Each user reports her true answer $t$ with probability $p$, and a random answer with probability $1 − p$. The latter has the same probability to be −1 and +1, whose expected value is zero. Therefore, the expected value for ui’s reported value is $p \times t$; thus, we can obtain an unbiased estimate of true answer by multiplying the reported value by a scaling factor $c = 1/p$. </p><p>$p_{00}=p+(1-p)*(1/2)\ \to \ p=\frac{e^\epsilon -1}{e^\epsilon +1}$.</p><p>So each user reports his random value in the following way to get an unbiased estimator:</p><script type="math/tex; mode=display">t^*=\left\{\begin{align} &c\times t=\frac{e^\epsilon +1}{e^\epsilon -1}\times t  & \textrm{Pr=p+(1-p)/2}=\frac{e^\epsilon }{e^\epsilon +1} \\&-c\times t=-\frac{e^\epsilon +1}{e^\epsilon -1}\times t  & \textrm{Pr=(1-p)/2}=\frac{1 }{e^\epsilon +1}\end{align}\right.</script></li><li><p>Once the aggregator receives all reported values for attribute $t$ , it computes the average over all users, which is an estimate of the mean value $\mathbb{E}[t]$ for $t$. Since $t$ can be either $+1$ or $-1$, the the percentage of users with $+1$ is $\frac{1+\mathbb{E}[t]}{2}$ and +1 is $\frac{1-\mathbb{E}[t]}{2}$</p></li></ul></blockquote></li></ol><h3 id="Polychotomous-Values"><a href="#Polychotomous-Values" class="headerlink" title="Polychotomous Values"></a>Polychotomous Values</h3><ol><li><p><strong>Problem setting</strong></p><p>Now we extend the question to multiple attributes and each user has a data $x, x\in\{0,1,2,…,t\}$。And the transit matrix is  </p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-05 at 9.22.05 PM.png" alt="Screen Shot 2018-06-05 at 9.22.05 PM"></p></li><li><p><strong>Solution</strong></p><ul><li><p><strong>K-ary Randomized Response</strong>-Categorical data</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-05 at 4.51.03 PM.png" alt="Screen Shot 2018-06-05 at 4.51.03 PM"></p><blockquote><p>Remarks:</p><ul><li>k-RR mechanism is optimal in the low privacy regime while suboptimal in high privacy regime.</li></ul></blockquote></li><li><p><strong>K-RAPPOR</strong>-Categorical data</p><p>The simplest version of RAPPOR, , called the basic one-time RAPPOR and referred to herein as k-RAPPO. There are several steps here.</p><blockquote><ol><li><p>data representaion</p><p>K-RAPPOR maps the input $X$ of size $k$ to an output $Y=\{0,1\}^k$ of size $2^k$. </p><p>Firstly, we map $X$ deterministically to $\widetilde{X}=R^k$, the $k$-dimensional Euclidean space, where $X=x_i \ (1\le{x_i}\le{k})$ and $\widetilde{X}=e_i\in\{0,1\}^k$. Specifically, it deterministically maps $X=x_i$ to $\widetilde{X}=e_i$, where $e_i$ is the $i$-th standard basis vector.</p><p>For example, $k=3$, and the input $X=\{x_1,x_2,x_3\}$, then $\widetilde{X}$  is $\{001,010,100\}$. And $x_1$ is represented as 1st data in $\widetilde{X}$, which is 001, $x_2$ is 2ed one 010. $x_3$ is 3rd one 100.</p></li><li><p>bit perturbation</p><p>In order to achieve $\epsilon$-locally differential privacy, we randomize the coordinates of $\widetilde{X}$ independently to obtain the private vector $Y\in\{0,1\}^k$. Formally, the $j^{th}$ coordinate of $Y$ is given by :</p><script type="math/tex; mode=display">Y(i)=\begin{cases}\widetilde{X}(i) \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ p=\frac{e^{\epsilon/2}}{1+e^{\epsilon/2}}\\1-\widetilde{X}(i) \ \ \ \ \ \ \ \ \ \ \ \ q=1-\frac{e^{\epsilon/2}}{1+e^{\epsilon/2}}\end{cases}</script></li></ol><p>Remarks:</p><ul><li>k-RAPPOR is a optimal privacy-preserving mechanism in high privacy regime while suboptimal in low privacy regime.</li></ul></blockquote></li><li><p>Random Matrix Projection<a href="https://arxiv.org/pdf/1504.04686.pdf" target="_blank" rel="noopener">[2015-Bassily]</a><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498248" target="_blank" rel="noopener">[2016-Chen]</a><a href="https://arxiv.org/pdf/1705.04421.pdf" target="_blank" rel="noopener">[2017-Wang]</a><a href="https://arxiv.org/pdf/1606.05053.pdf" target="_blank" rel="noopener">[2016-Nguyen]</a>-Categorical data</p><p>Here, each attribute contains $k\ge2$ possible values and the aggregator aims to build a histogram that contains the estimated frequency for each of the $k$ possible values.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-09 at 9.59.32 PM.png" alt="Screen Shot 2018-06-09 at 9.59.32 PM"></p><blockquote><p>Algorithm R: $\epsilon$-Basic Randomizer</p><ol><li><p>Assume that the number of possible values $d$ in the categorical attribute is far larger than the number of users $n$; hence, the method applies random projection to reduce the dimensionality from $d$ to $m$</p></li><li><p><strong>Encoding</strong></p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-07 at 5.52.05 PM.png" alt="Screen Shot 2018-06-07 at 5.52.05 PM"></p><p>Encode($x$)=$\Phi[r,j]$, where $r$ r is selected uniformly at random from $\{1,2,…,m\}$ and $j$ is the index of $x$ in original dataset $\{x_1,x_2,…,x_d\}$.</p><p>So for each user, the return vector is  $m$-dimensional vector where $s^{th} $ entry is $z_j$ and others are 0, which means the true loc in $i^{th} $ pos is maped to $s^{th}$ pos.</p></li><li><p><strong>Aggregation</strong></p><p>After receive all $z_i$ from users, we compute $\hat{z}=\frac{1}{n}\sum_{i=1}^{n}z_i$, where $\hat{z}$ is a $m$-dimentional vector.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-09 at 10.07.38 PM.png" alt="Screen Shot 2018-06-09 at 10.07.38 PM"></p></li></ol><p>Remarks:</p><ol><li><p>We map the input domain with size $d$ to output domain with size $m$, where $m$ is determined through Johnson-Lindenstrauss Lemma.</p></li><li><p>$R$ is $\epsilon$-LDP for every choice of the index $s$</p></li><li>$R(x)=z_j$ is an unbiased estimator of $x$. That is, $\mathbb{E}[R(x)]=x$</li></ol></blockquote></li><li><p><a href="https://arxiv.org/pdf/1606.05053.pdf" target="_blank" rel="noopener">Harmony-for-numeric</a>-Numeric data</p><blockquote><p>This method is to handle multiple numeric attributes. Say a user has a private tuple $t$, which contains $d$ attributes $A_1,A_2,…,A_d$. And assuming that each numeric attribute has a domain $[-1,1]$. And for numeric data, we try to calculate the mean of data.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-09 at 6.11.42 PM.png" alt="Screen Shot 2018-06-09 at 6.11.42 PM"></p><p>Remarks:</p><ol><li><p>The return tuple $t^*_{i}$ has non-zero value on only one attribute $A_j(j\in [d])$ and this value is binary.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-09 at 6.14.45 PM.png" alt="Screen Shot 2018-06-09 at 6.14.45 PM"></p></li><li><p>Algorithm 2 is $\epsilon$-LDP.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-09 at 6.16.58 PM.png" alt="Screen Shot 2018-06-09 at 6.16.58 PM"></p></li><li><p>the estimator $\frac{1}{n}\sum^{n}_{i=1}t^*[A_j]$ is an unbiased estimator of the mean of $A_j$.</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-09 at 6.20.05 PM.png" alt="Screen Shot 2018-06-09 at 6.20.05 PM"></p></li></ol><ol><li>xx</li></ol></blockquote></li></ul></li></ol><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h3 id="Multiple-Attributes-Mean-or-Frequencies-Estimation-2016-Nguyen-Code"><a href="#Multiple-Attributes-Mean-or-Frequencies-Estimation-2016-Nguyen-Code" class="headerlink" title="Multiple Attributes Mean or Frequencies Estimation 2016-Nguyen Code"></a>Multiple Attributes Mean or Frequencies Estimation <a href="https://arxiv.org/pdf/1606.05053.pdf" target="_blank" rel="noopener">2016-Nguyen</a> <a href="https://github.com/pokhym/LDP" target="_blank" rel="noopener">Code</a></h3><blockquote><p>They propose the Harmony method, which can handle multiple numeric or categorical attributes. </p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-09 at 10.21.40 PM.png" alt="Screen Shot 2018-06-09 at 10.21.40 PM"></p><p>Remarks:</p><ol><li>Algorithm2 is [Harmony-for-numeric] algorithm.</li><li>Algorithm3 is [Bassily and Smith’s method]</li><li>Each user randomly selects one attribute to submit.</li></ol></blockquote><h3 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h3><blockquote><p>Since the gradient is the numeric number, so the author user <strong>[Harmony-for-numeric]</strong> algorithm for randomized operation. But the error by this method is $\sqrt{dlog(d)/\epsilon}$, where $d$ is the number of attributes (the length of input vector $x$).</p><p>For logistic regression and SVM, they use min-batch gradient descent with the batch size $k$, reducing error to $\sqrt{dlog(d)/(\epsilon k)}$.</p><p>For linear regression, they introduce <strong>Dimension reduction</strong>, which introdcues error $\sqrt{rlog(r)/(\epsilon k)}$</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-11 at 11.28.05 AM.png" alt="Screen Shot 2018-06-11 at 11.28.05 AM"></p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-11 at 11.29.58 AM.png" alt="Screen Shot 2018-06-11 at 11.29.58 AM"></p></blockquote><h3 id="Locations-Density-Estimation-2018-Kim"><a href="#Locations-Density-Estimation-2018-Kim" class="headerlink" title="Locations Density Estimation [2018-Kim]"></a>Locations Density Estimation <a href="Application of Local Differential Privacy to Collection of Indoor Positioning Data">[2018-Kim]</a></h3><p>A number of studies have recently been made on discrete distribution estimation in the local model, in which users obfuscate their personal data (e.g., location, response in a survey) by themselves and a data collector estimates a distribution of the original personal data from the obfuscated data.</p><p>The purpose of this research is to approximately compute the distribution of users in the indoor space. </p><h3 id="Pricacy-model"><a href="#Pricacy-model" class="headerlink" title="Pricacy model"></a>Pricacy model</h3><ol><li><p><strong>data representation</strong></p><p>There are $n$ locations $B=\{b_1,b_2,…,b_n\}$, and the location of a user is in the form of a $n$-bit array, denoted as $L$, where the bit corresponding to the user’s location is set to 1 while the others are set to 0. So the input space size is $n$, the output space size is $2^n$.</p></li><li><p><strong>RAPPOR</strong></p><p>The next step is to perturb L, where each bit in L is first perturbed by randomized response as follows:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 9.41.00 PM-8080101.png" alt="Screen Shot 2018-06-03 at 9.41.00 PM-8080101"></p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 9.42.49 PM.png" alt="Screen Shot 2018-06-03 at 9.42.49 PM"></p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 9.44.09 PM.png" alt="Screen Shot 2018-06-03 at 9.44.09 PM"></p><p>The instantaneous randomized response, S, is transmitted to the data collector server.</p><h3 id="Estimation"><a href="#Estimation" class="headerlink" title="Estimation"></a>Estimation</h3></li></ol><h4 id="STATISTIC-BASED-APPROACH"><a href="#STATISTIC-BASED-APPROACH" class="headerlink" title="STATISTIC-BASED APPROACH"></a>STATISTIC-BASED APPROACH</h4><blockquote><ol><li><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 9.49.04 PM.png" alt="Screen Shot 2018-06-03 at 9.49.04 PM"></p></li><li><p>the number of the instantaneous randomized responses of which the i-th bit is expected to be set to 1, $num(S_i)$, is estimated as follows:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen%20Shot%202018-06-03%20at%209.55.59%20PM.png" alt="Screen Shot 2018-06-03 at 9.55.59 PM"></p><p>$num(U_i)$ is estimated as follows:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen%20Shot%202018-06-03%20at%209.57.20%20PM.png" alt="Screen Shot 2018-06-03 at 9.57.20 PM"></p><p>then the number of location i where users have been to can be calculated by combining above two formulas:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen%20Shot%202018-06-03%20at%2010.04.58%20PM.png" alt="Screen Shot 2018-06-03 at 10.04.58 PM"></p><p>Let $N_i$ denotes the total number of instantaneous randomized responses, S, of which the i-bit is set to 1 as well as which is received between $ts_{start}$ and $ts_{end}$. And $N_{total}$ denotes the total number of instantaneous randomized responses, S, that the data collection server received from the data contributors in the time interval between  $ts_{start}$ and $ts_{end}$. </p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.08.06 PM.png" alt="Screen Shot 2018-06-03 at 10.08.06 PM"></p></li><li><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.08.45 PM.png" alt="Screen Shot 2018-06-03 at 10.08.45 PM"></p></li></ol></blockquote><h4 id="EM-BASED-APPROACH"><a href="#EM-BASED-APPROACH" class="headerlink" title="EM-BASED APPROACH"></a>EM-BASED APPROACH</h4><blockquote><p>Here we intend to estimate  $P(L=x_i)$.</p><ol><li><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.13.26 PM.png" alt="Screen Shot 2018-06-03 at 10.13.26 PM"></p></li><li><p>Then we want to calculate $P(pos_r|L=x_y)$</p><p>​    </p><p>Given a $n$-bit array $L$, the probabilities that the k-th bit of the corresponding permanent randomized response, U, sets to 1 and 0 are respectively computed as follows:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.21.19 PM.png" alt="Screen Shot 2018-06-03 at 10.21.19 PM"></p><p>Then, Given $L_k=1$, the probabilities that the k-th bit of the instantaneous randomized response, S, sets to 1 and 0 are respectively computed as follows:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.22.12 PM.png" alt="Screen Shot 2018-06-03 at 10.22.12 PM"></p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.22.22 PM.png" alt="Screen Shot 2018-06-03 at 10.22.22 PM"></p></li></ol><p>   <img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.26.21 PM.png" alt="Screen Shot 2018-06-03 at 10.26.21 PM"></p><ol><li><p>The EM algorithm that computes $P(L =  x_i)$, 1 ≤ i ≤ n proceeds as follows:</p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.27.39 PM.png" alt="Screen Shot 2018-06-03 at 10.27.39 PM"></p><p><img src="/2018/06/02/DP-Application - Local-Privacy/Screen Shot 2018-06-03 at 10.28.02 PM.png" alt="Screen Shot 2018-06-03 at 10.28.02 PM"></p></li></ol></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p> [2018-Kim] Application of Local Differential Privacy to Collection of Indoor Positioning Data</p><p>[2016-Peter]  Discrete Distribution Estimation under Local Privacy</p><p>[2015-Bassily] Local, Private, Efficient Protocols for Succinct Histograms</p><p>[2016-Chen] Private Spatial Data Aggregation in the Local Setting</p><p>[2017-Wang] Optimizing Locally Differentially Private Protocols</p><p>[2016-Nguyen] Collecting and Analyzing Data from Smart Device Users with Local Differential Privacy</p><p>​          </p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mechanism of Differential Privacy</title>
      <link href="/2018/05/30/DP-Mechanism/"/>
      <url>/2018/05/30/DP-Mechanism/</url>
      <content type="html"><![CDATA[<h1 id="Laplace-Distribution"><a href="#Laplace-Distribution" class="headerlink" title="Laplace Distribution"></a>Laplace Distribution</h1><p>The following details are from <a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83" target="_blank" rel="noopener">Wikipedia</a>. And the python version is <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.laplace.html" target="_blank" rel="noopener">here</a></p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-05-30 at 6.17.03 PM.png" alt="Screen Shot 2018-05-30 at 6.17.03 PM"></p><p><img src="/2018/05/30/DP-Mechanism/Laplace_distribution_pdf-7722463.png" alt="Laplace_distribution_pdf-7722463"></p><blockquote><ol><li>概率密度函数反映了概率在$ x$点处的密集程度。</li><li>x轴表示每一种取值，而y轴表示概率。</li><li>the variance of this distribution is $\sigma^2=2b^2$, while its scale is $b$.</li></ol></blockquote><h2 id="CDF"><a href="#CDF" class="headerlink" title="CDF"></a>CDF</h2><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-05-30 at 6.18.29 PM.png" alt="Screen Shot 2018-05-30 at 6.18.29 PM"></p><p><img src="/2018/05/30/DP-Mechanism/Laplace_distribution_cdf.png" alt="Laplace_distribution_cdf"></p><blockquote><ol><li>CDF表示连续累积概率，即$F(0)=P(x\le{0})$，即所有非正值的概率和。</li><li>PDF 表示某一点取值的概率$f(0)=P(x=0)=0.5$</li></ol></blockquote><h1 id="Sensitivity"><a href="#Sensitivity" class="headerlink" title="Sensitivity"></a>Sensitivity</h1><h2 id="L1-sensitivity"><a href="#L1-sensitivity" class="headerlink" title="L1-sensitivity"></a>L1-sensitivity</h2><blockquote><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-06 at 3.41.25 PM.png" alt="Screen Shot 2018-06-06 at 3.41.25 PM"></p><p><strong>Remarks</strong>:</p><ol><li>$N^{|X|}$ 表示数据库的大小是$|X|$, 即有$X$条记录；而$\mathbb{R}$表示real number，$\mathbb{R}^{k}$则表示$k$维空间，即数据是$k$维的，$k$维向量。</li><li></li></ol></blockquote><h1 id="Laplace-Mechanism"><a href="#Laplace-Mechanism" class="headerlink" title="Laplace Mechanism"></a><a href="https://link.springer.com/content/pdf/10.1007%2F11681878_14.pdf" target="_blank" rel="noopener">Laplace Mechanism</a></h1><p>TO DO QUESTION??</p><ol><li><p>WHY LAPLACE DISTRIBUTION????</p></li><li><p>WHY SENSITIVITY IN THE SCALE????</p></li></ol><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><blockquote><p>the Laplace mechanism will simply compute $f$, and perturb each coordinate with noise drawn from the Laplace distribution.</p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-06 at 3.48.56 PM.png" alt="Screen Shot 2018-06-06 at 3.48.56 PM"></p><p>About the proof, the key is that :</p><ol><li><p>neighbourhood database:</p><p> $x\in{N^{|X|}}$ and $y\in{N^{|X|}}$, such that $||x-y||_1=\le1$. </p></li><li><p>noise result:</p><p>$\frac{P(f(x)=z)}{P(f(y)=z)}\le{e^{\epsilon}}$</p></li></ol><p>Remarks:</p><ol><li><p>Let $\hat{f(x)}$ be the output of Laplace mechanism with zero mean given an input $x$. Then, for ant $x$, $\mathbb{E}[\hat{f(x)}]=f(x)$, where $f(x)$ is true query result without any perturbation.</p><p>$\mathbb{E}[\hat{f(x)}]=\int{P(x)}\hat{f(x)}dx=\int{P(x)(f(x)+n(x))}dx=f(x)\int{P(x)}dx+\int{P(x)n(x)}dx$</p><p>Obviously, $\int{P(x)}dx=1$, since the distribution of $n$ has zero mean so it is symmetric. For any $Pr(x)$, there are always two variables $n_1$ and $n_2$ such that $n_2=-n_1$, resulting in $P(n_1)n_1+P(n_2)n_2=0$. So $\int{P(x)n(x)}dx=0$.</p><p>SO $\mathbb{E}[\hat{f(x)}]=f(x)$</p></li></ol><ol><li><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-11 at 10.30.20 AM.png" alt="Screen Shot 2018-06-11 at 10.30.20 AM"></li></ol></blockquote><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote><p>We sometimes refer to the problem of responding to large numbers of (possibly arbitrary) queries as the query release problem.</p><ol><li><p>Counting Queries</p><p>Since the sensitivity of a counting query is 1 (the addition or deletion of a single individual can change a count by at most 1), so $(\epsilon,0)$-differential privacy can be achieved for counting queries by the addition of noise scaled to $\frac{1}{\epsilon}$, that is, by adding noise drawn from Lap($\frac{1}{\epsilon}$). The expected distortion, or error, is $\frac{1}{\epsilon}$, independent of the size of the database.</p><p>A fixed but arbitrary list of m counting queries can be viewed as a vector-valued query. Absent any further information about the set of queries a worst-case bound on the sensitivity of this vector-valued query is m, as a single individual might change every count. In this case $(\epsilon,0)$-differential privacy can be achieved by adding noise scaled to $\frac{m}{\epsilon}$ to the true answer to each query.</p></li><li><p>Histogram Queries</p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-06 at 4.04.09 PM.png" alt="Screen Shot 2018-06-06 at 4.04.09 PM"></p></li></ol></blockquote><h2 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h2><blockquote><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-06 at 4.05.35 PM.png" alt="Screen Shot 2018-06-06 at 4.05.35 PM"></p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-06 at 4.12.18 PM.png" alt="Screen Shot 2018-06-06 at 4.12.18 PM"></p><p>Remarks:</p><ol><li>Theorem3.8中，Pr[]里面，左边表示Laplace mechanism产生的error，右边中的两项，$t=In(\frac{k}{\delta})$，$k$是query result的维度，$b=\frac{\Delta{f}}{\epsilon}$。</li><li><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-06 at 4.18.19 PM.png" alt="Screen Shot 2018-06-06 at 4.18.19 PM"></li></ol></blockquote><h1 id="Exponential-mechanism"><a href="#Exponential-mechanism" class="headerlink" title="Exponential mechanism"></a>Exponential mechanism</h1><p>The exponential mechanism was designed for situations in which we wish to choose the “best” response but adding noise directly to the computed quantity can completely destroy its value, such as setting a price in an auction, where the goal is to maximize revenue, and adding a small amount of positive noise to the optimal price (in order to protect the privacy of a bid) could dramatically reduce the resulting revenue.</p><h2 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h2><p>The sensitivity of score function $q$ tells us the maximum change in the scoring function for any pair of datasets $d$ and $d’$ such that $|d\otimes d’|=1$:</p><script type="math/tex; mode=display">\Delta q = max_{r,d,d' where |d\otimes d'|=1 }|q(d,r)-q(d',r)|</script><blockquote><p>Say we have a discrete candidate output in a range $R$, and assume that the probability distribution of output is $u$, commonly uniform. The general mechanism is to design a query function $q:D^n(input)\times{R(output)}\to{\mathbb{R}}$, which assign a real valued score to any pair $(d,r)$ from $D^n\times{R}$. With a prior distribution of candidate output $u$, we amplify the probability associated with each output by a factor of $e^{\epsilon{q(d,r)}}$:</p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-07 at 12.43.02 PM.png" alt="Screen Shot 2018-06-07 at 12.43.02 PM"></p><script type="math/tex; mode=display">\Delta{q}=max_{r\in{R}}\ max_{x,y:||x-y||_1\le{1}}|q(x,r)-q(y-r)|</script><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-07 at 12.47.15 PM.png" alt="Screen Shot 2018-06-07 at 12.47.15 PM"></p></blockquote><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-08 at 4.21.27 PM.png" alt="Screen Shot 2018-06-08 at 4.21.27 PM"></p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-08 at 4.21.48 PM.png" alt="Screen Shot 2018-06-08 at 4.21.48 PM"></p><blockquote><p>Remarks:</p><ol><li><p>by amplifying the probability, the sum of all output probability will not equal 1. So in order to bound the probability, we need a normalization term.</p></li><li><p>from the denifition, if we set the probability factor as $\epsilon$, then it will provide us $2\epsilon \Delta q$, which amptifies with a factor $2\Delta q$. SO if we want $\epsilon$-DP, then the probability factor should be $\frac{\epsilon}{2\Delta q}$</p></li><li><p>the exponential mechanism defines a distribution over the output domain and samples from this distribution.</p></li><li><p>now we want to know how a small change in the database can affect the output. Say we have database $d$ and $d’$, where $||d-d’||=1$. And we assume $q(d,r)=q(d’,r)+\Delta{q}$. we want to bound the probability ratio $\frac{P(r|d)}{P(r|d’)}$</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\frac{P(r|d)}{P(r|d')}&=\frac{e^{\epsilon{q(d,r)}}}{\int{e^{\epsilon{q(d,r)}}}}\div\frac{e^{\epsilon{q(d',r)}}}{\int{e^{\epsilon{q(d',r)}}}}\\&=\frac{e^{\epsilon{q(d,r)}}}{e^{\epsilon{q(d',r)}}}\times\frac{\int{e^{\epsilon{q(d',r)}}}}{\int{e^{\epsilon{q(d,r)}}}}\\for\ the\ left\ one,\ we\ replace\ q(d,r)=q(d',r)+\Delta{q} ,\\ for\ right\ since\ q(d',r)= q(d',r)-q(d,r)+q(d,r)\\&={\frac{e^{\epsilon{(q(d',r)+\Delta{q})}}}{e^{\epsilon{q(d',r)}}}}\times\frac{\int{e^{\epsilon{(q(d',r)}-\epsilon{(q(d,r)+\epsilon{(q(d,r)}})}}}{\int{e^{\epsilon{q(d,r)}}}}\\since\ |q(d',r)-q(d,r)|\le \Delta q,\ so\ we\ have \\&\le  e^{\epsilon \Delta q} \times \int{e^{\epsilon \Delta q}}\\&=e^{\epsilon \Delta q}\times{e^{\epsilon{\Delta{q}}}}\\&=e^{2\epsilon \Delta q}\end{aligned}\end{equation}</script></li></ol></blockquote><h2 id="Utility-1"><a href="#Utility-1" class="headerlink" title="Utility"></a>Utility</h2><p>The exponential mechanism can often give strong utility guarantees, because it discounts outcomes exponentially quickly as their quality score falls off.</p><p>Let $OPT_{q}(d)=max_{r\in R}q(d,r)$ denote the maximum score of any candidate output $r\in R$ with respect to database $d$. </p><p>Fixing a database $d$, let $R_{OPT}=\{r\in R:q(d,r)=OPT_{q}(x)\}$ denote the set of candidates in $R$ which attain maximum utility score $OPT_q(x)$. Then:</p><p><strong>Theorem</strong>:</p><script type="math/tex; mode=display">Pr[q(M_{E(d,q,R)}\le OPT_q(d)-\frac{2\Delta q}{\epsilon}(ln(\frac{|R|}{|R_{OPT}|})+t))]\le e^{-t}</script><p><strong>Corollary</strong>:</p><script type="math/tex; mode=display">Pr[q(M_{E(d,q,R)}\le OPT_q(d)-\frac{2\Delta q}{\epsilon}(ln(|R|)+t))]\le e^{-t}</script><blockquote><p>Remarks:</p><ol><li>We bound the probability that the exponential mechanism returns a “good” output of $R$, where good is measured in terms of $OPT_q(d)$.  The result is that it will be highly unlikely that the returned output $r$ has a utility score that is inferior to $OPT_q(x)$ by more than an additive factoc of $O(\frac{\Delta q}{\epsilon}log|R|)$</li><li>from the utility theorem, we can find that utility of the mechanism only depends on log(|Outputs|), leading to the fact that sampling an output may not be computationally efficient if output space is large. </li><li><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-08 at 11.08.54 AM.png" alt="Screen Shot 2018-06-08 at 11.08.54 AM"></li><li><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-08 at 3.37.36 PM.png" alt="Screen Shot 2018-06-08 at 3.37.36 PM"></li><li></li></ol></blockquote><h2 id="Laplace-vs-Exponential"><a href="#Laplace-vs-Exponential" class="headerlink" title="Laplace vs Exponential"></a><a href="http://www.cs.bu.edu/~goldbe/teaching/HW55812/exponential.pdf" target="_blank" rel="noopener">Laplace vs Exponential</a></h2><p>Exponential mechanism is an instance of the exponential mechanism.</p><ol><li><p><strong>candidate output domain</strong></p><p>Say we have the output domian $r\in R$, and the query function is $f$ which works over the database $d$ and $d’$ such that $|d\otimes{d’}|=1$.</p></li><li><p><strong>utility function</strong></p><script type="math/tex; mode=display">q(d,r)=-|f(d)-r|</script><p>To see how this works, notice first that with this scoring function, the exponential mechanism becomes:</p><p>$M(d,q,\epsilon)$=output $r$ with probability proportional to $e^{\epsilon q(d,r)}$</p><p>which provides $2\epsilon \Delta q$-DP.</p></li><li><p><strong>sensitivity</strong></p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\Delta q &=max|q(d,r)-q(d',r)|\\&=max||f(d')-r|-|f(d,r)||\\&\le max|f(d',r)-f(d,r)| \ \ \ \ \ \ \ \ \ \ \ \ \ \ (triangle inequlity)\\\end{aligned}\end{equation}</script><blockquote><p>So based on above details, for query function with sensitivity 1 and with privacy parameter $\epsilon$, exponential mechanism provides $2\epsilon$-DP, while Laplace mechanism provides $\epsilon$-DP. This is because we’ve used the general analysis of the exponential mechanism, so our result is less “tight”.</p><p>This means that to provide the same privacy level $\epsilon$, laplace mechanism is $\epsilon-$DP while exponential mechanism is  $\frac{\epsilon}{2}$-DP, meaning more noise.</p></blockquote></li></ol><h2 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h2><p><strong>The median mechanism</strong></p><p>Recall that the median of a list numbers $d=\{1,2,4,5,6\}$ is 4; so we write $med(d)=4$</p><ol><li><p><strong>candidate ooutputs</strong></p><p>every element in $d$ is the possilble output of the median query.</p></li><li><p><strong>utility function</strong></p><p>For the median example, our scoring function will be:</p><p>$q(d,r)=-min|d\otimes d’|$ such that $med(d’)=r$</p><blockquote><p>What does it mean? The idea is that we take in a database $d$ and a candidate median $r$, and we look for a $d’$ that is as similar as possible to $d$, such that $med(d’)=r$.</p><p>For example, $d=\{1,2,3,4,5\}$ and candidate output $r=4$. What we want to do is to change $d$ to $d’$ so that  $med(d’)=4$. To do so, we can remove $1$ and $2$ from the $d$ to get $d’=\{3,4,5\}$. so $q(\{1,2,3,4,5\},4)=-2$. If $r=3$, $q(\{1,2,3,4,5\},4)=0$ becasue $3$ is the true median and we needn’t change anything about database $d$. </p></blockquote></li><li><p><strong>sensitivity</strong> </p><p>We can get $|q(d,r)-q(d’,r)|\le 1$. It is obvious because the input database is added or removed one element, for the unchanged database, the change you make to make $r$ median is $x$ step.  Now we have already help you make a step. So the best situation is you only need to maek (x-1) step for x as median. The utility change is 1. While the worst situation is the addition or removal in the original database don’t help you at all, so you still need $x$ step. So the utility change is 0.</p><p><strong>There is the mathametical proof.</strong></p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-09 at 12.02.40 PM.png" alt="Screen Shot 2018-06-09 at 12.02.40 PM"></p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-09 at 12.02.49 PM.png" alt="Screen Shot 2018-06-09 at 12.02.49 PM"></p></li></ol><h1 id="Composition-Theorems"><a href="#Composition-Theorems" class="headerlink" title="Composition Theorems"></a>Composition Theorems</h1><p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2009/06/sigmod115-mcsherry.pdf" target="_blank" rel="noopener">[2009-McSherry]</a> Any approach to privacy must address issues of composition: that several outputs may be taken together, and should still provide privacy guarantees even when subjected to joint analysis</p><p><a href="https://www.cis.upenn.edu/~aaroth/Papers/privacybook.pdf" target="_blank" rel="noopener">[2014-Dwork]</a> The combination of two differentially private algorithms is differentially private itself. But the parameters $\epsilon$ and $\delta$ will necessarily degrade —- consider repeatedly computing the same statistic using the Laplace mechanism. The average of the answer given by each instance of the mechanism will eventually converge to the true value of the statistic, and so we cannot avoid that the strength of our privacy guarantee will degrade with repeated use.</p><h2 id="Sequential-composition"><a href="#Sequential-composition" class="headerlink" title="Sequential composition"></a>Sequential composition</h2><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-11 at 9.55.46 AM.png" alt="Screen Shot 2018-06-11 at 9.55.46 AM"></p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-11 at 10.31.41 AM.png" alt="Screen Shot 2018-06-11 at 10.31.41 AM"></p><blockquote><p>Proof:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}Pr(M(X)=O)&=\prod_{i=1}^{m}Pr(M_i(X)=O_i) \\&\le \prod_{i=1}^{m} e^{\epsilon_i}Pr(M_i{(X')=O_i})\\&=e^{\sum_{i=1}^{m}\epsilon_i}\prod_{i=1}^{m} Pr(M_i(X')=O_i)\\&=e^{\sum_{i=1}^{m}\epsilon_i} Pr(M_i(X)=O)\end{aligned}\end{equation}</script><p>x</p></blockquote><h2 id="Parallel-composition"><a href="#Parallel-composition" class="headerlink" title="Parallel composition"></a>Parallel composition</h2><p>While general sequences of queries accumulate privacy costs additively, when the queries are applied to disjoint subsets of the data we can improve the bound. Specifically, if the domain of input records is partitioned into disjoint sets, independent of the actual data, and the restrictions of the input data to each part are subjected to differentially-private analysis, the ultimate privacy guarantee depends only on the worst of the guarantees of each analysis, not the sum.</p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-11 at 9.58.34 AM.png" alt="Screen Shot 2018-06-11 at 9.58.34 AM"></p><h2 id="KL-Divergence"><a href="#KL-Divergence" class="headerlink" title="KL-Divergence"></a>KL-Divergence</h2><blockquote><p>又叫相对熵，是衡量分布间距离的一个度量。</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>设$P(i)​$和$Q(i)​$是$X​$取值的两个概率分布，则$P​$相对$Q​$的KL-Divergence是：</p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-06-05 at 10.10.43 AM.png" alt="Screen Shot 2018-06-05 at 10.10.43 AM"></p></blockquote><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><ol><li><p>非对称性</p><script type="math/tex; mode=display">D(p||q)\ne{D(q||p)}</script></li><li><p>非负性</p><script type="math/tex; mode=display">D(p||q)\ge0</script></li></ol></blockquote><p><a href="http://www.cis.upenn.edu/~aaroth/courses/slides/Lecture4.pdf" target="_blank" rel="noopener">[2011-Aaron]</a></p><p><img src="/2018/05/30/DP-Mechanism/Screen Shot 2018-05-31 at 3.10.30 PM.png" alt="Screen Shot 2018-05-31 at 3.10.30 PM"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[2014-Dwork] The Algorithmic Foundations of Differential Privacy</p><p>[2006-Dwork] Calibrating Noise to Sensitivity in Private Data Analysis</p><p>[2009-McSherry] Privacy Integrated Queries</p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Statistic 110</title>
      <link href="/2018/05/30/Statistic-110/"/>
      <url>/2018/05/30/Statistic-110/</url>
      <content type="html"><![CDATA[<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-041sc-probabilistic-systems-analysis-and-applied-probability-fall-2013/unit-i/" target="_blank" rel="noopener">Probabilistic Systems Analysis and Applied Probability</a></p><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-041sc-probabilistic-systems-analysis-and-applied-probability-fall-2013/unit-i/lecture-7/" target="_blank" rel="noopener">last time</a></p><h1 id="Independence"><a href="#Independence" class="headerlink" title="Independence"></a>Independence</h1><blockquote><p><strong>Definition</strong>:</p><script type="math/tex; mode=display">P(AB)=P(A)P(B)</script><p><img src="/2018/05/30/Statistic-110/Screen Shot 2018-06-10 at 11.04.20 PM.png" alt="Screen Shot 2018-06-10 at 11.04.20 PM"></p><p>Based on the pic, $P(AB)\ne P(A)P(B)$, so event A and event B are not independent event.</p></blockquote><h1 id="Discrete-Random-Variables"><a href="#Discrete-Random-Variables" class="headerlink" title="Discrete Random Variables"></a>Discrete Random Variables</h1><ol><li><p><strong>Probability mass function (PMF)</strong></p><p>it is the probability of a discrete random variable; while in continus setting, the probability of a random variable is called PDF.</p></li><li><p><strong>Expectation</strong></p><script type="math/tex; mode=display">E(X)=\sum_{x}xp_X(x)</script><blockquote><ul><li>Average in large number of repetitions the experiment</li></ul></blockquote></li><li><p><strong>Properties of expectations</strong></p><p><img src="/2018/05/30/Statistic-110/Screen Shot 2018-06-11 at 5.23.20 PM.png" alt="Screen Shot 2018-06-11 at 5.23.20 PM"></p><blockquote><ul><li>Once x is determined, then y is determined; so the probability of y is the probability of x;</li></ul></blockquote><p>If $\alpha , \beta$ are constants, then:</p><script type="math/tex; mode=display">E(\alpha)=\alpha\\E(\alpha X)=\alpha E(X)\\E(\alpha X+\beta)=\alpha E(X)+\beta</script></li><li><p><strong>Variance</strong></p><p><img src="/2018/05/30/Statistic-110/Screen Shot 2018-06-11 at 5.32.18 PM.png" alt="Screen Shot 2018-06-11 at 5.32.18 PM"></p><blockquote><ul><li>since $X$ is random while $E(X)$ is a number, so $X-E(X)$ is a random variable.</li><li>variance measures the average square distance from the mean.</li><li>a big variance means the variable are far away from the center while a small one means the variables are tightly concentrated around the mean value.</li></ul></blockquote></li><li><p><strong>Standard deviation</strong></p><script type="math/tex; mode=display">\sigma_X=\sqrt{var(X)}</script></li></ol><h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>乘除 —&gt; 加减</p><ol><li>$log_a(MN)=log_a{M}+log_a{N}$</li><li>$log_a{\frac{M}{N}}=log_a{M}-log_a{N}$</li></ol><h1 id="Unbiased-estimator"><a href="#Unbiased-estimator" class="headerlink" title="Unbiased estimator"></a><a href="https://www.zhihu.com/question/22983179/answer/23470969" target="_blank" rel="noopener">Unbiased estimator</a></h1><blockquote><p><img src="/2018/05/30/Statistic-110/Screen Shot 2018-06-06 at 9.20.56 PM.png" alt="Screen Shot 2018-06-06 at 9.20.56 PM"></p></blockquote><h1 id="Probability-and-Counting"><a href="#Probability-and-Counting" class="headerlink" title="Probability and Counting"></a>Probability and Counting</h1><p><strong>Sample space</strong>: a set of all possible outcomes of an experiment</p><p><strong>Event</strong>: a subset of the sample space</p><h1 id="Discrete-vs-Continuous-the-Uniform"><a href="#Discrete-vs-Continuous-the-Uniform" class="headerlink" title="Discrete vs. Continuous, the Uniform"></a>Discrete vs. Continuous, the Uniform</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><strong>PDF (Probability Density Function)</strong> : $X$ has PDF $f(x)$ if $P(a\le{X}\le{b})=\int_{a}^{b}f(x)$</p><p><strong>CDF (Cumulative Distribution Function)</strong> : if $X$ has PDF $f$, then the CDF is $F(X)=P(X\le{x})=\int_{-\infty}^{x}f(t)dt$</p><p><strong>Expectation</strong>: $E(X)=\int_{-\infty}^{\infty}xf(x)dx$</p><p><strong>Variance</strong>: $Var(X)=E(X-E(X))^2$</p><blockquote><p>$Var(X)=E(X^2-2X{E(X)}+E(X)^2)$</p><p>in above formular, because $2E(X)$ is a constant, so it can be outside, same thing with $E(X)^2$</p><p>$Var(X)=E(X^2)-2E(X)E(x)+E(X)^2=E(X^2)-E(X)^2$</p></blockquote><p><strong>Standard deviation</strong>: $SD(X)=\sqrt{Var(X)}$</p><h1 id="Expectation-and-Variance"><a href="#Expectation-and-Variance" class="headerlink" title="Expectation and Variance"></a>Expectation and Variance</h1><h2 id="Expectation"><a href="#Expectation" class="headerlink" title="Expectation"></a>Expectation</h2><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><ol><li>$E(X_1+X_2+…+X_n)=E(X_1)+E(X_2)+…+E(X_n)$</li><li>$E(X_1X_2…X_n)=E(X_1)E(X_2)…E(X_n)$  if $X_i$ is independent to each other.</li><li>$E(cX)=cE(X)$ if c is a constant.</li><li>$E(c)=c$  the expectation of constant is the constant itself.</li></ol><h1 id="Additive-Chernoff-Bound"><a href="#Additive-Chernoff-Bound" class="headerlink" title="Additive Chernoff Bound"></a>Additive Chernoff Bound</h1><p><img src="/2018/05/30/Statistic-110/Screen Shot 2018-06-05 at 8.35.00 PM.png" alt="Screen Shot 2018-06-05 at 8.35.00 PM"></p><blockquote><p>上式即</p><script type="math/tex; mode=display">P(|S\ge{\mu}|\ge\epsilon)\le2e^{-2m\epsilon^2}</script><p><img src="/2018/05/30/Statistic-110/929166-20161116214202513-1545949382.png" alt="929166-20161116214202513-1545949382"></p><p>Lemma说明我们用随机变量的均值$\hat{\phi}$取估计参数$\phi$, 估计的参数和实际参数的差超过一个特定数值的概率有一确定的上界，并且随着样本量m的增大，$\hat{\phi}$越接近$\phi$.</p></blockquote><h1 id="Johnson-Lindenstrauss-Lemma"><a href="#Johnson-Lindenstrauss-Lemma" class="headerlink" title="Johnson-Lindenstrauss Lemma"></a><a href="https://en.wikipedia.org/wiki/Johnson%E2%80%93Lindenstrauss_lemma" target="_blank" rel="noopener">Johnson-Lindenstrauss Lemma</a></h1><blockquote><p>The lemma states that a small set of points in a high-dimensional space can be embedded into a space of much lower dimension in such a way that distances between the points are nearly preserved.</p><p><img src="/2018/05/30/Statistic-110/Screen Shot 2018-06-06 at 11.01.27 PM.png" alt="Screen Shot 2018-06-06 at 11.01.27 PM"></p><p>Remarks:</p><ol><li>the new dimention $n$ is decided by data sample number $m$ and error bound $\epsilon$; less error (small $\epsilon$) and more sample points require more dimensions, meaning the new dimension $n$ should not be too small; </li><li>Johnson–Lindenstrauss 引理表明任何高维数据集均可以被随机投影到一个较低维度的欧氏空间,同时可以控制pairwise距离的失真.</li></ol></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Probability and Statistic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - Random Response</title>
      <link href="/2018/05/28/DP-Application-Random-Response/"/>
      <url>/2018/05/28/DP-Application-Random-Response/</url>
      <content type="html"><![CDATA[<p><a href="https://link.springer.com/content/pdf/10.1007%2F978-3-319-45871-7_17.pdf" target="_blank" rel="noopener">[2016-Atsushi]</a> gives a comprehensive survey about random response. Randomized response tends to be used in data collection scenario.Randomized response is purely a client-based privacy solution. It does not rely upon a trusted third-party server and puts control over data back to clients. The basic idea is answer truthfully with probability $p$, and answer randomly by picking a answer from the rest choices with probability $1-p$. And the rest choices include the true answer.</p><h3 id="Random-Response-and-its-Variant"><a href="#Random-Response-and-its-Variant" class="headerlink" title="Random Response and its  Variant"></a>Random Response and its  Variant</h3><h4 id="Definition-2016-Wang"><a href="#Definition-2016-Wang" class="headerlink" title="Definition[2016-Wang]"></a>Definition<a href="http://ceur-ws.org/Vol-1558/paper35.pdf" target="_blank" rel="noopener">[2016-Wang]</a></h4><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 10.18.29 PM.png" alt="Screen Shot 2018-05-29 at 10.18.29 PM"></p><h4 id="Warner-Version"><a href="#Warner-Version" class="headerlink" title="Warner Version"></a>Warner Version</h4><p>Random response was first proposed by [1965-Warner]. The aim is to estimate the proportion $\pi(A)$ of people who have some attribute A.</p><p>Each user has  reports her true answer $t\in \{1,-1\}​$ with probability p, and a random answer with probability 1 − p. The latter has the same probability to be −1 and +1;</p><h5 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h5><ol><li>There are red cards and non-red cards in a box, where the ratio of red cards among all the cards is $q$ with $0 &lt; q &lt; 1$ and $q \ne \frac{1}{2}$. And user draws a card.</li><li>If red, answer truthfully to the question “I am a member of A”</li><li>Otherwise, answer truthfully to the question “I am a member of A”</li></ol><h5 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h5><p>Let $\hat{T}$ be the proportion to which the respondents reply “True.” It is easy to see that the expectation of $\hat{T}$  is:</p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 12.40.16 AM.png" alt="Screen Shot 2018-05-29 at 12.40.16 AM"></p><h5 id="Privacy-Analysis"><a href="#Privacy-Analysis" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p>According to the definition of Differential Privacy, the following ratio should be bounded,</p><script type="math/tex; mode=display">P(A|A)\le{e^\epsilon{P(A|not \ A)}}\\P(A|not \ A)\le{e^\epsilon{P(A|A)}}</script><p>$P(A|A)=q​$</p><p>$P(A| not \ A)=(1-q)$</p><p>So combining the above two, we have:</p><p>The randomized response satisfied $\epsilon$-Differential Privacy, where</p><script type="math/tex; mode=display">\epsilon=max\{ln\frac{1-q}{q},ln\frac{q}{1-q}  \}</script><p><img src="/2018/05/28/DP-Application-Random-Response/myplot.jpeg" alt="myplot"></p><h4 id="Kuk-Version"><a href="#Kuk-Version" class="headerlink" title="Kuk Version"></a>Kuk Version</h4><p>Kuk’s proposed another kind of randomized response mechanism to estimate the proportion $\pi_A$, the same as Warner’s mechanism. </p><h5 id="Framework-1"><a href="#Framework-1" class="headerlink" title="Framework"></a>Framework</h5><ol><li>There are two boxes, $BOX_1$ and $BOX_2$. There are red and non-red cards in each box and the ratio of red cards in each box is $q_1,q_2$ respectively, where $0&lt;q_1,q_2&lt;1, q_1\ne{q_2}$. User takes one card from each box.</li><li>If this user is a member of A, then replies “red card” or “non-red card” in accordance<br>with the card taken from $BOX_1$</li><li>Otherwise, he does the same as above except that he takes a card from $BOX_2$.</li></ol><h5 id="Privacy-Analysis-1"><a href="#Privacy-Analysis-1" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.08.31 AM.png" alt="Screen Shot 2018-05-29 at 1.08.31 AM"></p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.08.51 AM.png" alt="Screen Shot 2018-05-29 at 1.08.51 AM"></p><h4 id="Negative-Survey-Mechanism"><a href="#Negative-Survey-Mechanism" class="headerlink" title="Negative Survey Mechanism"></a>Negative Survey Mechanism</h4><h5 id="Framework-2"><a href="#Framework-2" class="headerlink" title="Framework"></a>Framework</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.10.11 AM.png" alt="Screen Shot 2018-05-29 at 1.10.11 AM"></p><h5 id="Privacy-Analysis-2"><a href="#Privacy-Analysis-2" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.11.13 AM.png" alt="Screen Shot 2018-05-29 at 1.11.13 AM"></p><h4 id="t-times-Negative-Survey"><a href="#t-times-Negative-Survey" class="headerlink" title="t-times Negative Survey"></a>t-times Negative Survey</h4><h5 id="Privacy-Analysis-3"><a href="#Privacy-Analysis-3" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.12.13 AM-7574379.png" alt="Screen Shot 2018-05-29 at 1.12.13 AM-7574379"></p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.12.36 AM.png" alt="Screen Shot 2018-05-29 at 1.12.36 AM"></p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><h4 id="2011-Quercia"><a href="#2011-Quercia" class="headerlink" title="[2011-Quercia] "></a><a href="https://pdfs.semanticscholar.org/7e74/15857ddcc798affff74d7e615b0d29f6bf74.pdf" target="_blank" rel="noopener">[2011-Quercia] </a></h4><blockquote><h5 id="Framework-3"><a href="#Framework-3" class="headerlink" title="Framework"></a>Framework</h5><p>[2011-Quercia] uses random response to obfuscate locations.</p><p>Let $k$ be the number of locations on a map. Then, the main part of SpotMe works as follows:</p><ol><li>the mobile phone chooses the location k uniformly at random with probability $p$</li><li>it chooses the true location with probability $1-p$</li></ol><h5 id="Privacy-Analysis-4"><a href="#Privacy-Analysis-4" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p>According to the definition of Differential Privacy, the following ratio should be bounded,</p><script type="math/tex; mode=display">P(L_{noise}|L_{true})\le{e^{\epsilon}P(L_{true}|L^{'}_{true})}</script><p>where $L_{true}$ is user’s actual location and $L^{‘}_{true}$ is the user’s location after making some changes while $L_{noise}$ is user’s obfuscated location.</p><p>$P(L_{true}|L_{true})=(1-p)+p*\frac{1}{k}$</p><p>$P(L_{true}|L^{‘}_{true})=p*\frac{1}{k}$</p><p>so after combining above two formulations, we have privacy bugdet:</p><script type="math/tex; mode=display">\epsilon=ln\frac{k-(k-1)p}{p}</script></blockquote><h4 id="2016-Wang"><a href="#2016-Wang" class="headerlink" title="[2016-Wang]"></a><a href="http://ceur-ws.org/Vol-1558/paper35.pdf" target="_blank" rel="noopener">[2016-Wang]</a></h4><blockquote><p>Randomized Response vs. Laplace Mechanism</p><p><u><strong>Randomized Response</strong></u> </p><p>Without loss of generality, we assume the randomized response still favors the true value, i.e., $p_{00}, p_{11} &gt; 0.5$. Intuitively, under the same privacy standard, the mechanism with larger diagonal elements in the corresponding design matrix tends to achieve better utility.</p><ul><li><img src="/2018/05/28/DP-Application-Random-Response/Screen%20Shot%202018-06-01%20at%205.09.06%20PM.png" alt="Screen Shot 2018-06-01 at 5.09.06 PM"></li><li>What is the proportion of $X=1$? It aims to o learn the population distribution based on the collected randomized dataset. We use $\pi_1$to denote the true proportion of value 1 to be estimated in the original population. The observed proportion of value 1 in the collected dataset is denoted as $\lambda_1$. We denote the unbiased estimator for $\pi_1$ respectively as $\hat{\pi}_1$. </li><li><p><img src="/2018/05/28/DP-Application-Random-Response/Screen%20Shot%202018-06-01%20at%205.13.14%20PM.png" alt="Screen Shot 2018-06-01 at 5.13.14 PM"></p><p><strong><u>Laplace Mechanism</u></strong></p></li><li><p><img src="/2018/05/28/DP-Application-Random-Response/Screen%20Shot%202018-06-01%20at%205.22.11%20PM.png" alt="Screen Shot 2018-06-01 at 5.22.11 PM"></p></li><li><img src="/2018/05/28/DP-Application-Random-Response/Users/daniel/Downloads/Nutstore/Git-PersonalWeb/QingWebsite/website/source/_posts/DP-Application-Random-Response/Screen%20Shot%202018-06-01%20at%205.23.19%20PM-7891843.png" alt="Screen Shot 2018-06-01 at 5.23.19 PM-7891843"></li><li><img src="/2018/05/28/DP-Application-Random-Response/Screen%20Shot%202018-06-01%20at%205.24.26%20PM.png" alt="Screen Shot 2018-06-01 at 5.24.26 PM"></li><li></li></ul></blockquote><h4 id="2006-Huseyin"><a href="#2006-Huseyin" class="headerlink" title="[2006-Huseyin]"></a><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.78.3576&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">[2006-Huseyin]</a></h4><p><strong>One-Group Scheme</strong>s  vs <strong>Multi-Group Schemes</strong>. </p><blockquote><p>in my understanding, one-group means there arw n users and m items. for a user, all the items rating are in a group. For example, user_i’s true rateing for all items is (0101),with probability theta to upload (0101) and (1-theta) probability to upload (1010).</p><p>And in m-group, for example m=2, then user_i’s rating is (01)and(11). with probability theta1 to upload (01) and (1-theta1) to upload (10); theta2 to upload(11) and (1-theta2) to upload (00)</p><p>Although we achieve decent accuracy in this scheme, the privacy level is very low. We improve privacy level by introducing multi-group schemes, while with increasing M, accuracy decreases because we add more randomness. The accuracy is from how much info is preserved after randomness. The more info, the more accurate. P(true=x|randon resp = x) means preserved info. m-group info preserved: $P^m$</p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-06-02 at 4.16.46 PM.png" alt="Screen Shot 2018-06-02 at 4.16.46 PM"></p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-06-02 at 4.16.55 PM.png" alt="Screen Shot 2018-06-02 at 4.16.55 PM"></p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-06-02 at 4.17.21 PM.png" alt="Screen Shot 2018-06-02 at 4.17.21 PM"></p></blockquote><p><strong>Private Mechanism With Full Privacy</strong></p><blockquote><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-06-02 at 4.20.01 PM.png" alt="Screen Shot 2018-06-02 at 4.20.01 PM"></p></blockquote><h4 id="2014-Sun"><a href="#2014-Sun" class="headerlink" title="[2014-Sun]"></a><a href="https://pdfs.semanticscholar.org/ff20/5884c8e34f8a1d6616809ca532e6ed801393.pdf?_ga=2.49109027.44169730.1528666244-1946321552.1526143877" target="_blank" rel="noopener">[2014-Sun]</a></h4><blockquote><p>The problem setting is how to find frequent itemset with privacy. Say we have the item set $I={I_1,I_2,..,I_n}$. Before each user sends out their transaction which is $n$-dimention vector and ithe entry being 1 means this user has this item or else, he does the the randomized selection for each item. That is, keep true answer with probability $p_i$ for item i and  perturb the answer with $1-p$. And p controls the privacy level.</p><p>For k-itemset, we want to find out its support, which comes from the estimator based on the perturbed data. Say we want to calculate the support of $2$-itemset. And the item set is $\{A,B,C,D\}$. And the candidate domain is $\{AB,AC,AD,BC,BD,CD\}$. The aim is to get the true count of $AB, \ c(AB)$, which is $11$ and may comes from $\{00,01,10,11\}$, with the probability matrix $P=\matrix{p_{00},p_{01}\\p_{10},p_{11}}$. so based on the observed count of $[A=0,B=0],[A=0,B=1],[A=1,B=0],[A=1,B=1]$ we can get estimator count matrix by $C_{observed}=PC_{estimator}\to C_{estimator}=P^{-1}C_{observed}$. And the support for $AB$ is $C_{estimator}[-1]$.</p></blockquote><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[2011-Quercia] SpotME if you can: randomized responses for location obfuscation on mobile phones</p><p>[1965-Warner] Randomized response: a survey technique for eliminating evasive answer bias</p><p>[2016-Wang] Using Randomized Response for Differential Privacy Preserving Data Collection </p><p>[2006-Huseyin] Achieving Private Recommendations Using Randomized Response Techniques</p><p>[2014-Sun] Personalized Privacy-Preserving Frequent Itemset Mining Using Randomized Response</p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - Location Protection</title>
      <link href="/2018/05/27/DP-Application-Location-Protection/"/>
      <url>/2018/05/27/DP-Application-Location-Protection/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Setting"><a href="#Problem-Setting" class="headerlink" title="Problem Setting"></a>Problem Setting</h2><p>The goal of location with DP is that the chance of users being mapped to one specific obfuscated location from any of the actual locations is similar. The more similar the probability for each region is, the harder it is to infer users’ original positions, leading to better privacy protection.</p><h3 id="2013-Andres"><a href="#2013-Andres" class="headerlink" title="[2013-Andres]"></a><a href="http://www.lix.polytechnique.fr/~catuscia/papers/Geolocation/geo.pdf" target="_blank" rel="noopener">[2013-Andres]</a></h3><p>It performs as a probabilistic geo-obfuscation process, i.e., a user first obfuscates his<br>real location to another one according to a pre-configured<br>probability function P (encoding the probability of mapping<br>arbitrary location l to l∗) and then uploads the obfuscated<br>location to the server. The probability function is the key to<br>ensure differential privacy. The basic idea is that, suppose<br>the obfuscated location is l∗, for any two locations l1, l2,<br>their probability of being mapped to l∗ are similar. Then,<br>if an adversary observes a user u in l∗, he/she cannot distinguish whether u is actually in l1 or l2, even if he/she knows<br>the obfuscation function P . With this intuition, differential<br>privacy formally defines such similarity between any two<br>locations l1, l2 for arbitrary l∗.</p><p>The distance d(l1; l2) is introduced in the formulation to<br>reflect the intuition that if l1 and l2 are close to each other<br>(i.e., small d(l1; l2)), they should be more indistinguishable.Note that the set of locations L can be constructed by dividing the concerned area into a set of regions (of arbitrary<br>size) and selecting the representative locations of the regions<br>(e.g., geographic center)</p><h3 id="2014-Nicolas"><a href="#2014-Nicolas" class="headerlink" title="[2014-Nicolas]"></a><a href="https://arxiv.org/pdf/1402.5029.pdf" target="_blank" rel="noopener">[2014-Nicolas]</a></h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2013-Andres] Geo-indistinguishability: Differential privacy for location-based systems</p><p>[2014-Nicolas] Optimal geo-indistinguishable mechanisms for location privacy</p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - Private Spatial Decompositions</title>
      <link href="/2018/05/26/DP-Application-Private-Spatial-Decompositions/"/>
      <url>/2018/05/26/DP-Application-Private-Spatial-Decompositions/</url>
      <content type="html"><![CDATA[<p><a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a> details the methods of Private Spatial Decompositions.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2014-To] A Framework for Protecting Worker Location Privacy in Spatial Crowdsourcing</p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - CrowdSourcing</title>
      <link href="/2018/05/26/DP%20Application-CrowdSourcing/"/>
      <url>/2018/05/26/DP%20Application-CrowdSourcing/</url>
      <content type="html"><![CDATA[<p><a href="https://sigmodrecord.org/publications/sigmodRecord/1512/pdfs/05_surveys_Pournajaf.pdf" target="_blank" rel="noopener">[2015-Layla]</a> is a survey on the MobileCrowdScoucing privacy.</p><p>Four factors in CrowdSourcing:</p><blockquote><ol><li>sensing data quality, which tries to maximize the data quality measured by a certain metric (mostly used in environmental monitoring tasks)</li><li>incentive cost, which aims at minimizing the total budget (from the task organizer perspective)<br>for an MCS task with different incentive mechanisms, such as pay per participant or pay per task</li><li>energy consumption, whose objective is to identify an optimal collaborative data sensing and uploading scheme with energy-saving techniques such as piggybacking</li><li>travel distance, where the travel distance of a user for accomplishing a task is considered in task allocation, in order to minimize the overall travel distance for all the tasks.</li></ol></blockquote><h2 id="Task-Assignments-in-CrowdSourcing"><a href="#Task-Assignments-in-CrowdSourcing" class="headerlink" title="Task Assignments in CrowdSourcing"></a>Task Assignments in CrowdSourcing</h2><p>In croudsourcing, workers with mobile devices to collect data and send it to task requester for rewards.</p><p>In task assignment, organizers need participants’ precise locations for optimal task allocation. However, the exposure of their locations raises privacy concerns. Especially for those who are not eventually selected for any task, their location privacy is sacrificed in vain.</p><p>So in the differential privacy task assignment croudsourcing, the goal is to design a data release method that accurately represents the distribution of the workers and helps the Server efficiently match workers with tasks without compromising the privacy of their locations.</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="2014-To"><a href="#2014-To" class="headerlink" title="[2014-To]"></a><a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a></h3><p>it is the first one to solve this problem.</p><blockquote><ol><li><p>Framework</p><ul><li>Workers send their locations to a trusted cellular service provider(CSP) </li><li>CSP collects updates and releases a PSD according to privacy budget </li><li>When the SC-server receives a task t, it queries the PSD to determine a geocast region (GR), which is a unique feature of this work. Next, the SC-server initiates a geocast communication process to disseminate t to all workers within GR. Upon receiving request t, a worker w decides whether to perform the task or not.</li><li>Task assignment. <ul><li>Once server get a task request, server needs to query PSD to find a geocast region, balancing between high task assignment success rate and system overload like worker traveling distance and the number of  noticed worker. The author calculate maximum travel distance, models acceptance rate as the function of distance.</li><li>Geocast region construction. </li><li>Optimization. Including Partial Cell Selection and Communication Cost.</li></ul></li></ul></li><li><p>Privacy Model</p><ul><li><p>Privacy leakage: (1) workers disclose information to the task requester once they consent to the task; (2) completion of a task discloses the fact that some worker must have been at that location; (3) but this paper focuses on what happens prior to consent, when worker location and identity must be protected from both task requesters and the SC server.</p></li><li><p>the specific objective is to protect both the location and the identity of workers during task assignment. </p></li><li><p>Private Spatial Decom</p><ul><li><p>AG uses a two-level grid and variable cell granularity.</p></li><li><p>For the first-level, domain is divided into $m_1\times{m1}$ cells. This heuristic method is data-independent, and thus does not consume any privacy budget. For each level-1 cell, it is divided into $m_2\times{m2}$ subcells. </p><script type="math/tex; mode=display">m1 = max(10,\lceil{\frac{1}{4}\sqrt{\frac{N\times{\epsilon}}{k_1=10}}}\rceil)\\m_2=\lceil{\sqrt{\frac{N'\times{\epsilon_2}}{k_2=5}}}\rceil</script></li><li><p>$k_2$ selection. $k_2$ controls the granularity of level-2 domain and small one leads to compactness in level-2 subcells. </p></li><li><p>improving $m_2$</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.27.05 PM.png" alt="Screen Shot 2018-05-30 at 12.27.05 PM"></p></li></ul></li></ul></li></ol></blockquote><h3 id="2018-Yang"><a href="#2018-Yang" class="headerlink" title="[2018-Yang]"></a><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8319407" target="_blank" rel="noopener">[2018-Yang]</a></h3><p>it criticizes that <a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a> is based on the assumption that workers are uniformly distributed within the domain and and the workers in each cell have the same acceptance rate. So they proposes a workers density-based method.</p><blockquote><ol><li>Framework<ul><li>Workers must submit their location to the CSP, travel to the location designated for the task and collect data using their sensor-equipped device.</li><li>The CSP collects locations from workers and releases data in sanitized form to the Server for task assignment. There is a trust relationship between CSP and workers.</li><li>The Server queries the CSP for a sanitized dataset once it receives a task, where server chooses a geocast region GR to disseminate the task to the workers in GR. It then assigns the task to suitable workers, through the CSP, according to a task assignment algorithm.</li></ul></li><li>Modules<ul><li>Using quadtree to partition the region based on worker density.  But the authors change this method so that the partitioning is based on the worker density instead of choosing the middle point.</li><li>Partitioning point selection. Before partitioning, <code>m</code> initial points are randomly generated within the cell, ==============================(TODO)</li><li>Differential privacy data release. A noisy count of the number of workers in each cell is released to protect the privacy of worker locations, where whether or not a worker<br>within a specific cell cannot be identified.</li><li>Task assignment. Firstly, teh geocast region is selected based on task assignment success rate and system overhead (the distance workers need to travel and the number of workers notified of the task).</li></ul></li><li>Privacy Model<ul><li>The basic idea of private data release is that the domain of worker locations is partitioned into small cells and Laplace noise is added to the count of workers in each cell to achieve a differential privacy guarantee.</li><li>Pervious literature assumes the worker locations are distributed uniformly, and the workers in each cell have the same acceptance rate, which is not the case in real-world scenarios. Partitioning the data domain into a uniform grid would result in sizeable errors. Therefore, we propose a recursive partitioning process based on worker density. </li><li>The aim is to identify dense regions and sparse regions and make the distribution of the workers in each smaller region as near to uniform as possible.</li><li>Adopting data-independent quadtree into workers density-based data-independent technique. <ul><li>Partitioning stop condition. Traditional quadtrees require the data publisher to specify the height of the partitioning. In this paper, the process stops if (1) no workers exist in the cell; (2) the area of cell is less than some threshold, The smaller the cell, the more uniform the distribution of workers within it; (3) the distribution of workers in a cell is relatively uniform， which is measures by the threshold of maximum density difference.</li><li>First, $m$ initial partition points in the location domain need to be selected, where $m=\frac{\sqrt{area \ of \ cell}}{\alpha}$</li><li>check condition (1) and (2), which is the number of points in cell is greater than 0 and the area of cell is greater than the threshold. If one of answers is no, stop partitioning.</li><li>for each partitioning point, calculate the density of the subcells divided by this point. choose the point which has the maximum density difference bbetween subcells.</li><li>If the biggest density difference is greater than the threshold β, the cell is partitioned at point. Otherwise, the cell will not be partitioned as the distribution of worker in the cell is already close to uniform. For example, the density of four subcells is 1, 2, 1, 2, which means in each subcells, there are 1, 2, 1 and 2 points in each subcell, which is kind of uniform distribution in the cell.</li></ul></li></ul></li></ol></blockquote><h3 id="2017-Wang"><a href="#2017-Wang" class="headerlink" title="[2017-Wang]"></a><a href="http://papers.www2017.com.au.s3-website-ap-southeast-2.amazonaws.com/proceedings/p627.pdf" target="_blank" rel="noopener">[2017-Wang]</a></h3><blockquote><ol><li><p>Framework</p><ul><li>Platform-side Geo-Obfuscation Function Generation</li><li>User-side Location Obfuscation</li><li>Platform-side Obfuscation-aware Task Allocation</li></ul></li><li><p>Privacy Model</p><p>Overall, the aurhor models workers’ travel distance to task locations as the function of geo-obfuscation function and task allocation. And by calculating the optimal function, we can get the Geo-Obfuscation matrix which satisfies DP and task allocation schemes.</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 10.06.41 AM.png" alt="Screen Shot 2018-05-30 at 10.06.41 AM"></p><ul><li><p>the expected travel distance of assigning a task at $l_t$ to a user at (obfuscated) $l*$ given the geo-obfuscation function $P$.</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 10.18.25 AM.png" alt="Screen Shot 2018-05-30 at 10.18.25 AM"></p></li><li><p>optimal function</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 10.55.21 AM.png" alt="Screen Shot 2018-05-30 at 10.55.21 AM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 11.05.55 AM.png" alt="Screen Shot 2018-05-30 at 11.05.55 AM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 10.56.24 AM.png" alt="Screen Shot 2018-05-30 at 10.56.24 AM"></p></li><li><p>task allocation</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 11.07.06 AM.png" alt="Screen Shot 2018-05-30 at 11.07.06 AM"></p></li><li><p>Candidate Geo-Distribution Estimation</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 11.10.54 AM.png" alt="Screen Shot 2018-05-30 at 11.10.54 AM"></p></li><li><p>Laplace</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 11.27.15 AM.png" alt="Screen Shot 2018-05-30 at 11.27.15 AM"></p></li><li><p>Geo-distribution Estimation</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 11.50.49 AM.png" alt="Screen Shot 2018-05-30 at 11.50.49 AM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 11.50.57 AM.png" alt="Screen Shot 2018-05-30 at 11.50.57 AM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 11.51.05 AM.png" alt="Screen Shot 2018-05-30 at 11.51.05 AM"></p></li></ul></li></ol></blockquote><h3 id="2015-Gong"><a href="#2015-Gong" class="headerlink" title="[2015-Gong]"></a><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7296638" target="_blank" rel="noopener">[2015-Gong]</a></h3><h3 id="2016-Jin"><a href="#2016-Jin" class="headerlink" title="[2016-Jin]"></a><a href="http://webhost.engr.illinois.edu/~hjin8/publications/mobihoc16.pdf" target="_blank" rel="noopener">[2016-Jin]</a></h3><p>This paper considers how to effectively incentivize worker participation. And proposes a system framework that integrates an incentive, a weighted  data aggregation, and a data perturbation mechanism which protects the sensing data.</p><blockquote><ol><li><p>Framework</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-06-01 at 11.00.21 AM.png" alt="Screen Shot 2018-06-01 at 11.00.21 AM"></p><ul><li><p>Aggregation Mechanism</p><p>To guarantee that the perturbed results have satisfactory accuracy, the original aggregated results before perturbation need to be accurate enough in the first place. Therefore, we reasonably assume that the platform uses a weighted aggregation method to calculate the aggregated result $x_j$ for each task $\tau_j$ based on workers’ data.</p><p>The motivation for utilizing weighted aggregation is to capture the effect of workers’ diverse skill levels on the calculation of the aggregated results.</p></li><li><p>Incentive Mechanism</p><p>aim to design a pSRC auction that minimizes the platform’s total payment with satisfactory data aggregation</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-06-01 at 11.51.45 AM.png" alt="Screen Shot 2018-06-01 at 11.51.45 AM"></p><p>where $y_i$ means worker is seleted for a task, $\alpha_j$ is the error threshold for task j, $\theta_{i,j}$ is error of  worker i for task j.</p></li></ul></li><li><p>Privacy model</p><ul><li><p>workers locally sense a specific object or phenomenon and server aggregrate the uploaded data and publish a noise aggregated results to protect worker’s privacy.</p></li><li><p>the noise scale is deviated from the $(\alpha,\beta)-accuracy$.</p></li><li><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-06-01 at 12.09.47 PM-7873006.png" alt="Screen Shot 2018-06-01 at 12.09.47 PM-7873006"></p></li><li><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-06-01 at 12.25.25 PM.png" alt="Screen Shot 2018-06-01 at 12.25.25 PM"></p></li><li><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-06-01 at 12.19.28 PM.png" alt="Screen Shot 2018-06-01 at 12.19.28 PM"></p><p><strong>Remarks</strong>:</p><p>$Pr(|N_j|\ge\alpha_j)=Pr(N_j\ge\alpha_j)+Pr(-N_j\le-\alpha_j)$</p><p>according to the symmetry of PDF, $Pr(N_j\ge\alpha_j)=Pr(-N_j\le-\alpha_j)$</p><p>so $Pr(|N_j|\ge\alpha_j)=2Pr(N_j\ge\alpha_j)$</p></li><li></li></ul></li></ol></blockquote><h2 id="Data-Sensing-in-CrowdSourcing"><a href="#Data-Sensing-in-CrowdSourcing" class="headerlink" title="Data Sensing in CrowdSourcing"></a>Data Sensing in CrowdSourcing</h2><h3 id="Solutions-1"><a href="#Solutions-1" class="headerlink" title="Solutions"></a>Solutions</h3><h3 id="2016-Wang"><a href="#2016-Wang" class="headerlink" title="[2016-Wang]"></a><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7837982" target="_blank" rel="noopener">[2016-Wang]</a></h3><p>In this paper, instead of studying task assignment, the author focuses on sparse croudsensing. Due to large target sensing area and limited budget which result in insufficient spatial coverage of mobile users, sparse mobile croudsensing impute information of the uncovered regions by combining historical records with available sensing data from nearby regions.</p><blockquote><ol><li>Framework<ul><li>The server side generates probabilistic obfuscation matrix and data adjustment function in an offline way.</li><li>user sider senses its actual location and then maps the associated region to another region according to probabilistic obfuscation matrix. After that, the data adjustment function alters the original sensing data to fit the properties of the obfuscated region. Finally, mobile client then uploads the modified region and data to the server.</li><li>The server side does data inference : modeled as a matrix completion problem, where each element in the matrix is the value like temperature of a region at time t. In this paper, they use compressive sensing theory for inference.</li></ul></li><li><p>Privacy Model</p><ul><li><p>Privacy leakage : In Sparse MCS, participants report the sensing data with time stamps and geographical coordinates, which may introduce serious privacy risks. </p></li><li><p>Data utility: Due to location obfuscation, the uploaded region data is not actual value of this region, so adjustment is needed to decrease data utility loss. the data quality loss is determined by the difference of sensing data between the actual and the obfuscated locations, instead of the geographic distance. In other words, a participant’s location may be mapped to a place far away, as long as the sensing values of the two locations are close enough.</p></li><li><p>Adversary model - Bayesian attack</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 12.10.00 PM.png" alt="Screen Shot 2018-05-30 at 12.10.00 PM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 12.10.48 PM.png" alt="Screen Shot 2018-05-30 at 12.10.48 PM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 12.11.49 PM.png" alt="Screen Shot 2018-05-30 at 12.11.49 PM"></p></li><li><p>optimal function</p><p>The authors model the sensing data quality loss as the function of location obfuscation matrix.</p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 12.20.20 PM.png" alt="Screen Shot 2018-05-30 at 12.20.20 PM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 12.22.12 PM.png" alt="Screen Shot 2018-05-30 at 12.22.12 PM"></p><p><img src="/2018/05/26/DP Application-CrowdSourcing/Screen Shot 2018-05-30 at 12.22.56 PM.png" alt="Screen Shot 2018-05-30 at 12.22.56 PM"></p></li></ul></li></ol></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2014-To] A Framework for Protecting Worker Location Privacy in Spatial Crowdsourcing</p><p>[2018-Yang] Density-Based Location Preservation for Mobile Crowdsensing With Differential Privacy</p><p>[2016-Wang] Differential Location Privacy for Sparse Mobile Crowdsensing</p><p>[2015-Layla] Participant privacy in mobile crowd sensing task management: A survey of methods and challenges</p><p>[2015-Gong] Protecting Location Privacy for Task Allocation in Ad Hoc Mobile Cloud Computing</p><p>[2016-Jin] INCEPTION: Incentivizing Privacy-Preserving Data Aggregation for Mobile Crowd Sensing Systems</p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2018/05/26/Dynamic-Programming/"/>
      <url>/2018/05/26/Dynamic-Programming/</url>
      <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>这篇文章详细记录<a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a>上各种难度的动态规划题目。每道题我都给出题目，思路以及Python代码。</p><a id="more"></a><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p><p>首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？ 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p><p>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p><p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p><p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p><p><strong>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</strong></p><h3 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746.Min Cost Climbing Stairs"></a>746.Min Cost Climbing Stairs</h3><blockquote><ul><li><p>题目</p><p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p><p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>]</div><div class="line">&gt;   Output: <span class="number">6</span></div><div class="line">&gt;   Explanation: Cheapest <span class="keyword">is</span> start on cost[<span class="number">0</span>], <span class="keyword">and</span> only step on <span class="number">1</span>s, skipping cost[<span class="number">3</span>].</div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: cost = [<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</div><div class="line">&gt;   Output: <span class="number">15</span></div><div class="line">&gt;   Explanation: Cheapest <span class="keyword">is</span> start on cost[<span class="number">1</span>], pay that cost <span class="keyword">and</span> go to the top.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>典型动态规划，且只需要一维dp数组维护，考虑到可以从index=0|1开始，所以在dp数组前面插入两个0(因为是加法，乘法则插入1)，同时要表示终点，则在dp尾再插入一个0，统计到达top时的cost。</p></li><li><p>代码</p><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold"><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type cost: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           lcost = len(cost)</div><div class="line">&gt;           cost.append(<span class="number">0</span>)</div><div class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(lcost+<span class="number">3</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(dp)):</div><div class="line">&gt;               dp[i] = min(dp[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]) + cost[i<span class="number">-2</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote></div></div></li></ul></blockquote><h3 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h3><blockquote><ul><li><p>题意</p><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="number">2</span></div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: There are two ways to climb to the top.</div><div class="line">&gt;   <span class="number">1.</span> <span class="number">1</span> step + <span class="number">1</span> step</div><div class="line">&gt;   <span class="number">2.</span> <span class="number">2</span> steps</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: There are three ways to climb to the top.</div><div class="line">&gt;   <span class="number">1.</span> <span class="number">1</span> step + <span class="number">1</span> step + <span class="number">1</span> step</div><div class="line">&gt;   <span class="number">2.</span> <span class="number">1</span> step + <span class="number">2</span> steps</div><div class="line">&gt;   <span class="number">3.</span> <span class="number">2</span> steps + <span class="number">1</span> step</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>跟上面一题很相似了，同样是一维，也需要在首个插入</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           l = n+<span class="number">1</span></div><div class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l):</div><div class="line">&gt;               dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h3><blockquote><ul><li><p>题意</p><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</div><div class="line">&gt;   Output: <span class="number">6</span></div><div class="line">&gt;   Explanation: [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6.</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>一维dp数组，同样在前面插入0，但是返回的时候，要小心不能返回max(dp)，而是max(dp[1:])，防止input是[-1,-2].</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l+<span class="number">1</span>):</div><div class="line">&gt;               dp[i] = max(nums[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>])</div><div class="line">&gt;           <span class="keyword">return</span> max(dp[<span class="number">1</span>:])</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h3><blockquote><ul><li><p>题目</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</div><div class="line">&gt;                Total amount you can rob = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">2</span>), rob house <span class="number">4</span> (money = <span class="number">2</span>) Total amount you can rob = <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>dp状态思考错误，dp[i]表示抢到第i个房子时，目前获取的最大利润</p><p>dp状态转移方程，有点错误。错误以为不能抢劫相邻的房子意味着抢的房子之间必须相隔一个房子，其实可以中间可以相隔多个房子不抢。</p><p>则dp转移方程为：即要不要抢当前的房子</p><p>dp[i] = max( dp[i-1] , dp[i-2] + nums[i] )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l+<span class="number">1</span>):</div><div class="line">&gt;               dp[i] = max(nums[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>], dp[i<span class="number">-1</span>])</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><p>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p><p>正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p><p>让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p><p><strong>d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i]</strong></p><p>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p><h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h3><blockquote><ul><li><p>题目</p><p><script type="math/tex">m \times {n}</script>的矩阵，从（0，0）位置走到（m，n）位置共有多少走法</p></li><li><p>思路</p><p>二维dp，dp[i][j]记录到达位置（i,j）共有的走法，dp[i][j]=dp[i-1][j]+dp[i][j-1].</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type m: int</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">&gt;               dp[<span class="number">0</span>][i] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</div><div class="line">&gt;                   dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h3><blockquote><ul><li><p>题目</p><p>同样是[m,n]矩阵，但是有1表示障碍，不能过，0为空白可以过去。</p></li><li><p>思路</p><p>dp[i][j]仍然是可能的走法数，但是在初始化时，如果当前是障碍，则dp[][]=0.否则依赖于前面一个。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type obstacleGrid: List[List[int]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid : <span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           m = len(obstacleGrid)</div><div class="line">&gt;           n = len(obstacleGrid[<span class="number">0</span>])</div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span> <span class="comment">##update</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m): <span class="comment">##update</span></div><div class="line">&gt;               dp[i][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> dp[i<span class="number">-1</span>][<span class="number">0</span>] <span class="keyword">and</span> <span class="keyword">not</span> obstacleGrid[i][<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):<span class="comment">##update</span></div><div class="line">&gt;               dp[<span class="number">0</span>][i] = <span class="number">1</span> <span class="keyword">if</span> dp[<span class="number">0</span>][i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>][i] <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</div><div class="line">&gt;                   <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</div><div class="line">&gt;                       dp[i][j] = <span class="number">0</span></div><div class="line">&gt;                   <span class="keyword">else</span>:</div><div class="line">&gt;                       dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h3><blockquote><ul><li><p>题目</p><p>从矩阵的左上角走到右下角，矩阵上元素值为代价，求最小代价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Input:</div><div class="line">&gt;   [</div><div class="line">&gt;     [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</div><div class="line">&gt;     [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</div><div class="line">&gt;     [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</div><div class="line">&gt;   ]</div><div class="line">&gt;   Output: <span class="number">7</span></div><div class="line">&gt;   Explanation: Because the path <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> minimizes the sum.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>完全捡苹果题目，需要注意的是创建dp数组时，len_row在外层，len_column在内层。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type grid: List[List[int]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l1 = len(grid)</div><div class="line">&gt;           l2 = len(grid[<span class="number">0</span>])</div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l2)] <span class="keyword">for</span> j <span class="keyword">in</span> range(l1)] <span class="comment">###l2在里面，l1在外面</span></div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2):</div><div class="line">&gt;               dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2):</div><div class="line">&gt;                   temp = dp[i][j<span class="number">-1</span>] <span class="keyword">if</span> dp[i][j<span class="number">-1</span>]&lt;dp[i<span class="number">-1</span>][j] <span class="keyword">else</span> dp[i<span class="number">-1</span>][j]</div><div class="line">&gt;                   dp[i][j] = temp + grid[i][j]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h3><blockquote><ul><li><p>题目</p><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   [</div><div class="line">&gt;        [<span class="number">2</span>],</div><div class="line">&gt;       [<span class="number">3</span>,<span class="number">4</span>],</div><div class="line">&gt;      [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</div><div class="line">&gt;     [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</div><div class="line">&gt;   ]</div><div class="line">&gt;   The minimum path sum from top to bottom is <span class="number">11</span> (i.e., <span class="number">2</span> + <span class="number">3</span> + <span class="number">5</span> + <span class="number">1</span> = <span class="number">11</span>).</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>与捡苹果很相似，有两种想法，首先dp[i][j]表示到达需要的最少步数。那么状态转移方程有两种想法：</p><p>一种是：dp[i][j]出发有两种走法，dp[i+1][j]和dp[i+1][j+1]，更新到达后的状态dp[i+1][j]和dp[i+1][j+1]；</p><p>另一种是dp[i][j]有两种到达的方法，dp[i-1][j]和dp[i-1][j-1]，更新dp[i][j]</p><p>但是觉得第一种方法比较容易，因为第二种要考虑边界</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type triangle: List[List[int]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> triangle:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(triangle)</div><div class="line">&gt;           dp = [[ sys.maxsize <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle[j])) ] <span class="keyword">for</span> j <span class="keyword">in</span> range(l) ]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[i])):</div><div class="line">&gt;                   dp[i+<span class="number">1</span>][j] = dp[i+<span class="number">1</span>][j] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j] &lt; (dp[i][j]+triangle[i+<span class="number">1</span>][j]) <span class="keyword">else</span> (dp[i][j]+triangle[i+<span class="number">1</span>][j])</div><div class="line">&gt;                   dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] &lt; (dp[i][j]+triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]) <span class="keyword">else</span> (dp[i][j]+triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</div><div class="line">&gt;           <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h3><blockquote><ul><li><p>题目</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: You cannot rob house <span class="number">1</span> (money = <span class="number">2</span>) and then rob house <span class="number">3</span> (money = <span class="number">2</span>),</div><div class="line">&gt;                because they are adjacent houses.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</div><div class="line">&gt;                Total amount you can rob = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>房子排成了一个圆圈，则如果抢了第一家，就不能抢最后一家，因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢。则把数组分成两份，分别使用动态规划求解。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">if</span> len(nums)==<span class="number">1</span>:<span class="keyword">return</span> nums[<span class="number">0</span>]</div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           dp2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           dp1[<span class="number">1</span>] = nums[<span class="number">0</span>]</div><div class="line">&gt;           dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l):</div><div class="line">&gt;               dp1[i] = max(dp1[i<span class="number">-1</span>],dp1[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>])</div><div class="line">&gt;               dp2[i] = max(dp2[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>]+nums[i])</div><div class="line">&gt;           <span class="keyword">return</span> max(dp1[<span class="number">-1</span>],dp2[<span class="number">-1</span>])</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h3><blockquote><ul><li><p>题目</p><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: n = <span class="number">12</span></div><div class="line">&gt;   Output: <span class="number">3</span> </div><div class="line">&gt;   Explanation: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: n = <span class="number">13</span></div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li><li><p>思路</p><p>这道题就是找零钱。只是零钱的选取是有限的，而这边完美数是无限的，但是要小于n。故遍历零钱数组的操作，需要变成while循环，遍历每一个完美数。</p><p>dp[i]表示最少需要的数字凑成这个数，直到n。两层循环。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="comment">###LeetCode下Python3是超时，Python2可以</span></div><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [sys.maxsize <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</div><div class="line">&gt;               j = <span class="number">1</span></div><div class="line">&gt;               <span class="keyword">while</span> j*j&lt;=i:</div><div class="line">&gt;                   dp[i] = min(dp[i],dp[i-j*j]+<span class="number">1</span>)</div><div class="line">&gt;                   j = j + <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;           </div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h3><blockquote><ul><li><p>题目</p><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p></li><li><p>思路</p><p>如果动态规划，则时间复杂度是$O(n^2)$, 第一层循环来更新dp，第二个循环来遍历之前的数字且必须比当前小，不能等于。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</div><div class="line">&gt;                   <span class="keyword">if</span> nums[j]&lt;nums[i] <span class="keyword">and</span> dp[i] &lt; dp[j]+<span class="number">1</span>:</div><div class="line">&gt;                       dp[i] = dp[j]+<span class="number">1</span></div><div class="line">&gt;           <span class="keyword">return</span> max(dp)</div><div class="line">&gt;           </div><div class="line">&gt;           </div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="comment">###二分查找的复杂度是O(log(n)),则整体复杂度是O(nlong(n))</span></div><div class="line">&gt;   <span class="keyword">import</span> bisect</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           sorted_list = []</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">&gt;               pos = bisect.bisect_left(sorted_list,i)</div><div class="line">&gt;               <span class="keyword">if</span> pos==len(sorted_list):</div><div class="line">&gt;                   sorted_list.append(i)</div><div class="line">&gt;               <span class="keyword">else</span>:</div><div class="line">&gt;                   sorted_list[pos] = i</div><div class="line">&gt;           <span class="keyword">return</span> len(sorted_list)</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h3><blockquote><ul><li><p>题目</p><p>换硬币，但是可能失败，即没有1元银币，导致凑不够。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></div><div class="line">&gt;   <span class="keyword">return</span> <span class="number">3</span> (<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span>)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   coins = [<span class="number">2</span>], amount = <span class="number">3</span></div><div class="line">&gt;   <span class="keyword">return</span> -<span class="number">1</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>两层遍历，dp[i]表示凑够i元需要的最少银币数量。疑惑点是如何处理凑不够的情况，返回-1.事实上，只要有提供1元银币，一定可以凑够。那就判断dp[1]是否有更新。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type coins: List[int]</span></div><div class="line"><span class="string">&gt;           :type amount: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [sys.maxsize <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</div><div class="line">&gt;           re[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,amount+<span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</div><div class="line">&gt;                   <span class="keyword">if</span> coin &lt;= i:</div><div class="line">&gt;                       <span class="keyword">if</span> dp[i] &gt; dp[i-coin]+<span class="number">1</span>:</div><div class="line">&gt;                           dp[i] = dp[i-coin]+<span class="number">1</span></div><div class="line">&gt;           <span class="keyword">if</span> dp[<span class="number">-1</span>] == sys.maxsize:</div><div class="line">&gt;               <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">&gt;           <span class="keyword">else</span>:</div><div class="line">&gt;               <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h3><blockquote><ul><li><p>题目</p><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   For num = <span class="number">5</span> you should <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>].</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>可以使用动态规划，时间复杂度是$O(n)$. 显然dp[i]表示数字里面含有的1的个数。但是状态转移如何表示？计算i的时候，如何利用dp[0]-dp[i-1]呢？利用➗2，即右移操作。一个数右移一位，变成较小的数字，失去的是最右的1或者0.则状态转移变成了</p><p>dp[i] = dp[i&gt;&gt;1] + i%2</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type num: int</span></div><div class="line"><span class="string">&gt;           :rtype: List[int]</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(num+<span class="number">1</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,num+<span class="number">1</span>):</div><div class="line">&gt;               dp[i] = dp[i//<span class="number">2</span>] + i%<span class="number">2</span></div><div class="line">&gt;           <span class="keyword">return</span> dp</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="comment">###利用Python内置函数。</span></div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type num: int</span></div><div class="line"><span class="string">&gt;           :rtype: List[int]</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">return</span> [bin(x).count(<span class="string">'1'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(num+<span class="number">1</span>)]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h3><blockquote><ul><li><p>题目</p><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;   nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&gt;   target = <span class="number">4</span></div><div class="line">&gt;   </div><div class="line">&gt;   The possible combination ways are:</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">&gt;   (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">&gt;   (<span class="number">2</span>, <span class="number">2</span>)</div><div class="line">&gt;   (<span class="number">3</span>, <span class="number">1</span>)</div><div class="line">&gt;   </div><div class="line">&gt;   Note that different sequences are counted as different combinations.</div><div class="line">&gt;   </div><div class="line">&gt;   Therefore the output is <span class="number">7</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  <strong>Follow up:</strong> What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?</p><ul><li><p>思路</p><p>就是找银币了。但是不同于找硬币，其状态转移是dp[i] = dp[i-j] + 1；该问题的状态转移是dp[i] += dp[i-1]</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :type target: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> target == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;<span class="number">0</span>:</div><div class="line">&gt;               dif = <span class="number">1</span> - nums[<span class="number">0</span>]</div><div class="line">&gt;               target += dif</div><div class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">&gt;                   nums[i] += dif</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> nums:</div><div class="line">&gt;                   <span class="keyword">if</span> j &lt;= i:</div><div class="line">&gt;                       dp[i] += dp[i - j]</div><div class="line">&gt;           print(dp)</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Integer-Break-343"><a href="#Integer-Break-343" class="headerlink" title="Integer Break(343)"></a>Integer Break(343)</h3><blockquote><ul><li><p>题目</p><p>Given a positive integer <em>n</em>, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given <em>n</em> = 2, return 1 (2 = 1 + 1); given <em>n</em> = 10, return 36 (10 = 3 + 3 + 4).</p><p><strong>Note</strong>: You may assume that <em>n</em> is not less than 2 and not larger than 58.</p></li><li><p>思路</p><p>动态规划时间复杂度$O(n)$.难点在于状态转移方程，dp[i]表示i的因数的最大乘积。想到dp[i] = max( dp[i] , dp[j] <em> (i-j) )，其实本质就是将i先分解成（【j】  </em> 【i-j】），但是j可以再分解，同样i-j也可以再分解，选择大的。</p><p>即max（ j , dp[j] ）* max（i-j ，dp[i-j]）</p><p>故状态转移方程是：</p><p>dp[i] = max ( dp[i] , max（ j , dp[j] ）* max（i-j ，dp[i-j]） )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</div><div class="line">&gt;                   dp[i] = max (dp[i], max(dp[j],j)*max(dp[i-j],i-j))</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Word-Break-139"><a href="#Word-Break-139" class="headerlink" title="Word Break(139)"></a>Word Break(139)</h3><ul><li><p>题目</p><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Example1:</div><div class="line"></div><div class="line">Input: s = <span class="string">"leetcode"</span>, wordDict = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</div><div class="line">Output: <span class="keyword">true</span></div><div class="line">Explanation: Return <span class="keyword">true</span> because <span class="string">"leetcode"</span> can be segmented as <span class="string">"leet code"</span>.</div><div class="line">    </div><div class="line">Example2:</div><div class="line"></div><div class="line">Input: s = <span class="string">"applepenapple"</span>, wordDict = [<span class="string">"apple"</span>, <span class="string">"pen"</span>]</div><div class="line">Output: <span class="keyword">true</span></div><div class="line">Explanation: Return <span class="keyword">true</span> because <span class="string">"applepenapple"</span> can be segmented as <span class="string">"apple pen apple"</span>. Note that you are allowed to reuse a dictionary word.</div><div class="line"></div><div class="line">Example3:</div><div class="line">Input: s = <span class="string">"catsandog"</span>, wordDict = [<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]</div><div class="line">Output: <span class="keyword">false</span></div></pre></td></tr></table></figure></li><li><p>思路</p><p>$O(n^2)$的复杂度。</p><p>dp[i]表示子串$s[0,1…i-1]$能否由字典表示</p><p>dp[i] = true if dp[j]==true and s[j,j+1,…,i-1] is in dic.</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></div><div class="line">        dp = [<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)+<span class="number">1</span>)]</div><div class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)+<span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</div><div class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</div><div class="line">                    dp[i] = <span class="keyword">True</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</div></pre></td></tr></table></figure></li></ul><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><p>接下来，让我们来看看如何解决二维的DP问题。</p><p>平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。</p><p>解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。</p><p>首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是， 到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果， 我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解)</p><p>经过上面的分析，很容易可以得出问题的状态和状态转移方程。 状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么， 状态转移方程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">S[i][j]=A[i][j] + max(S[i-<span class="number">1</span>][j], <span class="keyword">if</span> i&gt;<span class="number">0</span> ; S[i][j-<span class="number">1</span>], <span class="keyword">if</span> j&gt;<span class="number">0</span>)</div></pre></td></tr></table></figure><p>$S[i][j]$有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算$S[i][j]$时，$S[i-1][j]$和$S[i][j-1]$都已经计算出来了。</p><h3 id="Ones-and-Zeroes-474"><a href="#Ones-and-Zeroes-474" class="headerlink" title="Ones and Zeroes(474)"></a>Ones and Zeroes(474)</h3><ul><li><p>题目</p><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p><p>For now, suppose you are a dominator of <strong>m</strong> <code>0s</code> and <strong>n</strong> <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p><p>Now your task is to find the maximum number of strings that you can form with given <strong>m</strong> <code>0s</code> and <strong>n</strong> <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most <strong>once</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Example1:</div><div class="line"></div><div class="line">Input: Array = &#123;<span class="string">"10"</span>, <span class="string">"0001"</span>, <span class="string">"111001"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>&#125;, m = <span class="number">5</span>, n = <span class="number">3</span></div><div class="line">Output: <span class="number">4</span></div><div class="line"></div><div class="line">Explanation: This are totally <span class="number">4</span> strings can be formed by the using of <span class="number">5</span> <span class="number">0</span>s and <span class="number">3</span> <span class="number">1</span>s, which are “<span class="number">10</span>,”<span class="number">0001</span>”,”<span class="number">1</span>”,”<span class="number">0</span>”</div><div class="line"></div><div class="line">Example2:</div><div class="line"></div><div class="line">Input: Array = &#123;<span class="string">"10"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>&#125;, m = <span class="number">1</span>, n = <span class="number">1</span></div><div class="line">Output: <span class="number">2</span></div><div class="line"></div><div class="line">Explanation: You could form <span class="string">"10"</span>, but then you<span class="string">'d have nothing left. Better form "0" and "1".</span></div></pre></td></tr></table></figure></li><li><p>思路</p></li><li><p>代码</p></li></ul><h3 id="Maximal-Square-221"><a href="#Maximal-Square-221" class="headerlink" title="Maximal Square(221)"></a><em><u>Maximal Square(221)</u></em></h3><blockquote><ul><li><p>题目</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: </div><div class="line">&gt;   </div><div class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></div><div class="line">&gt;   <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></div><div class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></div><div class="line">&gt;   </div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>想不到用dp解决。</p><p>dp[i][j]表示以点[i][j]为右下角顶点的正方形的边长。为了构成全1正方形，该点必须是1，那么如何利用已经计算好的dp状态更新当前dp状态呢？即如何根据该点拓展正方形？与它上方，左方和左上方三个点有关。</p><p>当我们判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角，否则该点为右下角的正方形最大就是它自己了。这是定性的判断，那具体的最大正方形边长呢？我们知道，该点为右下角的正方形的最大边长，最多比它的上方，左方和左上方为右下角的正方形的边长多1，最好的情况是是它的上方，左方和左上方为右下角的正方形的大小都一样的，这样加上该点就可以构成一个更大的正方形。但如果它的上方，左方和左上方为右下角的正方形的大小不一样，合起来就会缺了某个角落，这时候只能取那三个正方形中最小的正方形的边长加1了。假设<code>dp[i][j]</code>表示以i,j为右下角的正方形的最大边长，则有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + <span class="number">1</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type matrix: List[List[str]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           row = len(matrix)</div><div class="line">&gt;           column = len(matrix[<span class="number">0</span>])</div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(column) ] <span class="keyword">for</span> i <span class="keyword">in</span> range(row) ]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = int(matrix[i][<span class="number">0</span>])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(column):</div><div class="line">&gt;               dp[<span class="number">0</span>][i] = int(matrix[<span class="number">0</span>][i])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,row):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,column):</div><div class="line">&gt;                   <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</div><div class="line">&gt;                       dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</div><div class="line">&gt;               re = max(re,max(dp[i]))</div><div class="line">&gt;           <span class="keyword">return</span> re * re <span class="comment">### re != max(max(dp))</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h3><blockquote><ul><li><p>题目</p><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">5</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   Given n = <span class="number">3</span>, there are a total of <span class="number">5</span> unique BST<span class="string">'s:</span></div><div class="line"><span class="string">&gt;   </span></div><div class="line"><span class="string">&gt;      1         3     3      2      1</span></div><div class="line"><span class="string">&gt;       \       /     /      / \      \</span></div><div class="line"><span class="string">&gt;        3     2     1      1   3      2</span></div><div class="line"><span class="string">&gt;       /     /       \                 \</span></div><div class="line"><span class="string">&gt;      2     1         2                 3</span></div><div class="line"><span class="string">&gt;</span></div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>不会想到用动态规划。但是知道可以dp，有大致的想法，我最初认为dp[i]表示数字1，2，…，i能形成的二叉树的数量。这样在状态转移的时候就有麻烦了。其实，与数字大小无关，即dp[i]也可以是9，10，11，…，i+9形成的二叉树，实际上，dp[i]状态表示的是i个有序上升点能形成的二叉树个数。这样问题就简单了。状态转移：</p><p>dp[i] += dp[j-1] * dp[i-j] 遍历j从1-i，表示以j为顶点形成的二叉树。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> n</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</div><div class="line">&gt;                   dp[i] += dp[j<span class="number">-1</span>] * dp[i-j] <span class="comment">## += 且 j-1</span></div><div class="line">&gt;           print(dp)</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h3><blockquote><ul><li><p>题目</p><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="string">'A'</span> -&gt; <span class="number">1</span></div><div class="line">&gt;   <span class="string">'B'</span> -&gt; <span class="number">2</span></div><div class="line">&gt;   ...</div><div class="line">&gt;   <span class="string">'Z'</span> -&gt; <span class="number">26</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"12"</span></div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: It could be decoded as <span class="string">"AB"</span> (<span class="number">1</span> <span class="number">2</span>) or <span class="string">"L"</span> (<span class="number">12</span>).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"226"</span></div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: It could be decoded as <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), or <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>可以想到用dp，但是一直纠结于dp的维数。</p><p>dp[i]表示1-i字符串的decode种类，那么状态转移方程呢？与具体的字符串有关。因为数字只能是一位或者两位，且一位的数字不能是0.那么如果当前的数字是0，那么不能以一位解码；否则可以以该种方式解码，则dp[i] += dp[i-1];如果i-1和i的两位数是合法的，即位于10和26之间，那么是可以以两位数解码，dp[i] += dp[i-2] </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   dp[i] = </div><div class="line">&gt;       <span class="number">0</span>                   <span class="keyword">if</span> s[i] and s[i-<span class="number">1</span>][i] invalid</div><div class="line">&gt;       dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]   <span class="keyword">if</span> s[i] and s[i-<span class="number">1</span>][i] valid</div><div class="line">&gt;       dp[i-<span class="number">1</span>]             <span class="keyword">if</span> s[i] valid</div><div class="line">&gt;       dp[i-<span class="number">2</span>]             <span class="keyword">if</span> s[i-<span class="number">1</span>][i] valid</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type s: str</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(s)</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l + <span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] !=<span class="string">'0'</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</div><div class="line">&gt;               one_digit = s[i]</div><div class="line">&gt;               two_digit = int(s[i - <span class="number">1</span>:i + <span class="number">1</span>])</div><div class="line">&gt;               <span class="keyword">if</span> one_digit != <span class="string">'0'</span>:</div><div class="line">&gt;                   dp[i + <span class="number">1</span>] += dp[i]</div><div class="line">&gt;               <span class="keyword">if</span> two_digit &lt;= <span class="number">26</span> <span class="keyword">and</span> two_digit &gt;= <span class="number">10</span>:</div><div class="line">&gt;                   dp[i + <span class="number">1</span>] += dp[i - <span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a>368. Largest Divisible Subset</h3><blockquote><ul><li><p>题目</p><p>Given a set of <strong>distinct</strong> positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p><p>If there are multiple solutions, return any subset is fine.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">&gt;   </div><div class="line">&gt;   Result: [<span class="number">1</span>,<span class="number">2</span>] (of course, [<span class="number">1</span>,<span class="number">3</span>] will also be ok)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</div><div class="line">&gt;   </div><div class="line">&gt;   Result: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>题目是很复杂了，而且不会想到用dp，因为这边求解的是list，而非极值。看了网上代码，还是em。</p><p>首先不论返回的list，单纯看最大的可以是多大，因为取余有个性质，i&gt;j&gt;k, i % j = 0，j % k = 0, 那么i % k = 0.所以给了dp状态转移的思路，</p><p>dp[i]表示数字i以及i之前的数组能形成的最大子集，状态的更新只需要考虑i之前的数字能否取余为零</p><p>dp[i] = max( dp[i] , dp[j] +1 ) if i % j == 0</p><p>接下来难点就是如何记录结果list，当然我们可以设置一个二维数组来保存，一旦更新dp的时候，也要更新对应的list，即把i值加上上一个list中。但是我们可以把$O(n^2)$的空间复杂度变成$D(n)$, pre[i]记录i之前能取余且得到最大的子集的元素的下标。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   https:<span class="comment">//www.cnblogs.com/godlei/p/5621990.html</span></div><div class="line">&gt;   </div><div class="line">&gt;   如果a%b==<span class="number">0</span>，则a=mb，所以如果把数组排序后如果a%b==<span class="number">0</span>，且b%c==<span class="number">0</span>则a%c==<span class="number">0</span>。这就为用动态规划实现提供了可能性。设置一个数组result，result[i]表示i出包含的满足条件的子集个数。则如果nums[i]%nums[j]==<span class="number">0</span>，则result[i]=result[j]+<span class="number">1</span>;同时由于函数要返回的是一个List，所以我们要保存最长集合的路径。这个功能可以通过设置一个pre数组保存能被nums[i]整除的上一个数的索引。并在保存max值的同时保存max所在的位置maxIndex即可。</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: List[int]</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</div><div class="line">&gt;           nums = sorted(nums)</div><div class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]  <span class="comment">##表示集合元素个数,初始是1，表示至少自己单独成为合法的集合</span></div><div class="line">&gt;           size_max = <span class="number">1</span></div><div class="line">&gt;           index_max = <span class="number">0</span></div><div class="line">&gt;           pre = [<span class="number">-1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</div><div class="line">&gt;                   <span class="keyword">if</span> nums[i] % nums[j] == <span class="number">0</span> <span class="keyword">and</span> dp[i] &lt; dp[j] + <span class="number">1</span>:</div><div class="line">&gt;                       dp[i] = dp[j] + <span class="number">1</span></div><div class="line">&gt;                       pre[i] = j <span class="comment">##</span></div><div class="line">&gt;                       <span class="keyword">if</span> dp[i]&gt;size_max: <span class="comment">## 等于也ok</span></div><div class="line">&gt;                           size_max = dp[i]</div><div class="line">&gt;                           index_max = i</div><div class="line">&gt;           re = []</div><div class="line">&gt;           <span class="keyword">while</span> index_max != <span class="number">-1</span>:</div><div class="line">&gt;               re.append(nums[index_max])</div><div class="line">&gt;               index_max = pre[index_max]</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a>740. Delete and Earn</h3><blockquote><p>题目</p><p>Given an array <code>nums</code> of integers, you can perform operations on the array.</p><p>In each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. After, you must delete <strong>every</strong> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt; Example1:</div><div class="line">&gt; Input: nums = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</div><div class="line">&gt; Output: <span class="number">6</span></div><div class="line">&gt; Explanation: </div><div class="line">&gt; Delete <span class="number">4</span> to earn <span class="number">4</span> points, consequently <span class="number">3</span> is also deleted.</div><div class="line">&gt; Then, delete <span class="number">2</span> to earn <span class="number">2</span> points. <span class="number">6</span> total points are earned.</div><div class="line">&gt; </div><div class="line">&gt; Example2:</div><div class="line">&gt; Input: nums = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&gt; Output: <span class="number">9</span></div><div class="line">&gt; Explanation: </div><div class="line">&gt; Delete <span class="number">3</span> to earn <span class="number">3</span> points, deleting both <span class="number">2</span><span class="string">'s and the 4.</span></div><div class="line"><span class="string">&gt; Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span></div><div class="line"><span class="string">&gt; 9 total points are earned.</span></div><div class="line"><span class="string">&gt;</span></div></pre></td></tr></table></figure><ul><li><p>思路</p><p>这道题本质上就是198题House Rober。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> collections</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">deleteAndEarn</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           dic = collections.Counter(nums)</div><div class="line">&gt;           N = max(nums)</div><div class="line">&gt;           new_nums = []</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>): <span class="comment">#防止情况[3,1]</span></div><div class="line">&gt;               v = dic[i] <span class="keyword">if</span> i <span class="keyword">in</span> dic.keys() <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;               new_nums.append(i*v)</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(new_nums)+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">1</span>] = new_nums[<span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(new_nums)):</div><div class="line">&gt;               dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+new_nums[i])</div><div class="line">&gt;           <span class="keyword">return</span> max(dp)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="718-Maximum-Length-of-Repeated-Subarray"><a href="#718-Maximum-Length-of-Repeated-Subarray" class="headerlink" title="718. Maximum Length of Repeated Subarray"></a>718. Maximum Length of Repeated Subarray</h3><blockquote><ul><li><p>题目</p><p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;   Input:</div><div class="line">&gt;   A: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</div><div class="line">&gt;   B: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The repeated subarray with maximum length is [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].</div><div class="line">&gt;</div></pre></td></tr></table></figure></li><li><p>思路</p><p>经典动态规划。A[i]：表示A的子串0-i，B[j]：表示B的子串0-j</p><p>dp[i][j]：A的子串与B的子串最长重合，状态更新dp[i][j] = dp[i-1][j-1] + 1 if 两个子串的最后字符相同</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, A, B)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type A: List[int]</span></div><div class="line"><span class="string">&gt;           :type B: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           la = len(A)</div><div class="line">&gt;           lb = len(B)</div><div class="line">&gt;           dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(la+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(lb+<span class="number">1</span>) ]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(la):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(lb):</div><div class="line">&gt;                   <span class="keyword">if</span> A[i]==B[j]:</div><div class="line">&gt;                       dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">return</span> max(max(row) <span class="keyword">for</span> row <span class="keyword">in</span> dp)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Minimum-ASCII-Delete-Sum-for-Two-Strings-712"><a href="#Minimum-ASCII-Delete-Sum-for-Two-Strings-712" class="headerlink" title="Minimum ASCII Delete Sum for Two Strings(712)"></a>Minimum ASCII Delete Sum for Two Strings(712)</h3><blockquote><ul><li><p>题目</p><p>Given two strings <code>s1, s2</code>, find the lowest ASCII sum of deleted characters to make two strings equal. All elements of each string will have an ASCII value in <code>[97, 122]</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: s1 = <span class="string">"sea"</span>, s2 = <span class="string">"eat"</span></div><div class="line">&gt;   Output: <span class="number">231</span></div><div class="line">&gt;   Explanation: Deleting <span class="string">"s"</span> from <span class="string">"sea"</span> adds the ASCII value of <span class="string">"s"</span> (<span class="number">115</span>) to the sum.</div><div class="line">&gt;   Deleting <span class="string">"t"</span> from <span class="string">"eat"</span> adds <span class="number">116</span> to the sum.</div><div class="line">&gt;   At the end, both strings are equal, and <span class="number">115</span> + <span class="number">116</span> = <span class="number">231</span> is the minimum sum possible to achieve <span class="keyword">this</span>.</div><div class="line">&gt;   </div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: s1 = <span class="string">"delete"</span>, s2 = <span class="string">"leet"</span></div><div class="line">&gt;   Output: <span class="number">403</span></div><div class="line">&gt;   Explanation: Deleting <span class="string">"dee"</span> from <span class="string">"delete"</span> to turn the string into <span class="string">"let"</span>,</div><div class="line">&gt;   adds <span class="number">100</span>[d]+<span class="number">101</span>[e]+<span class="number">101</span>[e] to the sum.  Deleting <span class="string">"e"</span> from <span class="string">"leet"</span> adds <span class="number">101</span>[e] to the sum.</div><div class="line">&gt;   At the end, both strings are equal to <span class="string">"let"</span>, and the answer is <span class="number">100</span>+<span class="number">101</span>+<span class="number">101</span>+<span class="number">101</span> = <span class="number">403</span>.</div><div class="line">&gt;   If instead we turned both strings into <span class="string">"lee"</span> or <span class="string">"eet"</span>, we would get answers of <span class="number">433</span> or <span class="number">417</span>, which are higher.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li><li><p>思路</p><p>这道题就是LCS (Longest Common Subsequence).</p><p>在LCS中，<code>d[i][j]</code>表示<code>s1.substring(0,i)</code>和<code>s2.substring(0,j)</code>的LCS的长度, 那么</p><p><code>d[i][j]</code>=<code>d[i-1][j-1]</code>+1                                    if <code>s1[i-1]</code> == <code>s2[j-1]</code></p><p><code>d[i][j]</code>=max(<code>d[i-1][j]</code>, <code>d[i]]j-1</code>)              if <code>s1[i-1]</code> != <code>s2[j-1]</code></p><p>那么在本题背景下，<code>d[i][j]</code>表示<code>s1.substring(0,i)</code>和<code>s2.substring(0,j)</code>删除若干个字符后相等的最小<code>cost</code>，那么</p><p><code>d[i][j]</code>=<code>d[i-1][j-1]</code>+0                                                                        if <code>s1[i-1]</code> == <code>s2[j-1]</code></p><p><code>d[i][j]</code>=min(<code>d[i-1][j]</code>+<code>s1[i-1]</code>, <code>d[i]]j-1</code>+<code>s2[j-1]</code>)              if <code>s1[i-1]</code> != <code>s2[j-1]</code></p><p>但是，这道题需要和718题的Maximum Length of Repeated Subarray作个比较,因为718题的状态转移方程是：</p><p><code>d[i][j]</code>=<code>d[i-1][j-1]</code>+1          if <code>s1[i-1]</code> == <code>s2[j-1]</code> </p><p><code>d[i][j]</code>=0                                     if <code>s1[i-1]</code> != <code>s2[j-1]</code></p><p>差异在于 if <code>s1[i-1]</code> != <code>s2[j-1]</code>，在718中，一旦不等，意味着连续的相等的子串已经消失，则当前的计算得重新开始，重点是“连续”</p><p>而在本题以及LCS中，一旦不等，不必重新开始，因为没有要求“连续”，大不了跳过这个不等，则当前不等的计算就依赖于前面</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span><span class="params">(self, s1, s2)</span>:</span></div><div class="line">&gt;           mv = sys.maxsize</div><div class="line">&gt;           l1 = len(s1)</div><div class="line">&gt;           l2 = len(s2)</div><div class="line">&gt;           dp = [[ mv <span class="keyword">for</span> _ <span class="keyword">in</span> range(l2+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l1):</div><div class="line">&gt;               dp[i + <span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>]+ord(s1[i])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l2):</div><div class="line">&gt;               dp[<span class="number">0</span>][i + <span class="number">1</span>] = dp[<span class="number">0</span>][i]+ord(s2[i])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1+<span class="number">1</span>):</div><div class="line">&gt;                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2+<span class="number">1</span>):</div><div class="line">&gt;                   <span class="keyword">if</span> s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]:</div><div class="line">&gt;                       dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</div><div class="line">&gt;                   <span class="keyword">else</span>:</div><div class="line">&gt;                       dp[i][j] = min(dp[i<span class="number">-1</span>][j]+ord(s1[i<span class="number">-1</span>]) , dp[i][j<span class="number">-1</span>]+ord(s2[j<span class="number">-1</span>]))</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Knight-Probability-in-Chessboard-688"><a href="#Knight-Probability-in-Chessboard-688" class="headerlink" title="Knight Probability in Chessboard(688)"></a>Knight Probability in Chessboard(688)</h3><blockquote><ul><li><p>题目</p><p>On an <code>N</code>x<code>N</code> chessboard, a knight starts at the <code>r</code>-th row and <code>c</code>-th column and attempts to make exactly <code>K</code> moves. The rows and columns are 0 indexed, so the top-left square is <code>(0, 0)</code>, and the bottom-right square is <code>(N-1, N-1)</code>.</p><p>A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p><p><img src="/2018/05/26/Dynamic-Programming/knight.png" alt=""></p><p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p><p>The knight continues moving until it has made exactly <code>K</code> moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.</p></li><li><p>思路</p><p><code>dp[i][j][k]</code>:表示经过<code>k</code>次移动之后，knight到达位置<code>[i,j]</code>的所有可能方法数。那么状态转移有两种，一种是如果knight当前位置是<code>[i][j]</code>,且当前是第<code>k</code>次移动，那么更新下一次从当前<code>[i][j]</code>位置可能到达的其他位置<code>dp[i+x][j+y][k+1]</code>;另一种是当前位置是<code>[i][j]</code>,且当前是第<code>k</code>次移动，那么上一次<code>k-1</code>移动是如何到达当前位置。</p><p>本代码实现第一种方法，因为当前状态只与上一次状态有关，所以通过降维，使用<code>dp0[]</code>和<code>dp1[]</code>表示<code>k-1</code>和<code>k</code>的可能性，’状态转移是:</p><p><code>dp1[i][j] += dp0[i+x][j+y]</code></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">knightProbability</span><span class="params">(self, N, K, r, c)</span>:</span></div><div class="line">&gt;           dp0 = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           dp0[r][c] = <span class="number">1</span></div><div class="line">&gt;           dirs = [[<span class="number">-2</span>,<span class="number">-1</span>],[<span class="number">-2</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">-2</span>],[<span class="number">-1</span>,<span class="number">-2</span>]]</div><div class="line">&gt;           <span class="keyword">for</span> step <span class="keyword">in</span> range(K):</div><div class="line">&gt;               dp1 = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</div><div class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;                   <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</div><div class="line">&gt;                       <span class="keyword">for</span> d <span class="keyword">in</span> dirs:</div><div class="line">&gt;                           x = i+d[<span class="number">0</span>]</div><div class="line">&gt;                           y = j+d[<span class="number">1</span>]</div><div class="line">&gt;                           <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;N<span class="number">-1</span> <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> y&gt;N<span class="number">-1</span>:</div><div class="line">&gt;                               <span class="keyword">pass</span></div><div class="line">&gt;                           <span class="keyword">else</span>:</div><div class="line">&gt;                               dp1[x][y] += dp0[i][j]</div><div class="line">&gt;               dp0 = dp1</div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;               re += sum(dp0[i])</div><div class="line">&gt;           <span class="keyword">return</span> re/(<span class="number">8</span>**K)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Number-of-Longest-Increasing-Subsequence-673"><a href="#Number-of-Longest-Increasing-Subsequence-673" class="headerlink" title="Number of Longest Increasing Subsequence(673)"></a>Number of Longest Increasing Subsequence(673)</h3><blockquote><ul><li><p>题目</p><p>Given an unsorted array of integers, find the number of longest increasing subsequence.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: The two longest increasing subsequence are [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>] and [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>].</div><div class="line">&gt;       </div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</div><div class="line">&gt;   Output: <span class="number">5</span></div><div class="line">&gt;   Explanation: The length of longest continuous increasing subsequence is <span class="number">1</span>, and there are <span class="number">5</span> subsequences<span class="string">' length is 1, so output 5.</span></div><div class="line"><span class="string">&gt;       </span></div><div class="line"><span class="string">&gt;   Example3:</span></div><div class="line"><span class="string">&gt;   Input: [1,2,4,2,3]</span></div><div class="line"><span class="string">&gt;   Output: 3</span></div><div class="line"><span class="string">&gt;   Explanation: The two longest increasing subsequence are [1, 2, 4] and [1, 2, 3] and [1, 2, 3].</span></div><div class="line"><span class="string">&gt;</span></div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>dp[i]表示子串S[0] - S[i-1]的最长上升子串长度。动态转移方程是dp[i] = max (dp[i], dp[j] + 1), j 的范围是[0, i-1]。所以代码实现时，需要双重循环。但是，我们还需要记录一个构成最长子串的方式数。比如子串【1，2，4，2，3】，最长上升子串长度是3，但是有两种方式实现，【1，2，3】(2来自于index=1)和【1，2，3】[2来自于index=3]。</p><p>dp[i][2]:dp[i][0]表示子串S[0] - S[i-1]的最长上升子串长度，dp[i][1]第二维记录构成该最长子串的方式数</p><p>if dp[i][0]&gt;dp[j][1]  then dp[i][0] = dp[j][0] + 1, dp[i][1]  = dp[i][1] </p><p>else if dp[i][0]==dp[j][1]  then dp[i][1]  += dp[i][1] </p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums :<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           max_len = <span class="number">1</span></div><div class="line">&gt;           dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</div><div class="line">&gt;                   <span class="keyword">if</span> nums[i] &gt; nums[j]:</div><div class="line">&gt;                       <span class="keyword">if</span> dp[i][<span class="number">0</span>]&lt;dp[j][<span class="number">0</span>] + <span class="number">1</span>:</div><div class="line">&gt;                           dp[i][<span class="number">0</span>] = dp[j][<span class="number">0</span>] + <span class="number">1</span></div><div class="line">&gt;                           dp[i][<span class="number">1</span>] = dp[j][<span class="number">1</span>]</div><div class="line">&gt;                           max_len = max(max_len,dp[i][<span class="number">0</span>])</div><div class="line">&gt;                       <span class="keyword">elif</span> dp[i][<span class="number">0</span>] == dp[j][<span class="number">0</span>] + <span class="number">1</span>:</div><div class="line">&gt;                           dp[i][<span class="number">1</span>] += dp[j][<span class="number">1</span>]</div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">&gt;               <span class="keyword">if</span> dp[i][<span class="number">0</span>]==max_len:</div><div class="line">&gt;                   re+=dp[i][<span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><h3 id="2-Keys-Keyboard"><a href="#2-Keys-Keyboard" class="headerlink" title="2 Keys Keyboard"></a>2 Keys Keyboard</h3><blockquote><ul><li><p>题目</p><p>Initially on a notepad only one character ‘A’ is present. You can perform two operations on this notepad for each step:</p><ol><li><code>Copy All</code>: You can copy all the characters present on the notepad (partial copy is not allowed).</li><li><code>Paste</code>: You can paste the characters which are copied <strong>last time</strong>.</li></ol><p>Given a number <code>n</code>. You have to get <strong>exactly</strong> <code>n</code> ‘A’ on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get <code>n</code> ‘A’.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   </div><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   Intitally, we have one character <span class="string">'A'</span>.</div><div class="line">&gt;   In step <span class="number">1</span>, we use Copy All operation.</div><div class="line">&gt;   In step <span class="number">2</span>, we use Paste operation to get <span class="string">'AA'</span>.</div><div class="line">&gt;   In step <span class="number">3</span>, we use Paste operation to get <span class="string">'AAA'</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li>思路</li></ul><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           mv = sys.maxsize</div><div class="line">&gt;           <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           dp = [mv <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i):</div><div class="line">&gt;                   <span class="keyword">if</span> i%j == <span class="number">0</span>:</div><div class="line">&gt;                       dp[i] = min(dp[i],dp[j] + i//j)</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><h3 id="Out-of-Boundary-Paths-576"><a href="#Out-of-Boundary-Paths-576" class="headerlink" title="Out of Boundary Paths(576)"></a>Out of Boundary Paths(576)</h3><ul><li><p>题目</p><p>There is an <strong>m</strong> by <strong>n</strong> grid with a ball. Given the start coordinate <strong>(i,j)</strong> of the ball, you can move the ball to <strong>adjacent</strong> cell or cross the grid boundary in four directions (up, down, left, right). However, you can <strong>at most</strong> move <strong>N</strong> times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.</p><p><img src="/2018/05/26/Dynamic-Programming/Screen Shot 2018-05-29 at 8.25.29 PM.png" alt="Screen Shot 2018-05-29 at 8.25.29 PM"></p></li></ul><ul><li><p>思路</p><p><a href="http://www.cnblogs.com/grandyang/p/6927921.html" target="_blank" rel="noopener">参考</a></p><p>这道题给了我们一个二维的数组，某个位置放个足球，每次可以在上下左右四个方向中任意移动一步，总共可以移动N步，问我们总共能有多少种移动方法能把足球移除边界，由于结果可能是个巨大的数，所以让我们对一个大数取余。那么我们知道对于这种结果很大的数如果用递归解法很容易爆栈，所以最好考虑使用DP来解。那么我们使用一个三维的DP数组，其中dp[k][i][j]表示总共走k步，从(i,j)位置走出边界的总路径数。那么我们来找递推式，对于dp[k][i][j]，走k步出边界的总路径数等于其周围四个位置的走k-1步出边界的总路径数之和，如果周围某个位置已经出边界了，那么就直接加上1，否则就在dp数组中找出该值，这样整个更新下来，我们就能得出每一个位置走任意步数的出界路径数了，最后只要返回dp[N][i][j]就是所求结果了，参见代码如下.</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(self, m, n, N, i, j)</span>:</span></div><div class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]<span class="comment">##N+1是为了防止出现N=0情况。</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> ii <span class="keyword">in</span> range(m):</div><div class="line">                <span class="keyword">for</span> jj <span class="keyword">in</span> range(n):</div><div class="line">                    v1 = <span class="number">1</span> <span class="keyword">if</span> ii==<span class="number">0</span> <span class="keyword">else</span> dp[ii<span class="number">-1</span>][jj][k<span class="number">-1</span>]</div><div class="line">                    v2 = <span class="number">1</span> <span class="keyword">if</span> ii==m<span class="number">-1</span> <span class="keyword">else</span> dp[ii+<span class="number">1</span>][jj][k<span class="number">-1</span>]</div><div class="line">                    v3 = <span class="number">1</span> <span class="keyword">if</span> jj==<span class="number">0</span> <span class="keyword">else</span> dp[ii][jj<span class="number">-1</span>][k<span class="number">-1</span>]</div><div class="line">                    v4 = <span class="number">1</span> <span class="keyword">if</span> jj==n<span class="number">-1</span> <span class="keyword">else</span> dp[ii][jj+<span class="number">1</span>][k<span class="number">-1</span>]</div><div class="line">                    dp[ii][jj][k] = (v1+v2+v3+v4)%<span class="number">1000000007</span></div><div class="line">        <span class="keyword">return</span> dp[i][j][N]</div></pre></td></tr></table></figure></li></ul><h3 id="Longest-Palindromic-Subsequence-516-—for-Length"><a href="#Longest-Palindromic-Subsequence-516-—for-Length" class="headerlink" title="Longest Palindromic Subsequence(516)—for(Length)"></a><em><u>Longest Palindromic Subsequence(516)—for(Length)</u></em></h3><ul><li><p>题目</p><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Example1:</div><div class="line"></div><div class="line">Input:<span class="string">"bbbab"</span> Output:<span class="number">4</span> </div><div class="line">One possible longest palindromic subsequence is <span class="string">"bbbb"</span>.</div><div class="line"></div><div class="line">Example2:</div><div class="line">Input:<span class="string">"cbbd"</span> Output:<span class="number">2</span> </div><div class="line">One possible longest palindromic subsequence is <span class="string">"bb"</span>.</div></pre></td></tr></table></figure></li><li><p>思路</p><p>dp[i][j]表示字符串s[i…j]的最长回文串长度。</p><p>dp[i][j] = 1 表示单个单个字符s[i]就是一个回文串</p><p>dp[i][j] = dp[i+1][j-1] + 2 if s[i]==s[j], else</p><p>dp[i][j] = max (dp[i+1][j], dp[i][j-1])</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type s: str</span></div><div class="line"><span class="string">        :rtype: int</span></div><div class="line"><span class="string">        """</span></div><div class="line">        l = len(s)</div><div class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">            dp[i][i] = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> ll <span class="keyword">in</span> range(<span class="number">1</span>,l+<span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,l-ll):</div><div class="line">                j = i+ll</div><div class="line">                <span class="keyword">if</span> s[i]==s[j]:</div><div class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j] &gt; dp[i][j<span class="number">-1</span>] <span class="keyword">else</span> dp[i][j<span class="number">-1</span>]</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][l<span class="number">-1</span>]</div></pre></td></tr></table></figure></li></ul><h3 id="Predict-the-Winner-486-—for-Length"><a href="#Predict-the-Winner-486-—for-Length" class="headerlink" title="Predict the Winner(486)—for(Length)"></a>Predict the Winner(486)—for(Length)</h3><ul><li><p>题目</p><p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p><p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Example1:</div><div class="line"></div><div class="line">Input: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]</div><div class="line">Output: False</div><div class="line">Explanation: Initially, player <span class="number">1</span> can choose between <span class="number">1</span> and <span class="number">2</span>. </div><div class="line">If he chooses <span class="number">2</span> (or <span class="number">1</span>), then player <span class="number">2</span> can choose from <span class="number">1</span> (or <span class="number">2</span>) and <span class="number">5</span>. If player <span class="number">2</span> chooses <span class="number">5</span>, then player <span class="number">1</span> will be left with <span class="number">1</span> (or <span class="number">2</span>). </div><div class="line">So, <span class="keyword">final</span> score of player <span class="number">1</span> is <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span>, and player <span class="number">2</span> is <span class="number">5</span>. </div><div class="line">Hence, player <span class="number">1</span> will never be the winner and you need to <span class="keyword">return</span> False.</div><div class="line"></div><div class="line">Example2:</div><div class="line"></div><div class="line">Input: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">233</span>, <span class="number">7</span>]</div><div class="line">Output: True</div><div class="line">Explanation: Player <span class="number">1</span> first chooses <span class="number">1</span>. Then player <span class="number">2</span> have to choose between <span class="number">5</span> and <span class="number">7</span>. No matter which number player <span class="number">2</span> choose, player <span class="number">1</span> can choose <span class="number">233</span>.</div><div class="line">Finally, player <span class="number">1</span> <span class="function">has more <span class="title">score</span> <span class="params">(<span class="number">234</span>)</span> than player 2 <span class="params">(<span class="number">12</span>)</span>, so you need to return True representing player1 can win.</span></div></pre></td></tr></table></figure></li><li><p>思路</p><p>dp[i][j]表示子串s[i…j]供选择时两个玩家间的总分数差，无论是玩家1还是玩家2，都希望最大化差异，那么状态转移就是：</p><p>dp[i][j] = max(nums[i] - dp[i+1][j] , nums[j] - dp[i][j-1])</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PredictTheWinner</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type nums: List[int]</span></div><div class="line"><span class="string">        :rtype: bool</span></div><div class="line"><span class="string">        """</span></div><div class="line">        l = len(nums)</div><div class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">            dp[i][i] = nums[i]</div><div class="line">        <span class="keyword">for</span> dis <span class="keyword">in</span> range(<span class="number">1</span>,l):  <span class="comment">#the distance between index of i and j</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l-dis):</div><div class="line">                j = i+dis</div><div class="line">                dp[i][j] = nums[i]-dp[i+<span class="number">1</span>][j] <span class="keyword">if</span> nums[i]-dp[i+<span class="number">1</span>][j]&gt;nums[j]-dp[i][j<span class="number">-1</span>] <span class="keyword">else</span> nums[j]-dp[i][j<span class="number">-1</span>]</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][l<span class="number">-1</span>]&gt;=<span class="number">0</span></div></pre></td></tr></table></figure></li></ul><h3 id="Target-Sum-494"><a href="#Target-Sum-494" class="headerlink" title="Target Sum(494)"></a>Target Sum(494)</h3><ul><li><p>题目</p><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p><p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Input: nums is [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S is <span class="number">3</span>. </div><div class="line">Output: <span class="number">5</span></div><div class="line">Explanation: </div><div class="line"></div><div class="line">-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span> = <span class="number">3</span></div><div class="line"></div><div class="line">There are <span class="number">5</span> ways to assign symbols to make the sum of nums be target <span class="number">3</span>.</div></pre></td></tr></table></figure></li><li><p>思路</p><p><strong>解法1：</strong></p><p>经典动态规划。首先，将问题简单化，只考虑通过组合number，是否能组成得到target。</p><p>$V_i$表示使用num[0],num[1],…,nums[i]个数字组成可以得到的所有可能数字</p><p>那么$V_0={0}$，$V_i=\{V_{i-1}+num[i]\}\cup{\{V_{i-1}-num[i]\}}$</p><p>则判断$target\in{V_n}$</p><p>现在考虑数字组合得到target的方法数目，使用dp[i][j]来记录num[0],num[1],…,num[i-1]个数字组成得到sum=j的不同方式数。那么状态转移就是：</p><p>dp[i][j] = dp[i-1][j+num[i]] + dp[i-1][j-num[i]]</p><p>令num[0], num[1], num[2],…的和为TSUM，而所有可能的sum值，即dp第二维的长度是2*TSUM+1,即{-TSUM, -TSUM+1,…-1,0,1,…,TSUM-1,TSUM}。</p><p>初始化：dp[-1][0] = 1 组合使和0有一种方式，即什么都不操作。而sum=0的index是TSUM即dp[-1][TSUM]=1</p><p><strong>解法2：</strong></p><p>$P$ 表示集合，其中数字的符号只有“+”；$N$ 表示负数集合</p><p>那么$P\cup{N}=\{a_1,a_2,…,a_n\}$, $P\cap{N}=\empty$</p><p>那么问题就变成寻找集合$P$和$Q$，使$sum(P)-sum(N)=target$.</p><p>两边同时加上$sum(P)+sum(N)$</p><p>$sum(P)-sum(N)+sum(P)+sum(N)=target+sum(P)+sum(N)$</p><p>化简得到，$2*sum(P)=sum(a_1,a_2,…,a_n)+target$</p><p>即$sum(P)=\frac{sum(a_1,a_2,…,a_n)+target}{2}$</p><p>这样问题就变成了0-1背包问题，从$a_1,a_2,..,a_n$中凑成价值为$sum(P)$的方案。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">####解法1</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type nums: List[int]</span></div><div class="line"><span class="string">        :type S: int</span></div><div class="line"><span class="string">        :rtype: int</span></div><div class="line"><span class="string">        """</span></div><div class="line">        sums = sum(nums)</div><div class="line">        <span class="keyword">if</span> sums&lt;S:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">        l = len(nums)</div><div class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>*sums+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l+<span class="number">1</span>)]</div><div class="line">        dp[<span class="number">0</span>][sums] = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(nums[i],<span class="number">2</span>*sums+<span class="number">1</span>-nums[i]):</div><div class="line">                <span class="keyword">if</span> (dp[i][j]!=<span class="number">0</span>): <span class="comment">#表示前i-1个数字可以组成(j-tsum),那么通过吸收+num[i]，dp[i][j]可以更新 dp[i+1][j+nums[i]] 和 dp[i+1][j-nums[i]]</span></div><div class="line">                    dp[i+<span class="number">1</span>][j+nums[i]] += dp[i][j]</div><div class="line">                    dp[i+<span class="number">1</span>][j-nums[i]] += dp[i][j]</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][S+sums]</div><div class="line"></div><div class="line"><span class="comment">####解法2：</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type nums: List[int]</span></div><div class="line"><span class="string">        :type S: int</span></div><div class="line"><span class="string">        :rtype: int</span></div><div class="line"><span class="string">        """</span></div><div class="line">        sumA = sum(nums)</div><div class="line">        <span class="keyword">if</span> (sumA + S) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">or</span> sumA &lt; abs(S): <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        target = (sumA+S)//<span class="number">2</span></div><div class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target+<span class="number">1</span>)]</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target,<span class="number">-1</span>,<span class="number">-1</span>):</div><div class="line">                <span class="keyword">if</span> j&gt;=num:</div><div class="line">                    dp[j] += dp[j-num]</div><div class="line">        <span class="keyword">return</span> dp[target]</div></pre></td></tr></table></figure></li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="801-Minimum-Swaps-To-Make-Sequences-Increasing"><a href="#801-Minimum-Swaps-To-Make-Sequences-Increasing" class="headerlink" title="801. Minimum Swaps To Make Sequences Increasing"></a><em><u>801. Minimum Swaps To Make Sequences Increasing</u></em></h3><blockquote><ul><li><p>题目</p><p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p><p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>.  Note that both elements are in the same index position in their respective sequences.</p><p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing.  (A sequence is <em>strictly increasing</em> if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p><p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example:</div><div class="line">&gt;   Input: A = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>], B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</div><div class="line">&gt;   Output: <span class="number">1</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   Swap A[<span class="number">3</span>] and B[<span class="number">3</span>].  Then the sequences are:</div><div class="line">&gt;   A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] and B = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&gt;   which are both strictly increasing.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>文字  <a href="https://blog.csdn.net/magicbean2/article/details/79826617" target="_blank" rel="noopener">https://blog.csdn.net/magicbean2/article/details/79826617</a> </p><p>图片  <a href="http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-801-minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-801-minimum-swaps-to-make-sequences-increasing/</a></p><p> 这道题实在是太难了，不过看图片还是可以稍微有点顺畅。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minSwap</span><span class="params">(self, A, B)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type A: List[int]</span></div><div class="line"><span class="string">&gt;           :type B: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           mv = sys.maxsize</div><div class="line">&gt;           l = len(A)</div><div class="line">&gt;           keep = [mv <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           swap = [mv <span class="keyword">for</span> j <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           keep[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           swap[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 初始是1，不是0，因为意味着A[0]和B[0]交换一次</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l):</div><div class="line">&gt;               a1 = A[i<span class="number">-1</span>]</div><div class="line">&gt;               b1 = B[i<span class="number">-1</span>]</div><div class="line">&gt;               a2 = A[i]</div><div class="line">&gt;               b2 = B[i]</div><div class="line">&gt;               <span class="keyword">if</span> a1 &lt; a2 <span class="keyword">and</span> b1 &lt; b2:</div><div class="line">&gt;                   keep[i] = keep[i<span class="number">-1</span>] <span class="comment"># no swap for both i-1, i</span></div><div class="line">&gt;                   swap[i] = swap[i<span class="number">-1</span>] + <span class="number">1</span> <span class="comment"># swap for both i-1, i; swap[i-1] means swap i-1, 1 means swap i</span></div><div class="line">&gt;               <span class="keyword">if</span> a1 &lt; b2 <span class="keyword">and</span> b1 &lt; a2:</div><div class="line">&gt;                   keep[i] = min(keep[i], swap[i<span class="number">-1</span>])</div><div class="line">&gt;                   swap[i] = min(swap[i], keep[i<span class="number">-1</span>]+<span class="number">1</span>)</div><div class="line">&gt;           <span class="keyword">return</span> min(keep[<span class="number">-1</span>],swap[<span class="number">-1</span>])</div><div class="line">&gt;           </div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="787-Cheapest-Flights-Within-K-Stops"><a href="#787-Cheapest-Flights-Within-K-Stops" class="headerlink" title="787. Cheapest Flights Within K Stops"></a>787. Cheapest Flights Within K Stops</h3><blockquote><ul><li><p>题目</p><p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u</code>and arrives at <code>v</code> with a price <code>w</code>.</p><p>Now given all the cities and fights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example <span class="number">1</span>:</div><div class="line">&gt;   Input: </div><div class="line">&gt;   n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">500</span>]]</div><div class="line">&gt;   src = <span class="number">0</span>, dst = <span class="number">2</span>, k = <span class="number">1</span></div><div class="line">&gt;   Output: <span class="number">200</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The cheapest price from city <span class="number">0</span> to city <span class="number">2</span> with at most <span class="number">1</span> stop costs <span class="number">200</span>, as marked red in the picture.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example <span class="number">2</span>:</div><div class="line">&gt;   Input: </div><div class="line">&gt;   n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">500</span>]]</div><div class="line">&gt;   src = <span class="number">0</span>, dst = <span class="number">2</span>, k = <span class="number">0</span></div><div class="line">&gt;   Output: <span class="number">500</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The cheapest price from city <span class="number">0</span> to city <span class="number">2</span> with at most <span class="number">0</span> stop costs <span class="number">500</span>, as marked blue in the picture.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>dp[i][j]表示从src城市出发，经过i站，到达城市j</p><p>状态转移:</p><p>dp[i][j] = min ( dp[i][j] , dp[i-1][mid]+cost[mid][j] )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n, flights, src, dst, K)</span>:</span></div><div class="line">&gt;           mv = <span class="number">1000000</span></div><div class="line">&gt;           dp = [ [ mv <span class="keyword">for</span> _ <span class="keyword">in</span> range(n) ] <span class="keyword">for</span> _ <span class="keyword">in</span> range(K+<span class="number">2</span>) ] </div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(K+<span class="number">2</span>):</div><div class="line">&gt;               dp[i][src] = <span class="number">0</span> <span class="comment"># 从scr出发到scr，不需要cost</span></div><div class="line">&gt;           <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">2</span>):</div><div class="line">&gt;               <span class="keyword">for</span> flight <span class="keyword">in</span> flights:</div><div class="line">&gt;                  s = flight[<span class="number">0</span>]</div><div class="line">&gt;                  d = flight[<span class="number">1</span>]</div><div class="line">&gt;                  cost = flight[<span class="number">2</span>]</div><div class="line">&gt;                  dp[k][d] = min(dp[k][d],dp[k<span class="number">-1</span>][s]+cost)</div><div class="line">&gt;           <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[K+<span class="number">1</span>][dst]==mv <span class="keyword">else</span> dp[K+<span class="number">1</span>][dst]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="790-Domino-and-Tromino-Tiling"><a href="#790-Domino-and-Tromino-Tiling" class="headerlink" title="790. Domino and Tromino Tiling"></a>790. Domino and Tromino Tiling</h3><blockquote><ul><li><p>题目</p><p>We have two types of tiles: a 2x1 domino shape, and an “L” tromino shape. These shapes may be rotated.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   XX  &lt;- domino</div><div class="line">&gt;   </div><div class="line">&gt;   XX  &lt;- <span class="string">"L"</span> tromino</div><div class="line">&gt;   X</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7</strong>.</p><p>  (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example:</div><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">5</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The five different ways are listed below, different letters indicates different tiles:</div><div class="line">&gt;   XYZ XXZ XYY XXY XYY</div><div class="line">&gt;   XYZ YYZ XZZ XYY XXY</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>图片：<a href="http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-790-domino-and-tromino-tiling/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-790-domino-and-tromino-tiling/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;   dp[i]表示高度为<span class="number">2</span>，长度为i的形状可能组法。</div><div class="line">&gt;   只有xx多米诺时，有两种拼法，用一个xx，但是把它立起来，这样的拼法是dp[i-<span class="number">1</span>];另一种是用两个</div><div class="line">&gt;               xx</div><div class="line">&gt;   xx，组成正方形xx，这样拼法是dp[i-<span class="number">2</span>]</div><div class="line">&gt;   dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>],斐波那契数列。</div><div class="line">&gt;   考虑L型多米诺，具体看图，不好描述。</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numTilings</span><span class="params">(self, N)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type N: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           m = <span class="number">1000000007</span></div><div class="line">&gt;           dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-2</span>][<span class="number">0</span>] + <span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>])%m</div><div class="line">&gt;               dp[i][<span class="number">1</span>] = (dp[i<span class="number">-2</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>])%m</div><div class="line">&gt;           <span class="keyword">return</span> dp[N][<span class="number">0</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h3><blockquote><ul><li><p>题目</p><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"babad"</span></div><div class="line">&gt;   Output: <span class="string">"bab"</span></div><div class="line">&gt;   Note: <span class="string">"aba"</span> is also a valid answer.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"cbbd"</span></div><div class="line">&gt;   Output: <span class="string">"bb"</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>这道题的难点在于，使用下标i和j来表示substring，i和j具体应该如何变化。实际上，i和j分别表示子串的结束字符和开头字符，如果s[i] != s[j]，那么dp[i][j]=false; 否则查看j+1 至 i-1之间是否回文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   dp(i, j) <span class="function">represents whether <span class="title">s</span><span class="params">(i ... j)</span> can form a palindromic substring, <span class="title">dp</span><span class="params">(i, j)</span> is <span class="keyword">true</span> when <span class="title">s</span><span class="params">(i)</span> equals to <span class="title">s</span><span class="params">(j)</span> and <span class="title">s</span><span class="params">(i+<span class="number">1</span> ... j<span class="number">-1</span>)</span> is a palindromic substring. When we found a palindrome, check <span class="keyword">if</span> it's the longest one. Time complexity <span class="title">O</span><span class="params">(n^<span class="number">2</span>)</span>.</span></div><div class="line"><span class="function">&gt;</span></div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type s: str</span></div><div class="line"><span class="string">&gt;           :rtype: str</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">""</span></div><div class="line">&gt;           re = <span class="string">""</span></div><div class="line">&gt;           l = len(s)</div><div class="line">&gt;           dp = [ [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l) ]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">&gt;               dp[i][i] = <span class="keyword">True</span></div><div class="line">&gt;           <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,l):</div><div class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(j,<span class="number">-1</span>,<span class="number">-1</span>):<span class="comment">#start from (j-1), end in 0, not including -1</span></div><div class="line">&gt;                   dp[i][j] = s[i]==s[j] <span class="keyword">and</span> (j-i+<span class="number">1</span>&lt;<span class="number">3</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</div><div class="line">&gt;                   <span class="keyword">if</span> dp[i][j]:</div><div class="line">&gt;                       re = s[i:j+<span class="number">1</span>] <span class="keyword">if</span> len(re)&lt;(j-i+<span class="number">1</span>) <span class="keyword">else</span> re</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="764-Largest-Plus-Sign"><a href="#764-Largest-Plus-Sign" class="headerlink" title="764. Largest Plus Sign"></a><em><u>764. Largest Plus Sign</u></em></h3><blockquote><ul><li><p>题目</p><p>In a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>. What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid? Return the order of the plus sign. If there is none, return 0.</p><p>An “<em>axis-aligned plus sign of 1s</em> of order <strong>k</strong>“ has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code> going up, down, left, and right, and made of <code>1</code>s. This is demonstrated in the diagrams below. Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.</p><p><strong>Examples of Axis-Aligned Plus Signs of Order k:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;   Order <span class="number">1</span>:</div><div class="line">&gt;   <span class="number">000</span></div><div class="line">&gt;   <span class="number">010</span></div><div class="line">&gt;   <span class="number">000</span></div><div class="line">&gt;   </div><div class="line">&gt;   Order <span class="number">2</span>:</div><div class="line">&gt;   <span class="number">00000</span></div><div class="line">&gt;   <span class="number">00100</span></div><div class="line">&gt;   <span class="number">01110</span></div><div class="line">&gt;   <span class="number">00100</span></div><div class="line">&gt;   <span class="number">00000</span></div><div class="line">&gt;   </div><div class="line">&gt;   Order <span class="number">3</span>:</div><div class="line">&gt;   <span class="number">0000000</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0111110</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0000000</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  <strong>Example1</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: N = <span class="number">5</span>, mines = [[<span class="number">4</span>, <span class="number">2</span>]]</div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11011</span></div><div class="line">&gt;   In the above grid, the largest plus sign can only be order <span class="number">2</span>.  One of them is marked in bold.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>  <strong>Example2</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: N = <span class="number">2</span>, mines = []</div><div class="line">&gt;   Output: <span class="number">1</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   There is no plus sign of order <span class="number">2</span>, but there is of order <span class="number">1</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>  <strong>Example3</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: N = <span class="number">1</span>, mines = [[<span class="number">0</span>, <span class="number">0</span>]]</div><div class="line">&gt;   Output: <span class="number">0</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   There is no plus sign, so <span class="keyword">return</span> <span class="number">0</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   动态规划，分别记录<span class="number">4</span>个方向上的最大连续<span class="number">1</span>的个数。比如”<span class="number">1001111</span>”， 每个位置出现的最大连续<span class="number">1</span>的个数分别为：”<span class="number">1001234</span>”，有了<span class="number">4</span>个方向的最长连续<span class="number">1</span>，order就是这四个方向的最小值，遍历每个位置的order，求出最大order即可。</div><div class="line">&gt;   设置<span class="number">4</span>个状态转移矩阵，lf[][],rt[][],dn[][],up[][]</div><div class="line">&gt;   如果当前的grid[i][j]=<span class="number">1</span>,那么</div><div class="line">&gt;   lf[i][j] = lf[i][j-<span class="number">1</span>]+<span class="number">1</span></div><div class="line">&gt;   rt、dn、up同理。</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(self, N, mines)</span>:</span></div><div class="line">&gt;           grid = [[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           <span class="keyword">for</span> mine <span class="keyword">in</span> mines:</div><div class="line">&gt;               a = mine[<span class="number">0</span>]</div><div class="line">&gt;               b = mine[<span class="number">1</span>]</div><div class="line">&gt;               grid[a][b] = <span class="number">0</span></div><div class="line">&gt;           lf = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           rt = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           dn = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           up = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</div><div class="line">&gt;                   <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</div><div class="line">&gt;                       lf[i][j] = <span class="number">1</span> <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">else</span> lf[i][j<span class="number">-1</span>]+<span class="number">1</span></div><div class="line">&gt;                   <span class="keyword">if</span> grid[j][i]==<span class="number">1</span>:<span class="comment">##trick</span></div><div class="line">&gt;                       dn[j][i] = <span class="number">1</span> <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">else</span> dn[j<span class="number">-1</span>][i]+<span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</div><div class="line">&gt;                   <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</div><div class="line">&gt;                       rt[i][j] = <span class="number">1</span> <span class="keyword">if</span> j==N<span class="number">-1</span> <span class="keyword">else</span> rt[i][j+<span class="number">1</span>]+<span class="number">1</span></div><div class="line">&gt;                   <span class="keyword">if</span> grid[j][i]==<span class="number">1</span>: <span class="comment">##trick</span></div><div class="line">&gt;                       up[j][i] = <span class="number">1</span> <span class="keyword">if</span> j==N<span class="number">-1</span> <span class="keyword">else</span> up[j+<span class="number">1</span>][i]+<span class="number">1</span></div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):<span class="comment">##使用min、max函数会超时</span></div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</div><div class="line">&gt;                   tre = lf[i][j]</div><div class="line">&gt;                   tre = rt[i][j] <span class="keyword">if</span> rt[i][j]&lt;tre <span class="keyword">else</span> tre</div><div class="line">&gt;                   tre = dn[i][j] <span class="keyword">if</span> dn[i][j]&lt;tre <span class="keyword">else</span> tre</div><div class="line">&gt;                   tre = up[i][j] <span class="keyword">if</span> up[i][j]&lt;tre <span class="keyword">else</span> tre</div><div class="line">&gt;                   re = tre <span class="keyword">if</span> tre&gt;re <span class="keyword">else</span> re</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote></blockquote>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Definition of Differential Privacy</title>
      <link href="/2018/05/25/DP-Definition/"/>
      <url>/2018/05/25/DP-Definition/</url>
      <content type="html"><![CDATA[<p>This post is about the definition of Differential Privacy. DP ensures privacy by randomness. So before the definition of DP, we need to know what is randomized algorithms.</p><p>In this post, Domain is represented as $\mathbb{N}^{|X|}$, where $|X|$ means the element number of the domain; Range is represented as $\mathbb{R}^{|k|}$, where $k$ means the element is $k$ dimentions.</p><p>Range(A) means the output of the mechanism A.</p><a id="more"></a><h2 id="Randomized-algorithms"><a href="#Randomized-algorithms" class="headerlink" title="Randomized algorithms"></a>Randomized algorithms</h2><p>In general, a randomized algorithm with domain $A$ and (discrete) range $B$ will be associated with a mapping from $A$ to the probability simplex over $B$, denoted $\Delta(B)$:</p><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 10.25.01 AM.png" alt="Screen Shot 2018-06-02 at 10.25.01 AM"></p><blockquote><ol><li></li><li></li></ol></blockquote><h2 id="Differential-Privacy"><a href="#Differential-Privacy" class="headerlink" title="Differential Privacy"></a>Differential Privacy</h2><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 10.31.11 AM.png" alt="Screen Shot 2018-06-02 at 10.31.11 AM"></p><blockquote><p>Remarks:</p><ol><li><p>Assuming the existence of a trusted and trustworthy curator who holds the data of individuals in a database </p></li><li><p>For particitants, differential privacy promises to protect individuals from any additional harm that they might face due to their data being in the private database x that they would not have faced had their data not been part of x. </p><p>For adversaries, differential privacy asserts that for all pairs of adjacent databases x, y and all outputs $o$, an adversary cannot distinguish which is the true database on the basis of observing $o$, which implies the adversary’s prior and posterior views about an individual should not be too different.</p></li><li><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 3.02.26 PM.png" alt="Screen Shot 2018-06-02 at 3.02.26 PM"></p></li><li><p>DP merely ensures that one’s participation in a survey will not in itself be disclosed, nor will participation lead to disclosure of any specifics that one has contributed to the survey. </p></li></ol></blockquote><h3 id="Understanding-of-DP-definition"><a href="#Understanding-of-DP-definition" class="headerlink" title="Understanding of DP definition"></a>Understanding of DP definition</h3><ol><li><p>How DP mean by saying it can limit the knowledge of adversaries by quering the database?</p><blockquote><p>According to the definition, $Pr(o|D)\le{e^{\epsilon}Pr(o|D’)}$, by observing the output $o$, the adversary cannot reliably infer whether the database is $D$ or $D’$, which means it cannot know whether someone is added or removed to the database. Indeed, the smaller the $\epsilon$ is, the closer the likehood ratio of $D$ to $D’$ is to 1. Therefore, when $\epsilon$ is small, the adversary cannot distinguish the true database.</p></blockquote></li></ol><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><blockquote><ol><li>Post-Processing : Differential privacy is immune to post-processing</li></ol></blockquote><h2 id="Vector-DP"><a href="#Vector-DP" class="headerlink" title="Vector DP"></a>Vector DP</h2><blockquote><p>This following details are from<a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a>.</p></blockquote><h2 id="Group-DP"><a href="#Group-DP" class="headerlink" title="Group DP"></a>Group DP</h2><blockquote><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 9.41.37 AM.png" alt="Screen Shot 2018-06-02 at 9.41.37 AM"></p><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-05-17 at 10.07.34 AM.png" alt="Screen Shot 2018-05-17 at 10.07.34 AM"></p><ol><li>the strength of the privacy guarantee drops linearly with the size of the group</li></ol></blockquote><h2 id="Event-VS-User"><a href="#Event-VS-User" class="headerlink" title="Event VS User"></a>Event VS User</h2><blockquote><p>Differential privacy promises that the behavior of an algorithm will be roughly unchanged even if a single entry in the database is modified. But what constitutes a single entry in the database? Consider for example a database that takes the form of a graph. Such a database might encode a social network: each individual i ∈ [n] is represented by a vertex in the graph, and friendships between<br>individuals are represented by edges.</p><p>We could consider differential privacy at a level of granularity corresponding to individuals: that is, we could require that differentially private algorithms be insensitive to the addition or removal of any vertex from the graph.</p><p>We could on the other hand consider differential privacy at a level of granularity corresponding to edges, and ask our algorithms to be insensitive only to the addition or removal of single, or small numbers of, edges from the graph.</p><p>As another example, a differentially private movie recommendation system can be designed to protect the data in the training set at the “<strong>event</strong>” level of single movies, hiding the viewing/rating of any single<br>movie but not, say, hiding an individual’s enthusiasm for cowboy westerns or gore, or at the “<strong>user</strong>” level of an individual’s entire viewing and rating history.</p></blockquote><h2 id="Non-interactive-VS-Interactive"><a href="#Non-interactive-VS-Interactive" class="headerlink" title="Non-interactive VS Interactive"></a>Non-interactive VS Interactive</h2><h3 id="Non-interactive"><a href="#Non-interactive" class="headerlink" title="Non-interactive"></a>Non-interactive</h3><blockquote><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-01 at 8.50.43 PM.png" alt="Screen Shot 2018-06-01 at 8.50.43 PM"></p></blockquote><h3 id="Interactive"><a href="#Interactive" class="headerlink" title="Interactive"></a>Interactive</h3><blockquote><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-01 at 8.51.55 PM.png" alt="Screen Shot 2018-06-01 at 8.51.55 PM"></p></blockquote><h2 id="Privacy-loss"><a href="#Privacy-loss" class="headerlink" title="Privacy loss"></a>Privacy loss</h2><blockquote><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 3.04.16 PM.png" alt="Screen Shot 2018-06-02 at 3.04.16 PM"></p></blockquote><h2 id="DP-Utility-Analysis"><a href="#DP-Utility-Analysis" class="headerlink" title="DP Utility Analysis"></a>DP Utility Analysis</h2><blockquote><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 3.11.05 PM.png" alt="Screen Shot 2018-06-02 at 3.11.05 PM"></p><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 3.11.19 PM.png" alt="Screen Shot 2018-06-02 at 3.11.19 PM"></p><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-02 at 3.12.22 PM.png" alt="Screen Shot 2018-06-02 at 3.12.22 PM"></p><p>This following details are from <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8319407" target="_blank" rel="noopener">[2018-Yang]</a>.</p><p><img src="/2018/05/25/DP-Definition/Users/daniel/Downloads/Nutstore/Git-PersonalWeb/QingWebsite/website/source/_posts/Definition-of-Differential-Privacy/2018-YANG.png" alt="2018-YANG"></p><p><img src="/2018/05/25/DP-Definition/Users/daniel/Downloads/Nutstore/Git-PersonalWeb/QingWebsite/website/source/_posts/Definition-of-Differential-Privacy/2018-YANG1.png" alt="2018-YANG1-7391264"></p></blockquote><h2 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h2><h3 id="Prupose"><a href="#Prupose" class="headerlink" title="Prupose"></a>Prupose</h3><ul><li>differential privacy aims to ensure that the output of the algorithm does not significantly depend on any particular individual’s data and ensures that an adversary should not be able to confidently infer whether a particular individual is present in a database even with access to every other entry in the database and an unbounded computational power. <a href="http://ceur-ws.org/Vol-1558/paper35.pdf" target="_blank" rel="noopener">[2016-Wang]</a></li></ul><h2 id="Adversary-Models"><a href="#Adversary-Models" class="headerlink" title="Adversary Models"></a>Adversary Models</h2><h3 id="2017-Mousumi"><a href="#2017-Mousumi" class="headerlink" title="[2017-Mousumi]"></a><a href="https://link.springer.com/content/pdf/10.1007%2F978-3-319-59870-3_14.pdf" target="_blank" rel="noopener">[2017-Mousumi]</a></h3><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-04 at 10.31.07 AM.png" alt="Screen Shot 2018-06-04 at 10.31.07 AM"></p><h3 id="2016-Chen"><a href="#2016-Chen" class="headerlink" title="[2016-Chen]"></a><a href="http://www.shivakasiviswanathan.com/ICDE16b.pdf" target="_blank" rel="noopener">[2016-Chen]</a></h3><p><img src="/2018/05/25/DP-Definition/Definition-of-Differential-Privacy/Screen Shot 2018-06-06 at 12.11.08 PM.png" alt="Screen Shot 2018-06-06 at 12.11.08 PM"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2014-To] A Framework for Protecting Worker Location Privacy in Spatial Crowdsourcing</p><p>[2018-Yang] Density-Based Location Preservation for Mobile Crowdsensing With Differential Privacy</p><p>[2016-Wang] Using Randomized Response for Differential Privacy Preserving Data Collection </p><p>[2017-Mousumi] Computing Aggregates Over Numeric Data with Personalized Local Differential Privacy</p><p>[2016-Chen] Private Spatial Data Aggregation in the Local Setting</p>]]></content>
      
      <categories>
          
          <category> Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Greedy Algorithm</title>
      <link href="/2018/05/23/Greedy-Algorithm/"/>
      <url>/2018/05/23/Greedy-Algorithm/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Commands</title>
      <link href="/2018/05/23/Hexo-Commands/"/>
      <url>/2018/05/23/Hexo-Commands/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-Basic-Commands"><a href="#Hexo-Basic-Commands" class="headerlink" title="Hexo Basic Commands"></a>Hexo Basic Commands</h1><h2 id="create-a-blog"><a href="#create-a-blog" class="headerlink" title="create a blog"></a>create a blog</h2><p>hexo n “name of blog” </p><h2 id="post-a-blog"><a href="#post-a-blog" class="headerlink" title="post a blog"></a>post a blog</h2><a id="more"></a><p>hexo  clean</p><p>hexo g</p><p>hexo d</p><h2 id="online-markdown"><a href="#online-markdown" class="headerlink" title="online markdown"></a>online markdown</h2><p>hexo server -d</p><h2 id="article-folding"><a href="#article-folding" class="headerlink" title="article folding"></a>article folding</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!-- more --&gt;</div></pre></td></tr></table></figure><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>create a new pages firstly: <strong>hexo new page tags</strong></p><p>opne new page and set its type as “tages”</p><h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><p>create a new pages firstly: <strong>hexo new page categories</strong></p><p>opne new page and set its type as “categories”</p><h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><p><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">[Insert mathematical formula in hexo articles]</a></p><h2 id="Pictures"><a href="#Pictures" class="headerlink" title="Pictures"></a>Pictures</h2><p><a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">[Insert pics in hexo articles]</a></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
