<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Mechanism of Differential Privacy</title>
      <link href="/2018/05/30/Mechanism-of-Differential-Privacy/"/>
      <url>/2018/05/30/Mechanism-of-Differential-Privacy/</url>
      <content type="html"><![CDATA[<h1 id="Laplace-Distribution"><a href="#Laplace-Distribution" class="headerlink" title="Laplace Distribution"></a>Laplace Distribution</h1><p>The following details are from <a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83" target="_blank" rel="noopener">Wikipedia</a>.</p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p><img src="/2018/05/30/Mechanism-of-Differential-Privacy/Screen Shot 2018-05-30 at 6.17.03 PM.png" alt="Screen Shot 2018-05-30 at 6.17.03 PM"></p><p><img src="/2018/05/30/Mechanism-of-Differential-Privacy/Laplace_distribution_pdf-7722463.png" alt="Laplace_distribution_pdf-7722463"></p><blockquote><ol><li>概率密度函数反映了概率在$ x$点处的密集程度。</li></ol></blockquote><h2 id="CDF"><a href="#CDF" class="headerlink" title="CDF"></a>CDF</h2><p><img src="/2018/05/30/Mechanism-of-Differential-Privacy/Screen Shot 2018-05-30 at 6.18.29 PM.png" alt="Screen Shot 2018-05-30 at 6.18.29 PM"></p><p><img src="/2018/05/30/Mechanism-of-Differential-Privacy/Laplace_distribution_cdf.png" alt="Laplace_distribution_cdf"></p>]]></content>
      
      <categories>
          
          <category> -Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Statistic 110</title>
      <link href="/2018/05/30/Statistic-110/"/>
      <url>/2018/05/30/Statistic-110/</url>
      <content type="html"><![CDATA[<h1 id="Lecture-1-Probability-and-Counting"><a href="#Lecture-1-Probability-and-Counting" class="headerlink" title="Lecture 1: Probability and Counting"></a>Lecture 1: Probability and Counting</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><strong>Sample space</strong>: a set of all possible outcomes of an experiment</p><p><strong>Event</strong>: a subset of the sample space</p><h1 id="Lecture-12-Discrete-vs-Continuous-the-Uniform"><a href="#Lecture-12-Discrete-vs-Continuous-the-Uniform" class="headerlink" title="Lecture 12: Discrete vs. Continuous, the Uniform"></a>Lecture 12: Discrete vs. Continuous, the Uniform</h1><h2 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h2><p><strong>PDF (Probability Density Function)</strong> : $X$ has PDF $f(x)$ if $P(a\le{X}\le{b})=\int_{a}^{b}f(x)$</p><p><strong>CDF (Cumulative Distribution Function)</strong> : if $X$ has PDF $f$, then the CDF is $F(X)=P(X\le{x})=\int_{-\infty}^{x}f(t)dt$</p><p><strong>Expectation</strong>: $E(X)=\int_{-\infty}^{\infty}xf(x)dx$</p><p><strong>Variance</strong>: $Var(X)=E(X-E(X))^2$</p><blockquote><p>$Var(X)=E(X^2-2X{E(X)}+E(X)^2)$</p><p>in above formular, because $2E(X)$ is a constant, so it can be outside, same thing with $E(X)^2$</p><p>$Var(X)=E(X^2)-2E(X)E(x)+E(X)^2=E(X^2)-E(X)^2$</p></blockquote><p><strong>Standard deviation</strong>: $SD(X)=\sqrt{Var(X)}$</p>]]></content>
      
      
        <tags>
            
            <tag> -Probability and Statistic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - Random Response</title>
      <link href="/2018/05/28/DP-Application-Random-Response/"/>
      <url>/2018/05/28/DP-Application-Random-Response/</url>
      <content type="html"><![CDATA[<p><a href="https://link.springer.com/content/pdf/10.1007%2F978-3-319-45871-7_17.pdf" target="_blank" rel="noopener">[2016-Atsushi]</a> gives a comprehensive survey about random response. Randomized response tends to be used in data collection scenario.Randomized response is purely a client-based privacy solution. It does not<br>rely upon a trusted third-party server and puts control over data back to clients. The basic idea is answer truthfully with probability $p$, and answer randomly by picking a answer from the rest choices with probability $1-p$. And the rest choices include the true answer.</p><h3 id="Random-Response-and-its-Variant"><a href="#Random-Response-and-its-Variant" class="headerlink" title="Random Response and its  Variant"></a>Random Response and its  Variant</h3><h4 id="Definition-2016-Wang"><a href="#Definition-2016-Wang" class="headerlink" title="Definition[2016-Wang]"></a>Definition<a href="http://ceur-ws.org/Vol-1558/paper35.pdf" target="_blank" rel="noopener">[2016-Wang]</a></h4><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 10.18.29 PM.png" alt="Screen Shot 2018-05-29 at 10.18.29 PM"></p><h4 id="Warner-Version"><a href="#Warner-Version" class="headerlink" title="Warner Version"></a>Warner Version</h4><p>Random response was first proposed by [1965-Warner]. The aim is to estimate the proportion $\pi(A)$ of people who have some attribute A.</p><h5 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h5><ol><li>There are red cards and non-red cards in a box, where the ratio of red cards among all the cards is $q$ with $0 &lt; q &lt; 1$ and $q \ne \frac{1}{2}$. And user draws a card.</li><li>If red, answer truthfully to the question “I am a member of A”</li><li>Otherwise, answer truthfully to the question “I am a member of A”</li></ol><h5 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h5><p>Let $\hat{T}$ be the proportion to which the respondents reply “True.” It is easy to see that the expectation of $\hat{T}$  is:</p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 12.40.16 AM.png" alt="Screen Shot 2018-05-29 at 12.40.16 AM"></p><h5 id="Privacy-Analysis"><a href="#Privacy-Analysis" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p>According to the definition of Differential Privacy, the following ratio should be bounded,</p><script type="math/tex; mode=display">P(A|A)\le{e^\epsilon{P(A|not \ A)}}\\P(A|not \ A)\le{e^\epsilon{P(A|A)}}</script><p>$P(A|A)=q​$</p><p>$P(A| not \ A)=(1-q)$</p><p>So combining the above two, we have:</p><p>The randomized response satisfied $\epsilon$-Differential Privacy, where</p><script type="math/tex; mode=display">\epsilon=max\{ln\frac{1-q}{q},ln\frac{q}{1-q}  \}</script><p><img src="/2018/05/28/DP-Application-Random-Response/myplot.jpeg" alt="myplot"></p><h4 id="Kuk-Version"><a href="#Kuk-Version" class="headerlink" title="Kuk Version"></a>Kuk Version</h4><p>Kuk’s proposed another kind of randomized response mechanism to estimate the proportion $\pi_A$, the same as Warner’s mechanism. </p><h5 id="Framework-1"><a href="#Framework-1" class="headerlink" title="Framework"></a>Framework</h5><ol><li>There are two boxes, $BOX_1$ and $BOX_2$. There are red and non-red cards in each box and the ratio of red cards in each box is $q_1,q_2$ respectively, where $0&lt;q_1,q_2&lt;1, q_1\ne{q_2}$. User takes one card from each box.</li><li>If this user is a member of A, then replies “red card” or “non-red card” in accordance<br>with the card taken from $BOX_1$</li><li>Otherwise, he does the same as above except that he takes a card from $BOX_2$.</li></ol><h5 id="Privacy-Analysis-1"><a href="#Privacy-Analysis-1" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.08.31 AM.png" alt="Screen Shot 2018-05-29 at 1.08.31 AM"></p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.08.51 AM.png" alt="Screen Shot 2018-05-29 at 1.08.51 AM"></p><h4 id="Negative-Survey-Mechanism"><a href="#Negative-Survey-Mechanism" class="headerlink" title="Negative Survey Mechanism"></a>Negative Survey Mechanism</h4><h5 id="Framework-2"><a href="#Framework-2" class="headerlink" title="Framework"></a>Framework</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.10.11 AM.png" alt="Screen Shot 2018-05-29 at 1.10.11 AM"></p><h5 id="Privacy-Analysis-2"><a href="#Privacy-Analysis-2" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.11.13 AM.png" alt="Screen Shot 2018-05-29 at 1.11.13 AM"></p><h4 id="t-times-Negative-Survey"><a href="#t-times-Negative-Survey" class="headerlink" title="t-times Negative Survey"></a>t-times Negative Survey</h4><h5 id="Privacy-Analysis-3"><a href="#Privacy-Analysis-3" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.12.13 AM-7574379.png" alt="Screen Shot 2018-05-29 at 1.12.13 AM-7574379"></p><p><img src="/2018/05/28/DP-Application-Random-Response/Screen Shot 2018-05-29 at 1.12.36 AM.png" alt="Screen Shot 2018-05-29 at 1.12.36 AM"></p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><h4 id="2011-Quercia"><a href="#2011-Quercia" class="headerlink" title="[2011-Quercia] "></a><a href="https://pdfs.semanticscholar.org/7e74/15857ddcc798affff74d7e615b0d29f6bf74.pdf" target="_blank" rel="noopener">[2011-Quercia] </a></h4><h5 id="Framework-3"><a href="#Framework-3" class="headerlink" title="Framework"></a>Framework</h5><p>[2011-Quercia] uses random response to obfuscate locations.</p><p>Let $k$ be the number of locations on a map. Then, the main part of SpotMe works as follows:</p><ol><li>the mobile phone chooses the location k uniformly at random with probability $p$</li><li>it chooses the true location with probability $1-p$</li></ol><h5 id="Privacy-Analysis-4"><a href="#Privacy-Analysis-4" class="headerlink" title="Privacy Analysis"></a>Privacy Analysis</h5><p>According to the definition of Differential Privacy, the following ratio should be bounded,</p><script type="math/tex; mode=display">P(L_{noise}|L_{true})\le{e^{\epsilon}P(L_{true}|L^{'}_{true})}</script><p>where $L_{true}$ is user’s actual location and $L^{‘}_{true}$ is the user’s location after making some changes while $L_{noise}$ is user’s obfuscated location.</p><p>$P(L_{true}|L_{true})=(1-p)+p*\frac{1}{k}$</p><p>$P(L_{true}|L^{‘}_{true})=p*\frac{1}{k}$</p><p>so after combining above two formulations, we have privacy bugdet:</p><script type="math/tex; mode=display">\epsilon=ln\frac{k-(k-1)p}{p}</script><p>[2011-Quercia] SpotME if you can: randomized responses for location obfuscation on mobile phones</p><p>[1965-Warner] Randomized response: a survey technique for eliminating evasive answer bias</p><p>[2016-Wang] Using Randomized Response for Differential Privacy Preserving Data Collection </p>]]></content>
      
      <categories>
          
          <category> -Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - Location Protection</title>
      <link href="/2018/05/27/DP-Application-Location-Protection/"/>
      <url>/2018/05/27/DP-Application-Location-Protection/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Setting"><a href="#Problem-Setting" class="headerlink" title="Problem Setting"></a>Problem Setting</h2><p>The goal of location with DP is that the chance of users being mapped to one specific obfuscated location from any of the actual locations is similar. The more similar the probability for each region is, the harder it is to infer users’ original positions, leading to better privacy protection.</p><h3 id="2013-Andres"><a href="#2013-Andres" class="headerlink" title="[2013-Andres]"></a><a href="http://www.lix.polytechnique.fr/~catuscia/papers/Geolocation/geo.pdf" target="_blank" rel="noopener">[2013-Andres]</a></h3><p>It performs as a probabilistic geo-obfuscation process, i.e., a user first obfuscates his<br>real location to another one according to a pre-configured<br>probability function P (encoding the probability of mapping<br>arbitrary location l to l∗) and then uploads the obfuscated<br>location to the server. The probability function is the key to<br>ensure differential privacy. The basic idea is that, suppose<br>the obfuscated location is l∗, for any two locations l1, l2,<br>their probability of being mapped to l∗ are similar. Then,<br>if an adversary observes a user u in l∗, he/she cannot distinguish whether u is actually in l1 or l2, even if he/she knows<br>the obfuscation function P . With this intuition, differential<br>privacy formally defines such similarity between any two<br>locations l1, l2 for arbitrary l∗.</p><p>The distance d(l1; l2) is introduced in the formulation to<br>reflect the intuition that if l1 and l2 are close to each other<br>(i.e., small d(l1; l2)), they should be more indistinguishable.Note that the set of locations L can be constructed by dividing the concerned area into a set of regions (of arbitrary<br>size) and selecting the representative locations of the regions<br>(e.g., geographic center)</p><h3 id="2014-Nicolas"><a href="#2014-Nicolas" class="headerlink" title="[2014-Nicolas]"></a><a href="https://arxiv.org/pdf/1402.5029.pdf" target="_blank" rel="noopener">[2014-Nicolas]</a></h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2013-Andres] Geo-indistinguishability: Differential privacy for location-based systems</p><p>[2014-Nicolas] Optimal geo-indistinguishable mechanisms for location privacy</p>]]></content>
      
      <categories>
          
          <category> -Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - Private Spatial Decompositions</title>
      <link href="/2018/05/26/DP-Application-Private-Spatial-Decompositions/"/>
      <url>/2018/05/26/DP-Application-Private-Spatial-Decompositions/</url>
      <content type="html"><![CDATA[<p><a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a> details the methods of Private Spatial Decompositions.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2014-To] A Framework for Protecting Worker Location Privacy in Spatial Crowdsourcing</p>]]></content>
      
      <categories>
          
          <category> -Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP Application - CroudSourcing</title>
      <link href="/2018/05/26/DP%20Application-CroudSourcing/"/>
      <url>/2018/05/26/DP%20Application-CroudSourcing/</url>
      <content type="html"><![CDATA[<p><a href="https://sigmodrecord.org/publications/sigmodRecord/1512/pdfs/05_surveys_Pournajaf.pdf" target="_blank" rel="noopener">[2015-Layla]</a> is a survey on the MobileCroudScoucing privacy.</p><p>Four factors in CroudSourcing:</p><blockquote><ol><li>sensing data quality, which tries to maximize the data quality measured by a certain metric (mostly used in environmental monitoring tasks)</li><li>incentive cost, which aims at minimizing the total budget (from the task organizer perspective)<br>for an MCS task with different incentive mechanisms, such as pay per participant or pay per task</li><li>energy consumption, whose objective is to identify an optimal collaborative data sensing and uploading scheme with energy-saving techniques such as piggybacking</li><li>travel distance, where the travel distance of a user for accomplishing a task is considered in task allocation, in order to minimize the overall travel distance for all the tasks.</li></ol></blockquote><h2 id="Task-Assignments-in-CroudSourcing"><a href="#Task-Assignments-in-CroudSourcing" class="headerlink" title="Task Assignments in CroudSourcing"></a>Task Assignments in CroudSourcing</h2><p>In croudsourcing, workers with mobile devices to collect data and send it to task requester for rewards.</p><p>In task assignment, organizers need participants’ precise locations for optimal task allocation. However, the exposure of their locations raises privacy concerns. Especially for those who are not eventually selected for any task, their location privacy is sacrificed in vain.</p><p>So in the differential privacy task assignment croudsourcing, the goal is to design a data release method that accurately represents the distribution of the workers and helps the Server efficiently match workers with tasks without compromising the privacy of their locations.</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="2014-To"><a href="#2014-To" class="headerlink" title="[2014-To]"></a><a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a></h3><p>it is the first one to solve this problem.</p><blockquote><ol><li><p>Framework</p><ul><li>Workers send their locations to a trusted cellular service provider(CSP) </li><li>CSP collects updates and releases a PSD according to privacy budget </li><li>When the SC-server receives a task t, it queries the PSD to determine a geocast region (GR), which is a unique feature of this work. Next, the SC-server initiates a geocast communication process to disseminate t to all workers within GR. Upon receiving request t, a worker w decides whether to perform the task or not.</li><li>Task assignment. <ul><li>Once server get a task request, server needs to query PSD to find a geocast region, balancing between high task assignment success rate and system overload like worker traveling distance and the number of  noticed worker. The author calculate maximum travel distance, models acceptance rate as the function of distance.</li><li>Geocast region construction. </li><li>Optimization. Including Partial Cell Selection and Communication Cost.</li></ul></li></ul></li><li><p>Privacy Model</p><ul><li><p>Privacy leakage: (1) workers disclose information to the task requester once they consent to the task; (2) completion of a task discloses the fact that some worker must have been at that location; (3) but this paper focuses on what happens prior to consent, when worker location and identity must be protected from both task requesters and the SC server.</p></li><li><p>the specific objective is to protect both the location and the identity of workers during task assignment. </p></li><li><p>Private Spatial Decom</p><ul><li><p>AG uses a two-level grid and variable cell granularity.</p></li><li><p>For the first-level, domain is divided into $m_1\times{m1}$ cells. For each level-1 cell, it is divided into $m_2\times{m2}$ subcells. </p><script type="math/tex; mode=display">m1 = max(10,\lceil{\frac{1}{4}\sqrt{\frac{N\times{\epsilon_1}}{k_1=10}}}\rceil)\\m_2=\lceil{\sqrt{\frac{N'\times{\epsilon_2}}{k_2=5}}}\rceil</script></li><li><p>$k_2$ selection. $k_2$ controls the granularity of level-2 domain and small one leads to compactness in level-2 subcells. </p></li><li><p>improving $m_2$</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.27.05 PM.png" alt="Screen Shot 2018-05-30 at 12.27.05 PM"></p></li></ul></li></ul></li></ol></blockquote><h3 id="2018-Yang"><a href="#2018-Yang" class="headerlink" title="[2018-Yang]"></a><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8319407" target="_blank" rel="noopener">[2018-Yang]</a></h3><p>it criticizes that <a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a> is based on the assumption that workers are uniformly distributed within the domain and and the workers in each cell have the same acceptance rate. So they proposes a workers density-based method.</p><blockquote><ol><li>Framework<ul><li>Workers must submit their location to the CSP, travel to the location designated for the task and collect data using their sensor-equipped device.</li><li>The CSP collects locations from workers and releases data in sanitized form to the Server for task assignment. There is a trust relationship between CSP and workers.</li><li>The Server queries the CSP for a sanitized dataset once it receives a task, where server chooses a geocast region GR to disseminate the task to the workers in GR. It then assigns the task to suitable workers, through the CSP, according to a task assignment algorithm.</li></ul></li><li>Modules<ul><li>Using quadtree to partition the region based on worker density.  But the authors change this method so that the partitioning is based on the worker density instead of choosing the middle point.</li><li>Partitioning point selection. Before partitioning, <code>m</code> initial points are randomly generated within the cell, ==============================(TODO)</li><li>Differential privacy data release. A noisy count of the number of workers in each cell is released to protect the privacy of worker locations, where whether or not a worker<br>within a specific cell cannot be identified.</li><li>Task assignment. Firstly, teh geocast region is selected based on task assignment success rate and system overhead (the distance workers need to travel and the number of workers notified of the task).</li></ul></li><li>Privacy Model<ul><li>The basic idea of private data release is that the domain of worker locations is partitioned into small cells and Laplace noise is added to the count of workers in each cell to achieve a differential privacy guarantee.</li><li>Pervious literature assumes the worker locations are distributed uniformly, and the workers in each cell have the same acceptance rate, which is not the case in real-world scenarios. Partitioning the data domain into a uniform grid would result in sizeable errors. Therefore, we propose a recursive partitioning process based on worker density. </li><li>The aim is to identify dense regions and sparse regions and make the distribution of the workers in each smaller region as near to uniform as possible.</li><li>Adopting data-independent quadtree into workers density-based data-independent technique. <ul><li>Partitioning stop condition. Traditional quadtrees require the data publisher to specify the height of the partitioning. In this paper, the process stops if (1) no workers exist in the cell; (2) the area of cell is less than some threshold, The smaller the cell, the more uniform the distribution of workers within it; (3) the distribution of workers in a cell is relatively uniform， which is measures by the threshold of maximum density difference.</li><li>First, $m$ initial partition points in the location domain need to be selected, where $m=\frac{\sqrt{area \ of \ cell}}{\alpha}$</li><li>check condition (1) and (2), which is the number of points in cell is greater than 0 and the area of cell is greater than the threshold. If one of answers is no, stop partitioning.</li><li>for each partitioning point, calculate the density of the subcells divided by this point. choose the point which has the maximum density difference bbetween subcells.</li><li>If the biggest density difference is greater than the threshold β, the cell is partitioned at point. Otherwise, the cell will not be partitioned as the distribution of worker in the cell is already close to uniform. For example, the density of four subcells is 1, 2, 1, 2, which means in each subcells, there are 1, 2, 1 and 2 points in each subcell, which is kind of uniform distribution in the cell.</li></ul></li></ul></li></ol></blockquote><h3 id="2017-Wang"><a href="#2017-Wang" class="headerlink" title="[2017-Wang]"></a><a href="http://papers.www2017.com.au.s3-website-ap-southeast-2.amazonaws.com/proceedings/p627.pdf" target="_blank" rel="noopener">[2017-Wang]</a></h3><blockquote><ol><li><p>Framework</p><ul><li>Platform-side Geo-Obfuscation Function Generation</li><li>User-side Location Obfuscation</li><li>Platform-side Obfuscation-aware Task Allocation</li></ul></li><li><p>Privacy Model</p><p>Overall, the aurhor models workers’ travel distance to task locations as the function of geo-obfuscation function and task allocation. And by calculating the optimal function, we can get the Geo-Obfuscation matrix which satisfies DP and task allocation schemes.</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 10.06.41 AM.png" alt="Screen Shot 2018-05-30 at 10.06.41 AM"></p><ul><li><p>the expected travel distance of assigning a task at $l_t$ to a user at (obfuscated) $l*$ given the geo-obfuscation function $P$.</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 10.18.25 AM.png" alt="Screen Shot 2018-05-30 at 10.18.25 AM"></p></li><li><p>optimal function</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 10.55.21 AM.png" alt="Screen Shot 2018-05-30 at 10.55.21 AM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 11.05.55 AM.png" alt="Screen Shot 2018-05-30 at 11.05.55 AM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 10.56.24 AM.png" alt="Screen Shot 2018-05-30 at 10.56.24 AM"></p></li><li><p>task allocation</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 11.07.06 AM.png" alt="Screen Shot 2018-05-30 at 11.07.06 AM"></p></li><li><p>Candidate Geo-Distribution Estimation</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 11.10.54 AM.png" alt="Screen Shot 2018-05-30 at 11.10.54 AM"></p></li><li><p>Laplace</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 11.27.15 AM.png" alt="Screen Shot 2018-05-30 at 11.27.15 AM"></p></li><li><p>Geo-distribution Estimation</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 11.50.49 AM.png" alt="Screen Shot 2018-05-30 at 11.50.49 AM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 11.50.57 AM.png" alt="Screen Shot 2018-05-30 at 11.50.57 AM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 11.51.05 AM.png" alt="Screen Shot 2018-05-30 at 11.51.05 AM"></p></li></ul></li></ol></blockquote><h2 id="Data-Sensing-in-CroudSourcing"><a href="#Data-Sensing-in-CroudSourcing" class="headerlink" title="Data Sensing in CroudSourcing"></a>Data Sensing in CroudSourcing</h2><h3 id="Solutions-1"><a href="#Solutions-1" class="headerlink" title="Solutions"></a>Solutions</h3><h3 id="2016-Wang"><a href="#2016-Wang" class="headerlink" title="[2016-Wang]"></a><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7837982" target="_blank" rel="noopener">[2016-Wang]</a></h3><p>In this paper, instead of studying task assignment, the author focuses on sparse croudsensing. Due to large target sensing area and limited budget which result in insufficient spatial coverage of mobile users, sparse mobile croudsensing impute information of the uncovered regions by combining historical records with available sensing data from nearby regions.</p><blockquote><ol><li>Framework<ul><li>The server side generates probabilistic obfuscation matrix and data adjustment function in an offline way.</li><li>user sider senses its actual location and then maps the associated region to another region according to probabilistic obfuscation matrix. After that, the data adjustment function alters the original sensing data to fit the properties of the obfuscated region. Finally, mobile client then uploads the modified region and data to the server.</li><li>The server side does data inference : modeled as a matrix completion problem, where each element in the matrix is the value like temperature of a region at time t. In this paper, they use compressive sensing theory for inference.</li></ul></li><li><p>Privacy Model</p><ul><li><p>Privacy leakage : In Sparse MCS, participants report the sensing data with time stamps and geographical coordinates, which may introduce serious privacy risks. </p></li><li><p>Data utility: Due to location obfuscation, the uploaded region data is not actual value of this region, so adjustment is needed to decrease data utility loss. the data quality loss is determined by the difference of sensing data between the actual and the obfuscated locations, instead of the geographic distance. In other words, a participant’s location may be mapped to a place far away, as long as the sensing values of the two locations are close enough.</p></li><li><p>Adversary model - Bayesian attack</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.10.00 PM.png" alt="Screen Shot 2018-05-30 at 12.10.00 PM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.10.48 PM.png" alt="Screen Shot 2018-05-30 at 12.10.48 PM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.11.49 PM.png" alt="Screen Shot 2018-05-30 at 12.11.49 PM"></p></li><li><p>optimal function</p><p>The authors model the sensing data quality loss as the function of location obfuscation matrix.</p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.20.20 PM.png" alt="Screen Shot 2018-05-30 at 12.20.20 PM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.22.12 PM.png" alt="Screen Shot 2018-05-30 at 12.22.12 PM"></p><p><img src="/2018/05/26/DP Application-CroudSourcing/Screen Shot 2018-05-30 at 12.22.56 PM.png" alt="Screen Shot 2018-05-30 at 12.22.56 PM"></p></li></ul></li></ol></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2014-To] A Framework for Protecting Worker Location Privacy in Spatial Crowdsourcing</p><p>[2018-Yang] Density-Based Location Preservation for Mobile Crowdsensing With Differential Privacy</p><p>[2016-Wang] Differential Location Privacy for Sparse Mobile Crowdsensing</p><p>[2015-Layla] Participant privacy in mobile crowd sensing task management: A survey of methods and challenges</p>]]></content>
      
      <categories>
          
          <category> -Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2018/05/26/Dynamic-Programming/"/>
      <url>/2018/05/26/Dynamic-Programming/</url>
      <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>这篇文章详细记录<a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a>上各种难度的动态规划题目。每道题我都给出题目，思路以及Python代码。</p><a id="more"></a><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p><p>首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？ 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p><p>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p><p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p><p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p><p><strong>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</strong></p><h3 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746.Min Cost Climbing Stairs"></a>746.Min Cost Climbing Stairs</h3><blockquote><ul><li><p>题目</p><p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p><p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>]</div><div class="line">&gt;   Output: <span class="number">6</span></div><div class="line">&gt;   Explanation: Cheapest <span class="keyword">is</span> start on cost[<span class="number">0</span>], <span class="keyword">and</span> only step on <span class="number">1</span>s, skipping cost[<span class="number">3</span>].</div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: cost = [<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</div><div class="line">&gt;   Output: <span class="number">15</span></div><div class="line">&gt;   Explanation: Cheapest <span class="keyword">is</span> start on cost[<span class="number">1</span>], pay that cost <span class="keyword">and</span> go to the top.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>典型动态规划，且只需要一维dp数组维护，考虑到可以从index=0|1开始，所以在dp数组前面插入两个0(因为是加法，乘法则插入1)，同时要表示终点，则在dp尾再插入一个0，统计到达top时的cost。</p></li><li><p>代码</p><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold"><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type cost: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           lcost = len(cost)</div><div class="line">&gt;           cost.append(<span class="number">0</span>)</div><div class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(lcost+<span class="number">3</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(dp)):</div><div class="line">&gt;               dp[i] = min(dp[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]) + cost[i<span class="number">-2</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote></div></div></li></ul></blockquote><h3 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h3><blockquote><ul><li><p>题意</p><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="number">2</span></div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: There are two ways to climb to the top.</div><div class="line">&gt;   <span class="number">1.</span> <span class="number">1</span> step + <span class="number">1</span> step</div><div class="line">&gt;   <span class="number">2.</span> <span class="number">2</span> steps</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: There are three ways to climb to the top.</div><div class="line">&gt;   <span class="number">1.</span> <span class="number">1</span> step + <span class="number">1</span> step + <span class="number">1</span> step</div><div class="line">&gt;   <span class="number">2.</span> <span class="number">1</span> step + <span class="number">2</span> steps</div><div class="line">&gt;   <span class="number">3.</span> <span class="number">2</span> steps + <span class="number">1</span> step</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>跟上面一题很相似了，同样是一维，也需要在首个插入</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           l = n+<span class="number">1</span></div><div class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l):</div><div class="line">&gt;               dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h3><blockquote><ul><li><p>题意</p><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</div><div class="line">&gt;   Output: <span class="number">6</span></div><div class="line">&gt;   Explanation: [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6.</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>一维dp数组，同样在前面插入0，但是返回的时候，要小心不能返回max(dp)，而是max(dp[1:])，防止input是[-1,-2].</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l+<span class="number">1</span>):</div><div class="line">&gt;               dp[i] = max(nums[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>])</div><div class="line">&gt;           <span class="keyword">return</span> max(dp[<span class="number">1</span>:])</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h3><blockquote><ul><li><p>题目</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</div><div class="line">&gt;                Total amount you can rob = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">2</span>), rob house <span class="number">4</span> (money = <span class="number">2</span>) Total amount you can rob = <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>dp状态思考错误，dp[i]表示抢到第i个房子时，目前获取的最大利润</p><p>dp状态转移方程，有点错误。错误以为不能抢劫相邻的房子意味着抢的房子之间必须相隔一个房子，其实可以中间可以相隔多个房子不抢。</p><p>则dp转移方程为：即要不要抢当前的房子</p><p>dp[i] = max( dp[i-1] , dp[i-2] + nums[i] )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l+<span class="number">1</span>):</div><div class="line">&gt;               dp[i] = max(nums[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>], dp[i<span class="number">-1</span>])</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><p>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p><p>正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p><p>让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p><p><strong>d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i]</strong></p><p>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p><h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h3><blockquote><ul><li><p>题目</p><p><script type="math/tex">m \times {n}</script>的矩阵，从（0，0）位置走到（m，n）位置共有多少走法</p></li><li><p>思路</p><p>二维dp，dp[i][j]记录到达位置（i,j）共有的走法，dp[i][j]=dp[i-1][j]+dp[i][j-1].</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type m: int</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">&gt;               dp[<span class="number">0</span>][i] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</div><div class="line">&gt;                   dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h3><blockquote><ul><li><p>题目</p><p>同样是[m,n]矩阵，但是有1表示障碍，不能过，0为空白可以过去。</p></li><li><p>思路</p><p>dp[i][j]仍然是可能的走法数，但是在初始化时，如果当前是障碍，则dp[][]=0.否则依赖于前面一个。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type obstacleGrid: List[List[int]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid : <span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           m = len(obstacleGrid)</div><div class="line">&gt;           n = len(obstacleGrid[<span class="number">0</span>])</div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span> <span class="comment">##update</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m): <span class="comment">##update</span></div><div class="line">&gt;               dp[i][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> dp[i<span class="number">-1</span>][<span class="number">0</span>] <span class="keyword">and</span> <span class="keyword">not</span> obstacleGrid[i][<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):<span class="comment">##update</span></div><div class="line">&gt;               dp[<span class="number">0</span>][i] = <span class="number">1</span> <span class="keyword">if</span> dp[<span class="number">0</span>][i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>][i] <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</div><div class="line">&gt;                   <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</div><div class="line">&gt;                       dp[i][j] = <span class="number">0</span></div><div class="line">&gt;                   <span class="keyword">else</span>:</div><div class="line">&gt;                       dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h3><blockquote><ul><li><p>题目</p><p>从矩阵的左上角走到右下角，矩阵上元素值为代价，求最小代价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Input:</div><div class="line">&gt;   [</div><div class="line">&gt;     [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</div><div class="line">&gt;     [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</div><div class="line">&gt;     [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</div><div class="line">&gt;   ]</div><div class="line">&gt;   Output: <span class="number">7</span></div><div class="line">&gt;   Explanation: Because the path <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> minimizes the sum.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>完全捡苹果题目，需要注意的是创建dp数组时，len_row在外层，len_column在内层。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type grid: List[List[int]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l1 = len(grid)</div><div class="line">&gt;           l2 = len(grid[<span class="number">0</span>])</div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l2)] <span class="keyword">for</span> j <span class="keyword">in</span> range(l1)] <span class="comment">###l2在里面，l1在外面</span></div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2):</div><div class="line">&gt;               dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2):</div><div class="line">&gt;                   temp = dp[i][j<span class="number">-1</span>] <span class="keyword">if</span> dp[i][j<span class="number">-1</span>]&lt;dp[i<span class="number">-1</span>][j] <span class="keyword">else</span> dp[i<span class="number">-1</span>][j]</div><div class="line">&gt;                   dp[i][j] = temp + grid[i][j]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h3><blockquote><ul><li><p>题目</p><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   [</div><div class="line">&gt;        [<span class="number">2</span>],</div><div class="line">&gt;       [<span class="number">3</span>,<span class="number">4</span>],</div><div class="line">&gt;      [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</div><div class="line">&gt;     [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</div><div class="line">&gt;   ]</div><div class="line">&gt;   The minimum path sum from top to bottom is <span class="number">11</span> (i.e., <span class="number">2</span> + <span class="number">3</span> + <span class="number">5</span> + <span class="number">1</span> = <span class="number">11</span>).</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>与捡苹果很相似，有两种想法，首先dp[i][j]表示到达需要的最少步数。那么状态转移方程有两种想法：</p><p>一种是：dp[i][j]出发有两种走法，dp[i+1][j]和dp[i+1][j+1]，更新到达后的状态dp[i+1][j]和dp[i+1][j+1]；</p><p>另一种是dp[i][j]有两种到达的方法，dp[i-1][j]和dp[i-1][j-1]，更新dp[i][j]</p><p>但是觉得第一种方法比较容易，因为第二种要考虑边界</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type triangle: List[List[int]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> triangle:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(triangle)</div><div class="line">&gt;           dp = [[ sys.maxsize <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle[j])) ] <span class="keyword">for</span> j <span class="keyword">in</span> range(l) ]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[i])):</div><div class="line">&gt;                   dp[i+<span class="number">1</span>][j] = dp[i+<span class="number">1</span>][j] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j] &lt; (dp[i][j]+triangle[i+<span class="number">1</span>][j]) <span class="keyword">else</span> (dp[i][j]+triangle[i+<span class="number">1</span>][j])</div><div class="line">&gt;                   dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] &lt; (dp[i][j]+triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]) <span class="keyword">else</span> (dp[i][j]+triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</div><div class="line">&gt;           <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h3><blockquote><ul><li><p>题目</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: You cannot rob house <span class="number">1</span> (money = <span class="number">2</span>) and then rob house <span class="number">3</span> (money = <span class="number">2</span>),</div><div class="line">&gt;                because they are adjacent houses.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</div><div class="line">&gt;                Total amount you can rob = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>房子排成了一个圆圈，则如果抢了第一家，就不能抢最后一家，因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢。则把数组分成两份，分别使用动态规划求解。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">if</span> len(nums)==<span class="number">1</span>:<span class="keyword">return</span> nums[<span class="number">0</span>]</div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           dp2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           dp1[<span class="number">1</span>] = nums[<span class="number">0</span>]</div><div class="line">&gt;           dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l):</div><div class="line">&gt;               dp1[i] = max(dp1[i<span class="number">-1</span>],dp1[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>])</div><div class="line">&gt;               dp2[i] = max(dp2[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>]+nums[i])</div><div class="line">&gt;           <span class="keyword">return</span> max(dp1[<span class="number">-1</span>],dp2[<span class="number">-1</span>])</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h3><blockquote><ul><li><p>题目</p><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: n = <span class="number">12</span></div><div class="line">&gt;   Output: <span class="number">3</span> </div><div class="line">&gt;   Explanation: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: n = <span class="number">13</span></div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li><li><p>思路</p><p>这道题就是找零钱。只是零钱的选取是有限的，而这边完美数是无限的，但是要小于n。故遍历零钱数组的操作，需要变成while循环，遍历每一个完美数。</p><p>dp[i]表示最少需要的数字凑成这个数，直到n。两层循环。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="comment">###LeetCode下Python3是超时，Python2可以</span></div><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [sys.maxsize <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</div><div class="line">&gt;               j = <span class="number">1</span></div><div class="line">&gt;               <span class="keyword">while</span> j*j&lt;=i:</div><div class="line">&gt;                   dp[i] = min(dp[i],dp[i-j*j]+<span class="number">1</span>)</div><div class="line">&gt;                   j = j + <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;           </div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h3><blockquote><ul><li><p>题目</p><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p></li><li><p>思路</p><p>如果动态规划，则时间复杂度是$O(n^2)$, 第一层循环来更新dp，第二个循环来遍历之前的数字且必须比当前小，不能等于。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</div><div class="line">&gt;                   <span class="keyword">if</span> nums[j]&lt;nums[i] <span class="keyword">and</span> dp[i] &lt; dp[j]+<span class="number">1</span>:</div><div class="line">&gt;                       dp[i] = dp[j]+<span class="number">1</span></div><div class="line">&gt;           <span class="keyword">return</span> max(dp)</div><div class="line">&gt;           </div><div class="line">&gt;           </div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="comment">###二分查找的复杂度是O(log(n)),则整体复杂度是O(nlong(n))</span></div><div class="line">&gt;   <span class="keyword">import</span> bisect</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           sorted_list = []</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">&gt;               pos = bisect.bisect_left(sorted_list,i)</div><div class="line">&gt;               <span class="keyword">if</span> pos==len(sorted_list):</div><div class="line">&gt;                   sorted_list.append(i)</div><div class="line">&gt;               <span class="keyword">else</span>:</div><div class="line">&gt;                   sorted_list[pos] = i</div><div class="line">&gt;           <span class="keyword">return</span> len(sorted_list)</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h3><blockquote><ul><li><p>题目</p><p>换硬币，但是可能失败，即没有1元银币，导致凑不够。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></div><div class="line">&gt;   <span class="keyword">return</span> <span class="number">3</span> (<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span>)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   coins = [<span class="number">2</span>], amount = <span class="number">3</span></div><div class="line">&gt;   <span class="keyword">return</span> -<span class="number">1</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>两层遍历，dp[i]表示凑够i元需要的最少银币数量。疑惑点是如何处理凑不够的情况，返回-1.事实上，只要有提供1元银币，一定可以凑够。那就判断dp[1]是否有更新。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type coins: List[int]</span></div><div class="line"><span class="string">&gt;           :type amount: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [sys.maxsize <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</div><div class="line">&gt;           re[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,amount+<span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</div><div class="line">&gt;                   <span class="keyword">if</span> coin &lt;= i:</div><div class="line">&gt;                       <span class="keyword">if</span> dp[i] &gt; dp[i-coin]+<span class="number">1</span>:</div><div class="line">&gt;                           dp[i] = dp[i-coin]+<span class="number">1</span></div><div class="line">&gt;           <span class="keyword">if</span> dp[<span class="number">-1</span>] == sys.maxsize:</div><div class="line">&gt;               <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">&gt;           <span class="keyword">else</span>:</div><div class="line">&gt;               <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h3><blockquote><ul><li><p>题目</p><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   For num = <span class="number">5</span> you should <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>].</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>可以使用动态规划，时间复杂度是$O(n)$. 显然dp[i]表示数字里面含有的1的个数。但是状态转移如何表示？计算i的时候，如何利用dp[0]-dp[i-1]呢？利用➗2，即右移操作。一个数右移一位，变成较小的数字，失去的是最右的1或者0.则状态转移变成了</p><p>dp[i] = dp[i&gt;&gt;1] + i%2</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type num: int</span></div><div class="line"><span class="string">&gt;           :rtype: List[int]</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(num+<span class="number">1</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,num+<span class="number">1</span>):</div><div class="line">&gt;               dp[i] = dp[i//<span class="number">2</span>] + i%<span class="number">2</span></div><div class="line">&gt;           <span class="keyword">return</span> dp</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="comment">###利用Python内置函数。</span></div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type num: int</span></div><div class="line"><span class="string">&gt;           :rtype: List[int]</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">return</span> [bin(x).count(<span class="string">'1'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(num+<span class="number">1</span>)]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h3><blockquote><ul><li><p>题目</p><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;   nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&gt;   target = <span class="number">4</span></div><div class="line">&gt;   </div><div class="line">&gt;   The possible combination ways are:</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line">&gt;   (<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">&gt;   (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">&gt;   (<span class="number">2</span>, <span class="number">2</span>)</div><div class="line">&gt;   (<span class="number">3</span>, <span class="number">1</span>)</div><div class="line">&gt;   </div><div class="line">&gt;   Note that different sequences are counted as different combinations.</div><div class="line">&gt;   </div><div class="line">&gt;   Therefore the output is <span class="number">7</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  <strong>Follow up:</strong> What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?</p><ul><li><p>思路</p><p>就是找银币了。但是不同于找硬币，其状态转移是dp[i] = dp[i-j] + 1；该问题的状态转移是dp[i] += dp[i-1]</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :type target: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> target == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;<span class="number">0</span>:</div><div class="line">&gt;               dif = <span class="number">1</span> - nums[<span class="number">0</span>]</div><div class="line">&gt;               target += dif</div><div class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">&gt;                   nums[i] += dif</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> nums:</div><div class="line">&gt;                   <span class="keyword">if</span> j &lt;= i:</div><div class="line">&gt;                       dp[i] += dp[i - j]</div><div class="line">&gt;           print(dp)</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a>343. Integer Break</h3><blockquote><ul><li><p>题目</p><p>Given a positive integer <em>n</em>, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given <em>n</em> = 2, return 1 (2 = 1 + 1); given <em>n</em> = 10, return 36 (10 = 3 + 3 + 4).</p><p><strong>Note</strong>: You may assume that <em>n</em> is not less than 2 and not larger than 58.</p></li><li><p>思路</p><p>动态规划时间复杂度$O(n)$.难点在于状态转移方程，dp[i]表示i的因数的最大乘积。想到dp[i] = max( dp[i] , dp[j] <em> (i-j) )，其实本质就是将i先分解成（【j】  </em> 【i-j】），但是j可以再分解，同样i-j也可以再分解，选择大的。</p><p>即max（ j , dp[j] ）* max（i-j ，dp[i-j]）</p><p>故状态转移方程是：</p><p>dp[i] = max ( dp[i] , max（ j , dp[j] ）* max（i-j ，dp[i-j]） )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</div><div class="line">&gt;                   dp[i] = max (dp[i], max(dp[j],j)*max(dp[i-j],i-j))</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><p>接下来，让我们来看看如何解决二维的DP问题。</p><p>平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。</p><p>解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。</p><p>首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是， 到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果， 我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解)</p><p>经过上面的分析，很容易可以得出问题的状态和状态转移方程。 状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么， 状态转移方程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">S[i][j]=A[i][j] + max(S[i-<span class="number">1</span>][j], <span class="keyword">if</span> i&gt;<span class="number">0</span> ; S[i][j-<span class="number">1</span>], <span class="keyword">if</span> j&gt;<span class="number">0</span>)</div></pre></td></tr></table></figure><p>$S[i][j]$有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算$S[i][j]$时，$S[i-1][j]$和$S[i][j-1]$都已经计算出来了。</p><h3 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a><em><u>221. Maximal Square</u></em></h3><blockquote><ul><li><p>题目</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: </div><div class="line">&gt;   </div><div class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></div><div class="line">&gt;   <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></div><div class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></div><div class="line">&gt;   </div><div class="line">&gt;   Output: <span class="number">4</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>想不到用dp解决。</p><p>dp[i][j]表示以点[i][j]为右下角顶点的正方形的边长。为了构成全1正方形，该点必须是1，那么如何利用已经计算好的dp状态更新当前dp状态呢？即如何根据该点拓展正方形？与它上方，左方和左上方三个点有关。</p><p>当我们判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角，否则该点为右下角的正方形最大就是它自己了。这是定性的判断，那具体的最大正方形边长呢？我们知道，该点为右下角的正方形的最大边长，最多比它的上方，左方和左上方为右下角的正方形的边长多1，最好的情况是是它的上方，左方和左上方为右下角的正方形的大小都一样的，这样加上该点就可以构成一个更大的正方形。但如果它的上方，左方和左上方为右下角的正方形的大小不一样，合起来就会缺了某个角落，这时候只能取那三个正方形中最小的正方形的边长加1了。假设<code>dp[i][j]</code>表示以i,j为右下角的正方形的最大边长，则有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + <span class="number">1</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type matrix: List[List[str]]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           row = len(matrix)</div><div class="line">&gt;           column = len(matrix[<span class="number">0</span>])</div><div class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(column) ] <span class="keyword">for</span> i <span class="keyword">in</span> range(row) ]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = int(matrix[i][<span class="number">0</span>])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(column):</div><div class="line">&gt;               dp[<span class="number">0</span>][i] = int(matrix[<span class="number">0</span>][i])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,row):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,column):</div><div class="line">&gt;                   <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</div><div class="line">&gt;                       dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</div><div class="line">&gt;               re = max(re,max(dp[i]))</div><div class="line">&gt;           <span class="keyword">return</span> re * re <span class="comment">### re != max(max(dp))</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h3><blockquote><ul><li><p>题目</p><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">5</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   Given n = <span class="number">3</span>, there are a total of <span class="number">5</span> unique BST<span class="string">'s:</span></div><div class="line"><span class="string">&gt;   </span></div><div class="line"><span class="string">&gt;      1         3     3      2      1</span></div><div class="line"><span class="string">&gt;       \       /     /      / \      \</span></div><div class="line"><span class="string">&gt;        3     2     1      1   3      2</span></div><div class="line"><span class="string">&gt;       /     /       \                 \</span></div><div class="line"><span class="string">&gt;      2     1         2                 3</span></div><div class="line"><span class="string">&gt;</span></div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>不会想到用动态规划。但是知道可以dp，有大致的想法，我最初认为dp[i]表示数字1，2，…，i能形成的二叉树的数量。这样在状态转移的时候就有麻烦了。其实，与数字大小无关，即dp[i]也可以是9，10，11，…，i+9形成的二叉树，实际上，dp[i]状态表示的是i个有序上升点能形成的二叉树个数。这样问题就简单了。状态转移：</p><p>dp[i] += dp[j-1] * dp[i-j] 遍历j从1-i，表示以j为顶点形成的二叉树。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> n</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</div><div class="line">&gt;                   dp[i] += dp[j<span class="number">-1</span>] * dp[i-j] <span class="comment">## += 且 j-1</span></div><div class="line">&gt;           print(dp)</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h3><blockquote><ul><li><p>题目</p><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="string">'A'</span> -&gt; <span class="number">1</span></div><div class="line">&gt;   <span class="string">'B'</span> -&gt; <span class="number">2</span></div><div class="line">&gt;   ...</div><div class="line">&gt;   <span class="string">'Z'</span> -&gt; <span class="number">26</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"12"</span></div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: It could be decoded as <span class="string">"AB"</span> (<span class="number">1</span> <span class="number">2</span>) or <span class="string">"L"</span> (<span class="number">12</span>).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"226"</span></div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: It could be decoded as <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), or <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>).</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>可以想到用dp，但是一直纠结于dp的维数。</p><p>dp[i]表示1-i字符串的decode种类，那么状态转移方程呢？与具体的字符串有关。因为数字只能是一位或者两位，且一位的数字不能是0.那么如果当前的数字是0，那么不能以一位解码；否则可以以该种方式解码，则dp[i] += dp[i-1];如果i-1和i的两位数是合法的，即位于10和26之间，那么是可以以两位数解码，dp[i] += dp[i-2] </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   dp[i] = </div><div class="line">&gt;       <span class="number">0</span>                   <span class="keyword">if</span> s[i] and s[i-<span class="number">1</span>][i] invalid</div><div class="line">&gt;       dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]   <span class="keyword">if</span> s[i] and s[i-<span class="number">1</span>][i] valid</div><div class="line">&gt;       dp[i-<span class="number">1</span>]             <span class="keyword">if</span> s[i] valid</div><div class="line">&gt;       dp[i-<span class="number">2</span>]             <span class="keyword">if</span> s[i-<span class="number">1</span>][i] valid</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type s: str</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(s)</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l + <span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] !=<span class="string">'0'</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</div><div class="line">&gt;               one_digit = s[i]</div><div class="line">&gt;               two_digit = int(s[i - <span class="number">1</span>:i + <span class="number">1</span>])</div><div class="line">&gt;               <span class="keyword">if</span> one_digit != <span class="string">'0'</span>:</div><div class="line">&gt;                   dp[i + <span class="number">1</span>] += dp[i]</div><div class="line">&gt;               <span class="keyword">if</span> two_digit &lt;= <span class="number">26</span> <span class="keyword">and</span> two_digit &gt;= <span class="number">10</span>:</div><div class="line">&gt;                   dp[i + <span class="number">1</span>] += dp[i - <span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a>368. Largest Divisible Subset</h3><blockquote><ul><li><p>题目</p><p>Given a set of <strong>distinct</strong> positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p><p>If there are multiple solutions, return any subset is fine.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">&gt;   </div><div class="line">&gt;   Result: [<span class="number">1</span>,<span class="number">2</span>] (of course, [<span class="number">1</span>,<span class="number">3</span>] will also be ok)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</div><div class="line">&gt;   </div><div class="line">&gt;   Result: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>题目是很复杂了，而且不会想到用dp，因为这边求解的是list，而非极值。看了网上代码，还是em。</p><p>首先不论返回的list，单纯看最大的可以是多大，因为取余有个性质，i&gt;j&gt;k, i % j = 0，j % k = 0, 那么i % k = 0.所以给了dp状态转移的思路，</p><p>dp[i]表示数字i以及i之前的数组能形成的最大子集，状态的更新只需要考虑i之前的数字能否取余为零</p><p>dp[i] = max( dp[i] , dp[j] +1 ) if i % j == 0</p><p>接下来难点就是如何记录结果list，当然我们可以设置一个二维数组来保存，一旦更新dp的时候，也要更新对应的list，即把i值加上上一个list中。但是我们可以把$O(n^2)$的空间复杂度变成$D(n)$, pre[i]记录i之前能取余且得到最大的子集的元素的下标。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   https:<span class="comment">//www.cnblogs.com/godlei/p/5621990.html</span></div><div class="line">&gt;   </div><div class="line">&gt;   如果a%b==<span class="number">0</span>，则a=mb，所以如果把数组排序后如果a%b==<span class="number">0</span>，且b%c==<span class="number">0</span>则a%c==<span class="number">0</span>。这就为用动态规划实现提供了可能性。设置一个数组result，result[i]表示i出包含的满足条件的子集个数。则如果nums[i]%nums[j]==<span class="number">0</span>，则result[i]=result[j]+<span class="number">1</span>;同时由于函数要返回的是一个List，所以我们要保存最长集合的路径。这个功能可以通过设置一个pre数组保存能被nums[i]整除的上一个数的索引。并在保存max值的同时保存max所在的位置maxIndex即可。</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: List[int]</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</div><div class="line">&gt;           nums = sorted(nums)</div><div class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]  <span class="comment">##表示集合元素个数,初始是1，表示至少自己单独成为合法的集合</span></div><div class="line">&gt;           size_max = <span class="number">1</span></div><div class="line">&gt;           index_max = <span class="number">0</span></div><div class="line">&gt;           pre = [<span class="number">-1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</div><div class="line">&gt;                   <span class="keyword">if</span> nums[i] % nums[j] == <span class="number">0</span> <span class="keyword">and</span> dp[i] &lt; dp[j] + <span class="number">1</span>:</div><div class="line">&gt;                       dp[i] = dp[j] + <span class="number">1</span></div><div class="line">&gt;                       pre[i] = j <span class="comment">##</span></div><div class="line">&gt;                       <span class="keyword">if</span> dp[i]&gt;size_max: <span class="comment">## 等于也ok</span></div><div class="line">&gt;                           size_max = dp[i]</div><div class="line">&gt;                           index_max = i</div><div class="line">&gt;           re = []</div><div class="line">&gt;           <span class="keyword">while</span> index_max != <span class="number">-1</span>:</div><div class="line">&gt;               re.append(nums[index_max])</div><div class="line">&gt;               index_max = pre[index_max]</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a>740. Delete and Earn</h3><blockquote><p>题目</p><p>Given an array <code>nums</code> of integers, you can perform operations on the array.</p><p>In each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. After, you must delete <strong>every</strong> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt; Example1:</div><div class="line">&gt; Input: nums = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</div><div class="line">&gt; Output: <span class="number">6</span></div><div class="line">&gt; Explanation: </div><div class="line">&gt; Delete <span class="number">4</span> to earn <span class="number">4</span> points, consequently <span class="number">3</span> is also deleted.</div><div class="line">&gt; Then, delete <span class="number">2</span> to earn <span class="number">2</span> points. <span class="number">6</span> total points are earned.</div><div class="line">&gt; </div><div class="line">&gt; Example2:</div><div class="line">&gt; Input: nums = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&gt; Output: <span class="number">9</span></div><div class="line">&gt; Explanation: </div><div class="line">&gt; Delete <span class="number">3</span> to earn <span class="number">3</span> points, deleting both <span class="number">2</span><span class="string">'s and the 4.</span></div><div class="line"><span class="string">&gt; Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span></div><div class="line"><span class="string">&gt; 9 total points are earned.</span></div><div class="line"><span class="string">&gt;</span></div></pre></td></tr></table></figure><ul><li><p>思路</p><p>这道题本质上就是198题House Rober。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> collections</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">deleteAndEarn</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type nums: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           dic = collections.Counter(nums)</div><div class="line">&gt;           N = max(nums)</div><div class="line">&gt;           new_nums = []</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>): <span class="comment">#防止情况[3,1]</span></div><div class="line">&gt;               v = dic[i] <span class="keyword">if</span> i <span class="keyword">in</span> dic.keys() <span class="keyword">else</span> <span class="number">0</span></div><div class="line">&gt;               new_nums.append(i*v)</div><div class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(new_nums)+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">1</span>] = new_nums[<span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(new_nums)):</div><div class="line">&gt;               dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+new_nums[i])</div><div class="line">&gt;           <span class="keyword">return</span> max(dp)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="718-Maximum-Length-of-Repeated-Subarray"><a href="#718-Maximum-Length-of-Repeated-Subarray" class="headerlink" title="718. Maximum Length of Repeated Subarray"></a>718. Maximum Length of Repeated Subarray</h3><blockquote><ul><li><p>题目</p><p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;   Input:</div><div class="line">&gt;   A: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</div><div class="line">&gt;   B: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The repeated subarray with maximum length is [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].</div><div class="line">&gt;</div></pre></td></tr></table></figure></li><li><p>思路</p><p>经典动态规划。A[i]：表示A的子串0-i，B[j]：表示B的子串0-j</p><p>dp[i][j]：A的子串与B的子串最长重合，状态更新dp[i][j] = dp[i-1][j-1] + 1 if 两个子串的最后字符相同</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, A, B)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type A: List[int]</span></div><div class="line"><span class="string">&gt;           :type B: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           la = len(A)</div><div class="line">&gt;           lb = len(B)</div><div class="line">&gt;           dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(la+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(lb+<span class="number">1</span>) ]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(la):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(lb):</div><div class="line">&gt;                   <span class="keyword">if</span> A[i]==B[j]:</div><div class="line">&gt;                       dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">return</span> max(max(row) <span class="keyword">for</span> row <span class="keyword">in</span> dp)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Minimum-ASCII-Delete-Sum-for-Two-Strings-712"><a href="#Minimum-ASCII-Delete-Sum-for-Two-Strings-712" class="headerlink" title="Minimum ASCII Delete Sum for Two Strings(712)"></a>Minimum ASCII Delete Sum for Two Strings(712)</h3><blockquote><ul><li><p>题目</p><p>Given two strings <code>s1, s2</code>, find the lowest ASCII sum of deleted characters to make two strings equal. All elements of each string will have an ASCII value in <code>[97, 122]</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: s1 = <span class="string">"sea"</span>, s2 = <span class="string">"eat"</span></div><div class="line">&gt;   Output: <span class="number">231</span></div><div class="line">&gt;   Explanation: Deleting <span class="string">"s"</span> from <span class="string">"sea"</span> adds the ASCII value of <span class="string">"s"</span> (<span class="number">115</span>) to the sum.</div><div class="line">&gt;   Deleting <span class="string">"t"</span> from <span class="string">"eat"</span> adds <span class="number">116</span> to the sum.</div><div class="line">&gt;   At the end, both strings are equal, and <span class="number">115</span> + <span class="number">116</span> = <span class="number">231</span> is the minimum sum possible to achieve <span class="keyword">this</span>.</div><div class="line">&gt;   </div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: s1 = <span class="string">"delete"</span>, s2 = <span class="string">"leet"</span></div><div class="line">&gt;   Output: <span class="number">403</span></div><div class="line">&gt;   Explanation: Deleting <span class="string">"dee"</span> from <span class="string">"delete"</span> to turn the string into <span class="string">"let"</span>,</div><div class="line">&gt;   adds <span class="number">100</span>[d]+<span class="number">101</span>[e]+<span class="number">101</span>[e] to the sum.  Deleting <span class="string">"e"</span> from <span class="string">"leet"</span> adds <span class="number">101</span>[e] to the sum.</div><div class="line">&gt;   At the end, both strings are equal to <span class="string">"let"</span>, and the answer is <span class="number">100</span>+<span class="number">101</span>+<span class="number">101</span>+<span class="number">101</span> = <span class="number">403</span>.</div><div class="line">&gt;   If instead we turned both strings into <span class="string">"lee"</span> or <span class="string">"eet"</span>, we would get answers of <span class="number">433</span> or <span class="number">417</span>, which are higher.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li><li><p>思路</p><p>这道题就是LCS (Longest Common Subsequence).</p><p>在LCS中，<code>d[i][j]</code>表示<code>s1.substring(0,i)</code>和<code>s2.substring(0,j)</code>的LCS的长度, 那么</p><p><code>d[i][j]</code>=<code>d[i-1][j-1]</code>+1                                    if <code>s1[i-1]</code> == <code>s2[j-1]</code></p><p><code>d[i][j]</code>=max(<code>d[i-1][j]</code>, <code>d[i]]j-1</code>)              if <code>s1[i-1]</code> != <code>s2[j-1]</code></p><p>那么在本题背景下，<code>d[i][j]</code>表示<code>s1.substring(0,i)</code>和<code>s2.substring(0,j)</code>删除若干个字符后相等的最小<code>cost</code>，那么</p><p><code>d[i][j]</code>=<code>d[i-1][j-1]</code>+0                                                                        if <code>s1[i-1]</code> == <code>s2[j-1]</code></p><p><code>d[i][j]</code>=min(<code>d[i-1][j]</code>+<code>s1[i-1]</code>, <code>d[i]]j-1</code>+<code>s2[j-1]</code>)              if <code>s1[i-1]</code> != <code>s2[j-1]</code></p><p>但是，这道题需要和718题的Maximum Length of Repeated Subarray作个比较,因为718题的状态转移方程是：</p><p><code>d[i][j]</code>=<code>d[i-1][j-1]</code>+1          if <code>s1[i-1]</code> == <code>s2[j-1]</code> </p><p><code>d[i][j]</code>=0                                     if <code>s1[i-1]</code> != <code>s2[j-1]</code></p><p>差异在于 if <code>s1[i-1]</code> != <code>s2[j-1]</code>，在718中，一旦不等，意味着连续的相等的子串已经消失，则当前的计算得重新开始，重点是“连续”</p><p>而在本题以及LCS中，一旦不等，不必重新开始，因为没有要求“连续”，大不了跳过这个不等，则当前不等的计算就依赖于前面</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span><span class="params">(self, s1, s2)</span>:</span></div><div class="line">&gt;           mv = sys.maxsize</div><div class="line">&gt;           l1 = len(s1)</div><div class="line">&gt;           l2 = len(s2)</div><div class="line">&gt;           dp = [[ mv <span class="keyword">for</span> _ <span class="keyword">in</span> range(l2+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l1):</div><div class="line">&gt;               dp[i + <span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>]+ord(s1[i])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l2):</div><div class="line">&gt;               dp[<span class="number">0</span>][i + <span class="number">1</span>] = dp[<span class="number">0</span>][i]+ord(s2[i])</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1+<span class="number">1</span>):</div><div class="line">&gt;                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2+<span class="number">1</span>):</div><div class="line">&gt;                   <span class="keyword">if</span> s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]:</div><div class="line">&gt;                       dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</div><div class="line">&gt;                   <span class="keyword">else</span>:</div><div class="line">&gt;                       dp[i][j] = min(dp[i<span class="number">-1</span>][j]+ord(s1[i<span class="number">-1</span>]) , dp[i][j<span class="number">-1</span>]+ord(s2[j<span class="number">-1</span>]))</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Knight-Probability-in-Chessboard-688"><a href="#Knight-Probability-in-Chessboard-688" class="headerlink" title="Knight Probability in Chessboard(688)"></a>Knight Probability in Chessboard(688)</h3><blockquote><ul><li><p>题目</p><p>On an <code>N</code>x<code>N</code> chessboard, a knight starts at the <code>r</code>-th row and <code>c</code>-th column and attempts to make exactly <code>K</code> moves. The rows and columns are 0 indexed, so the top-left square is <code>(0, 0)</code>, and the bottom-right square is <code>(N-1, N-1)</code>.</p><p>A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p><p><img src="/2018/05/26/Dynamic-Programming/knight.png" alt=""></p><p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p><p>The knight continues moving until it has made exactly <code>K</code> moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.</p></li><li><p>思路</p><p><code>dp[i][j][k]</code>:表示经过<code>k</code>次移动之后，knight到达位置<code>[i,j]</code>的所有可能方法数。那么状态转移有两种，一种是如果knight当前位置是<code>[i][j]</code>,且当前是第<code>k</code>次移动，那么更新下一次从当前<code>[i][j]</code>位置可能到达的其他位置<code>dp[i+x][j+y][k+1]</code>;另一种是当前位置是<code>[i][j]</code>,且当前是第<code>k</code>次移动，那么上一次<code>k-1</code>移动是如何到达当前位置。</p><p>本代码实现第一种方法，因为当前状态只与上一次状态有关，所以通过降维，使用<code>dp0[]</code>和<code>dp1[]</code>表示<code>k-1</code>和<code>k</code>的可能性，’状态转移是:</p><p><code>dp1[i][j] += dp0[i+x][j+y]</code></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">knightProbability</span><span class="params">(self, N, K, r, c)</span>:</span></div><div class="line">&gt;           dp0 = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           dp0[r][c] = <span class="number">1</span></div><div class="line">&gt;           dirs = [[<span class="number">-2</span>,<span class="number">-1</span>],[<span class="number">-2</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">-2</span>],[<span class="number">-1</span>,<span class="number">-2</span>]]</div><div class="line">&gt;           <span class="keyword">for</span> step <span class="keyword">in</span> range(K):</div><div class="line">&gt;               dp1 = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</div><div class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;                   <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</div><div class="line">&gt;                       <span class="keyword">for</span> d <span class="keyword">in</span> dirs:</div><div class="line">&gt;                           x = i+d[<span class="number">0</span>]</div><div class="line">&gt;                           y = j+d[<span class="number">1</span>]</div><div class="line">&gt;                           <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;N<span class="number">-1</span> <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> y&gt;N<span class="number">-1</span>:</div><div class="line">&gt;                               <span class="keyword">pass</span></div><div class="line">&gt;                           <span class="keyword">else</span>:</div><div class="line">&gt;                               dp1[x][y] += dp0[i][j]</div><div class="line">&gt;               dp0 = dp1</div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;               re += sum(dp0[i])</div><div class="line">&gt;           <span class="keyword">return</span> re/(<span class="number">8</span>**K)</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Number-of-Longest-Increasing-Subsequence-673"><a href="#Number-of-Longest-Increasing-Subsequence-673" class="headerlink" title="Number of Longest Increasing Subsequence(673)"></a>Number of Longest Increasing Subsequence(673)</h3><blockquote><ul><li><p>题目</p><p>Given an unsorted array of integers, find the number of longest increasing subsequence.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation: The two longest increasing subsequence are [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>] and [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>].</div><div class="line">&gt;       </div><div class="line">&gt;   Example2:</div><div class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</div><div class="line">&gt;   Output: <span class="number">5</span></div><div class="line">&gt;   Explanation: The length of longest continuous increasing subsequence is <span class="number">1</span>, and there are <span class="number">5</span> subsequences<span class="string">' length is 1, so output 5.</span></div><div class="line"><span class="string">&gt;       </span></div><div class="line"><span class="string">&gt;   Example3:</span></div><div class="line"><span class="string">&gt;   Input: [1,2,4,2,3]</span></div><div class="line"><span class="string">&gt;   Output: 3</span></div><div class="line"><span class="string">&gt;   Explanation: The two longest increasing subsequence are [1, 2, 4] and [1, 2, 3] and [1, 2, 3].</span></div><div class="line"><span class="string">&gt;</span></div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>dp[i]表示子串S[0] - S[i-1]的最长上升子串长度。动态转移方程是dp[i] = max (dp[i], dp[j] + 1), j 的范围是[0, i-1]。所以代码实现时，需要双重循环。但是，我们还需要记录一个构成最长子串的方式数。比如子串【1，2，4，2，3】，最长上升子串长度是3，但是有两种方式实现，【1，2，3】(2来自于index=1)和【1，2，3】[2来自于index=3]。</p><p>dp[i][2]:dp[i][0]表示子串S[0] - S[i-1]的最长上升子串长度，dp[i][1]第二维记录构成该最长子串的方式数</p><p>if dp[i][0]&gt;dp[j][1]  then dp[i][0] = dp[j][0] + 1, dp[i][1]  = dp[i][1] </p><p>else if dp[i][0]==dp[j][1]  then dp[i][1]  += dp[i][1] </p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span><span class="params">(self, nums)</span>:</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums :<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           l = len(nums)</div><div class="line">&gt;           max_len = <span class="number">1</span></div><div class="line">&gt;           dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</div><div class="line">&gt;                   <span class="keyword">if</span> nums[i] &gt; nums[j]:</div><div class="line">&gt;                       <span class="keyword">if</span> dp[i][<span class="number">0</span>]&lt;dp[j][<span class="number">0</span>] + <span class="number">1</span>:</div><div class="line">&gt;                           dp[i][<span class="number">0</span>] = dp[j][<span class="number">0</span>] + <span class="number">1</span></div><div class="line">&gt;                           dp[i][<span class="number">1</span>] = dp[j][<span class="number">1</span>]</div><div class="line">&gt;                           max_len = max(max_len,dp[i][<span class="number">0</span>])</div><div class="line">&gt;                       <span class="keyword">elif</span> dp[i][<span class="number">0</span>] == dp[j][<span class="number">0</span>] + <span class="number">1</span>:</div><div class="line">&gt;                           dp[i][<span class="number">1</span>] += dp[j][<span class="number">1</span>]</div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">&gt;               <span class="keyword">if</span> dp[i][<span class="number">0</span>]==max_len:</div><div class="line">&gt;                   re+=dp[i][<span class="number">1</span>]</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><h3 id="2-Keys-Keyboard"><a href="#2-Keys-Keyboard" class="headerlink" title="2 Keys Keyboard"></a>2 Keys Keyboard</h3><blockquote><ul><li><p>题目</p><p>Initially on a notepad only one character ‘A’ is present. You can perform two operations on this notepad for each step:</p><ol><li><code>Copy All</code>: You can copy all the characters present on the notepad (partial copy is not allowed).</li><li><code>Paste</code>: You can paste the characters which are copied <strong>last time</strong>.</li></ol><p>Given a number <code>n</code>. You have to get <strong>exactly</strong> <code>n</code> ‘A’ on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get <code>n</code> ‘A’.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;   Example1:</div><div class="line">&gt;   </div><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">3</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   Intitally, we have one character <span class="string">'A'</span>.</div><div class="line">&gt;   In step <span class="number">1</span>, we use Copy All operation.</div><div class="line">&gt;   In step <span class="number">2</span>, we use Paste operation to get <span class="string">'AA'</span>.</div><div class="line">&gt;   In step <span class="number">3</span>, we use Paste operation to get <span class="string">'AAA'</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li>思路</li></ul><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, n)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type n: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           mv = sys.maxsize</div><div class="line">&gt;           <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></div><div class="line">&gt;           dp = [mv <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i):</div><div class="line">&gt;                   <span class="keyword">if</span> i%j == <span class="number">0</span>:</div><div class="line">&gt;                       dp[i] = min(dp[i],dp[j] + i//j)</div><div class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><h3 id="Out-of-Boundary-Paths-576"><a href="#Out-of-Boundary-Paths-576" class="headerlink" title="Out of Boundary Paths(576)"></a>Out of Boundary Paths(576)</h3><ul><li><p>题目</p><p>There is an <strong>m</strong> by <strong>n</strong> grid with a ball. Given the start coordinate <strong>(i,j)</strong> of the ball, you can move the ball to <strong>adjacent</strong> cell or cross the grid boundary in four directions (up, down, left, right). However, you can <strong>at most</strong> move <strong>N</strong> times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.</p><p><img src="/2018/05/26/Dynamic-Programming/Screen Shot 2018-05-29 at 8.25.29 PM.png" alt="Screen Shot 2018-05-29 at 8.25.29 PM"></p></li></ul><ul><li><p>思路</p><p><a href="http://www.cnblogs.com/grandyang/p/6927921.html" target="_blank" rel="noopener">参考</a></p><p>这道题给了我们一个二维的数组，某个位置放个足球，每次可以在上下左右四个方向中任意移动一步，总共可以移动N步，问我们总共能有多少种移动方法能把足球移除边界，由于结果可能是个巨大的数，所以让我们对一个大数取余。那么我们知道对于这种结果很大的数如果用递归解法很容易爆栈，所以最好考虑使用DP来解。那么我们使用一个三维的DP数组，其中dp[k][i][j]表示总共走k步，从(i,j)位置走出边界的总路径数。那么我们来找递推式，对于dp[k][i][j]，走k步出边界的总路径数等于其周围四个位置的走k-1步出边界的总路径数之和，如果周围某个位置已经出边界了，那么就直接加上1，否则就在dp数组中找出该值，这样整个更新下来，我们就能得出每一个位置走任意步数的出界路径数了，最后只要返回dp[N][i][j]就是所求结果了，参见代码如下.</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(self, m, n, N, i, j)</span>:</span></div><div class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]<span class="comment">##N+1是为了防止出现N=0情况。</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> ii <span class="keyword">in</span> range(m):</div><div class="line">                <span class="keyword">for</span> jj <span class="keyword">in</span> range(n):</div><div class="line">                    v1 = <span class="number">1</span> <span class="keyword">if</span> ii==<span class="number">0</span> <span class="keyword">else</span> dp[ii<span class="number">-1</span>][jj][k<span class="number">-1</span>]</div><div class="line">                    v2 = <span class="number">1</span> <span class="keyword">if</span> ii==m<span class="number">-1</span> <span class="keyword">else</span> dp[ii+<span class="number">1</span>][jj][k<span class="number">-1</span>]</div><div class="line">                    v3 = <span class="number">1</span> <span class="keyword">if</span> jj==<span class="number">0</span> <span class="keyword">else</span> dp[ii][jj<span class="number">-1</span>][k<span class="number">-1</span>]</div><div class="line">                    v4 = <span class="number">1</span> <span class="keyword">if</span> jj==n<span class="number">-1</span> <span class="keyword">else</span> dp[ii][jj+<span class="number">1</span>][k<span class="number">-1</span>]</div><div class="line">                    dp[ii][jj][k] = (v1+v2+v3+v4)%<span class="number">1000000007</span></div><div class="line">        <span class="keyword">return</span> dp[i][j][N]</div></pre></td></tr></table></figure></li></ul><h3 id="Longest-Palindromic-Subsequence-516-—for-Length"><a href="#Longest-Palindromic-Subsequence-516-—for-Length" class="headerlink" title="Longest Palindromic Subsequence(516)—for(Length)"></a><em><u>Longest Palindromic Subsequence(516)—for(Length)</u></em></h3><ul><li><p>题目</p><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Example1:</div><div class="line"></div><div class="line">Input:<span class="string">"bbbab"</span> Output:<span class="number">4</span> </div><div class="line">One possible longest palindromic subsequence is <span class="string">"bbbb"</span>.</div><div class="line"></div><div class="line">Example2:</div><div class="line">Input:<span class="string">"cbbd"</span> Output:<span class="number">2</span> </div><div class="line">One possible longest palindromic subsequence is <span class="string">"bb"</span>.</div></pre></td></tr></table></figure></li><li><p>思路</p><p>dp[i][j]表示字符串s[i…j]的最长回文串长度。</p><p>dp[i][j] = 1 表示单个单个字符s[i]就是一个回文串</p><p>dp[i][j] = dp[i+1][j-1] + 2 if s[i]==s[j], else</p><p>dp[i][j] = max (dp[i+1][j], dp[i][j-1])</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type s: str</span></div><div class="line"><span class="string">        :rtype: int</span></div><div class="line"><span class="string">        """</span></div><div class="line">        l = len(s)</div><div class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">            dp[i][i] = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> ll <span class="keyword">in</span> range(<span class="number">1</span>,l+<span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,l-ll):</div><div class="line">                j = i+ll</div><div class="line">                <span class="keyword">if</span> s[i]==s[j]:</div><div class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j] &gt; dp[i][j<span class="number">-1</span>] <span class="keyword">else</span> dp[i][j<span class="number">-1</span>]</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][l<span class="number">-1</span>]</div></pre></td></tr></table></figure></li></ul><h3 id="Predict-the-Winner-486-—for-Length"><a href="#Predict-the-Winner-486-—for-Length" class="headerlink" title="Predict the Winner(486)—for(Length)"></a>Predict the Winner(486)—for(Length)</h3><ul><li><p>题目</p><p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p><p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Example1:</div><div class="line"></div><div class="line">Input: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]</div><div class="line">Output: False</div><div class="line">Explanation: Initially, player <span class="number">1</span> can choose between <span class="number">1</span> and <span class="number">2</span>. </div><div class="line">If he chooses <span class="number">2</span> (or <span class="number">1</span>), then player <span class="number">2</span> can choose from <span class="number">1</span> (or <span class="number">2</span>) and <span class="number">5</span>. If player <span class="number">2</span> chooses <span class="number">5</span>, then player <span class="number">1</span> will be left with <span class="number">1</span> (or <span class="number">2</span>). </div><div class="line">So, <span class="keyword">final</span> score of player <span class="number">1</span> is <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span>, and player <span class="number">2</span> is <span class="number">5</span>. </div><div class="line">Hence, player <span class="number">1</span> will never be the winner and you need to <span class="keyword">return</span> False.</div><div class="line"></div><div class="line">Example2:</div><div class="line"></div><div class="line">Input: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">233</span>, <span class="number">7</span>]</div><div class="line">Output: True</div><div class="line">Explanation: Player <span class="number">1</span> first chooses <span class="number">1</span>. Then player <span class="number">2</span> have to choose between <span class="number">5</span> and <span class="number">7</span>. No matter which number player <span class="number">2</span> choose, player <span class="number">1</span> can choose <span class="number">233</span>.</div><div class="line">Finally, player <span class="number">1</span> <span class="function">has more <span class="title">score</span> <span class="params">(<span class="number">234</span>)</span> than player 2 <span class="params">(<span class="number">12</span>)</span>, so you need to return True representing player1 can win.</span></div></pre></td></tr></table></figure></li><li><p>思路</p><p>dp[i][j]表示子串s[i…j]供选择时两个玩家间的总分数差，无论是玩家1还是玩家2，都希望最大化差异，那么状态转移就是：</p><p>dp[i][j] = max(nums[i] - dp[i+1][j] , nums[j] - dp[i][j-1])</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PredictTheWinner</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type nums: List[int]</span></div><div class="line"><span class="string">        :rtype: bool</span></div><div class="line"><span class="string">        """</span></div><div class="line">        l = len(nums)</div><div class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">            dp[i][i] = nums[i]</div><div class="line">        <span class="keyword">for</span> dis <span class="keyword">in</span> range(<span class="number">1</span>,l):  <span class="comment">#the distance between index of i and j</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l-dis):</div><div class="line">                j = i+dis</div><div class="line">                dp[i][j] = nums[i]-dp[i+<span class="number">1</span>][j] <span class="keyword">if</span> nums[i]-dp[i+<span class="number">1</span>][j]&gt;nums[j]-dp[i][j<span class="number">-1</span>] <span class="keyword">else</span> nums[j]-dp[i][j<span class="number">-1</span>]</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][l<span class="number">-1</span>]&gt;=<span class="number">0</span></div></pre></td></tr></table></figure></li></ul><h3 id="Target-Sum-494"><a href="#Target-Sum-494" class="headerlink" title="Target Sum(494)"></a>Target Sum(494)</h3><ul><li><p>题目</p><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p><p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Input: nums is [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S is <span class="number">3</span>. </div><div class="line">Output: <span class="number">5</span></div><div class="line">Explanation: </div><div class="line"></div><div class="line">-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></div><div class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span> = <span class="number">3</span></div><div class="line"></div><div class="line">There are <span class="number">5</span> ways to assign symbols to make the sum of nums be target <span class="number">3</span>.</div></pre></td></tr></table></figure></li><li><p>思路</p></li></ul><ul><li>代码</li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="801-Minimum-Swaps-To-Make-Sequences-Increasing"><a href="#801-Minimum-Swaps-To-Make-Sequences-Increasing" class="headerlink" title="801. Minimum Swaps To Make Sequences Increasing"></a><em><u>801. Minimum Swaps To Make Sequences Increasing</u></em></h3><blockquote><ul><li><p>题目</p><p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p><p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>.  Note that both elements are in the same index position in their respective sequences.</p><p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing.  (A sequence is <em>strictly increasing</em> if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p><p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example:</div><div class="line">&gt;   Input: A = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>], B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</div><div class="line">&gt;   Output: <span class="number">1</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   Swap A[<span class="number">3</span>] and B[<span class="number">3</span>].  Then the sequences are:</div><div class="line">&gt;   A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] and B = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&gt;   which are both strictly increasing.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>文字  <a href="https://blog.csdn.net/magicbean2/article/details/79826617" target="_blank" rel="noopener">https://blog.csdn.net/magicbean2/article/details/79826617</a> </p><p>图片  <a href="http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-801-minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-801-minimum-swaps-to-make-sequences-increasing/</a></p><p> 这道题实在是太难了，不过看图片还是可以稍微有点顺畅。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minSwap</span><span class="params">(self, A, B)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type A: List[int]</span></div><div class="line"><span class="string">&gt;           :type B: List[int]</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           mv = sys.maxsize</div><div class="line">&gt;           l = len(A)</div><div class="line">&gt;           keep = [mv <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           swap = [mv <span class="keyword">for</span> j <span class="keyword">in</span> range(l)]</div><div class="line">&gt;           keep[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">&gt;           swap[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 初始是1，不是0，因为意味着A[0]和B[0]交换一次</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l):</div><div class="line">&gt;               a1 = A[i<span class="number">-1</span>]</div><div class="line">&gt;               b1 = B[i<span class="number">-1</span>]</div><div class="line">&gt;               a2 = A[i]</div><div class="line">&gt;               b2 = B[i]</div><div class="line">&gt;               <span class="keyword">if</span> a1 &lt; a2 <span class="keyword">and</span> b1 &lt; b2:</div><div class="line">&gt;                   keep[i] = keep[i<span class="number">-1</span>] <span class="comment"># no swap for both i-1, i</span></div><div class="line">&gt;                   swap[i] = swap[i<span class="number">-1</span>] + <span class="number">1</span> <span class="comment"># swap for both i-1, i; swap[i-1] means swap i-1, 1 means swap i</span></div><div class="line">&gt;               <span class="keyword">if</span> a1 &lt; b2 <span class="keyword">and</span> b1 &lt; a2:</div><div class="line">&gt;                   keep[i] = min(keep[i], swap[i<span class="number">-1</span>])</div><div class="line">&gt;                   swap[i] = min(swap[i], keep[i<span class="number">-1</span>]+<span class="number">1</span>)</div><div class="line">&gt;           <span class="keyword">return</span> min(keep[<span class="number">-1</span>],swap[<span class="number">-1</span>])</div><div class="line">&gt;           </div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="787-Cheapest-Flights-Within-K-Stops"><a href="#787-Cheapest-Flights-Within-K-Stops" class="headerlink" title="787. Cheapest Flights Within K Stops"></a>787. Cheapest Flights Within K Stops</h3><blockquote><ul><li><p>题目</p><p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u</code>and arrives at <code>v</code> with a price <code>w</code>.</p><p>Now given all the cities and fights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example <span class="number">1</span>:</div><div class="line">&gt;   Input: </div><div class="line">&gt;   n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">500</span>]]</div><div class="line">&gt;   src = <span class="number">0</span>, dst = <span class="number">2</span>, k = <span class="number">1</span></div><div class="line">&gt;   Output: <span class="number">200</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The cheapest price from city <span class="number">0</span> to city <span class="number">2</span> with at most <span class="number">1</span> stop costs <span class="number">200</span>, as marked red in the picture.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example <span class="number">2</span>:</div><div class="line">&gt;   Input: </div><div class="line">&gt;   n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">500</span>]]</div><div class="line">&gt;   src = <span class="number">0</span>, dst = <span class="number">2</span>, k = <span class="number">0</span></div><div class="line">&gt;   Output: <span class="number">500</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The cheapest price from city <span class="number">0</span> to city <span class="number">2</span> with at most <span class="number">0</span> stop costs <span class="number">500</span>, as marked blue in the picture.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>dp[i][j]表示从src城市出发，经过i站，到达城市j</p><p>状态转移:</p><p>dp[i][j] = min ( dp[i][j] , dp[i-1][mid]+cost[mid][j] )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="keyword">import</span> sys</div><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n, flights, src, dst, K)</span>:</span></div><div class="line">&gt;           mv = <span class="number">1000000</span></div><div class="line">&gt;           dp = [ [ mv <span class="keyword">for</span> _ <span class="keyword">in</span> range(n) ] <span class="keyword">for</span> _ <span class="keyword">in</span> range(K+<span class="number">2</span>) ] </div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(K+<span class="number">2</span>):</div><div class="line">&gt;               dp[i][src] = <span class="number">0</span> <span class="comment"># 从scr出发到scr，不需要cost</span></div><div class="line">&gt;           <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">2</span>):</div><div class="line">&gt;               <span class="keyword">for</span> flight <span class="keyword">in</span> flights:</div><div class="line">&gt;                  s = flight[<span class="number">0</span>]</div><div class="line">&gt;                  d = flight[<span class="number">1</span>]</div><div class="line">&gt;                  cost = flight[<span class="number">2</span>]</div><div class="line">&gt;                  dp[k][d] = min(dp[k][d],dp[k<span class="number">-1</span>][s]+cost)</div><div class="line">&gt;           <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[K+<span class="number">1</span>][dst]==mv <span class="keyword">else</span> dp[K+<span class="number">1</span>][dst]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="790-Domino-and-Tromino-Tiling"><a href="#790-Domino-and-Tromino-Tiling" class="headerlink" title="790. Domino and Tromino Tiling"></a>790. Domino and Tromino Tiling</h3><blockquote><ul><li><p>题目</p><p>We have two types of tiles: a 2x1 domino shape, and an “L” tromino shape. These shapes may be rotated.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   XX  &lt;- domino</div><div class="line">&gt;   </div><div class="line">&gt;   XX  &lt;- <span class="string">"L"</span> tromino</div><div class="line">&gt;   X</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7</strong>.</p><p>  (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   Example:</div><div class="line">&gt;   Input: <span class="number">3</span></div><div class="line">&gt;   Output: <span class="number">5</span></div><div class="line">&gt;   Explanation: </div><div class="line">&gt;   The five different ways are listed below, different letters indicates different tiles:</div><div class="line">&gt;   XYZ XXZ XYY XXY XYY</div><div class="line">&gt;   XYZ YYZ XZZ XYY XXY</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>图片：<a href="http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-790-domino-and-tromino-tiling/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-790-domino-and-tromino-tiling/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;   dp[i]表示高度为<span class="number">2</span>，长度为i的形状可能组法。</div><div class="line">&gt;   只有xx多米诺时，有两种拼法，用一个xx，但是把它立起来，这样的拼法是dp[i-<span class="number">1</span>];另一种是用两个</div><div class="line">&gt;               xx</div><div class="line">&gt;   xx，组成正方形xx，这样拼法是dp[i-<span class="number">2</span>]</div><div class="line">&gt;   dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>],斐波那契数列。</div><div class="line">&gt;   考虑L型多米诺，具体看图，不好描述。</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numTilings</span><span class="params">(self, N)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type N: int</span></div><div class="line"><span class="string">&gt;           :rtype: int</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           m = <span class="number">1000000007</span></div><div class="line">&gt;           dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</div><div class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</div><div class="line">&gt;               dp[i][<span class="number">0</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-2</span>][<span class="number">0</span>] + <span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>])%m</div><div class="line">&gt;               dp[i][<span class="number">1</span>] = (dp[i<span class="number">-2</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>])%m</div><div class="line">&gt;           <span class="keyword">return</span> dp[N][<span class="number">0</span>]</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h3><blockquote><ul><li><p>题目</p><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"babad"</span></div><div class="line">&gt;   Output: <span class="string">"bab"</span></div><div class="line">&gt;   Note: <span class="string">"aba"</span> is also a valid answer.</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: <span class="string">"cbbd"</span></div><div class="line">&gt;   Output: <span class="string">"bb"</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><p>这道题的难点在于，使用下标i和j来表示substring，i和j具体应该如何变化。实际上，i和j分别表示子串的结束字符和开头字符，如果s[i] != s[j]，那么dp[i][j]=false; 否则查看j+1 至 i-1之间是否回文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   dp(i, j) <span class="function">represents whether <span class="title">s</span><span class="params">(i ... j)</span> can form a palindromic substring, <span class="title">dp</span><span class="params">(i, j)</span> is <span class="keyword">true</span> when <span class="title">s</span><span class="params">(i)</span> equals to <span class="title">s</span><span class="params">(j)</span> and <span class="title">s</span><span class="params">(i+<span class="number">1</span> ... j<span class="number">-1</span>)</span> is a palindromic substring. When we found a palindrome, check <span class="keyword">if</span> it's the longest one. Time complexity <span class="title">O</span><span class="params">(n^<span class="number">2</span>)</span>.</span></div><div class="line"><span class="function">&gt;</span></div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></div><div class="line">&gt;           <span class="string">"""</span></div><div class="line"><span class="string">&gt;           :type s: str</span></div><div class="line"><span class="string">&gt;           :rtype: str</span></div><div class="line"><span class="string">&gt;           """</span></div><div class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">""</span></div><div class="line">&gt;           re = <span class="string">""</span></div><div class="line">&gt;           l = len(s)</div><div class="line">&gt;           dp = [ [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l) ]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">&gt;               dp[i][i] = <span class="keyword">True</span></div><div class="line">&gt;           <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,l):</div><div class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(j,<span class="number">-1</span>,<span class="number">-1</span>):<span class="comment">#start from (j-1), end in 0, not including -1</span></div><div class="line">&gt;                   dp[i][j] = s[i]==s[j] <span class="keyword">and</span> (j-i+<span class="number">1</span>&lt;<span class="number">3</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</div><div class="line">&gt;                   <span class="keyword">if</span> dp[i][j]:</div><div class="line">&gt;                       re = s[i:j+<span class="number">1</span>] <span class="keyword">if</span> len(re)&lt;(j-i+<span class="number">1</span>) <span class="keyword">else</span> re</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="764-Largest-Plus-Sign"><a href="#764-Largest-Plus-Sign" class="headerlink" title="764. Largest Plus Sign"></a><em><u>764. Largest Plus Sign</u></em></h3><blockquote><ul><li><p>题目</p><p>In a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>. What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid? Return the order of the plus sign. If there is none, return 0.</p><p>An “<em>axis-aligned plus sign of 1s</em> of order <strong>k</strong>“ has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code> going up, down, left, and right, and made of <code>1</code>s. This is demonstrated in the diagrams below. Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.</p><p><strong>Examples of Axis-Aligned Plus Signs of Order k:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt;   Order <span class="number">1</span>:</div><div class="line">&gt;   <span class="number">000</span></div><div class="line">&gt;   <span class="number">010</span></div><div class="line">&gt;   <span class="number">000</span></div><div class="line">&gt;   </div><div class="line">&gt;   Order <span class="number">2</span>:</div><div class="line">&gt;   <span class="number">00000</span></div><div class="line">&gt;   <span class="number">00100</span></div><div class="line">&gt;   <span class="number">01110</span></div><div class="line">&gt;   <span class="number">00100</span></div><div class="line">&gt;   <span class="number">00000</span></div><div class="line">&gt;   </div><div class="line">&gt;   Order <span class="number">3</span>:</div><div class="line">&gt;   <span class="number">0000000</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0111110</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0001000</span></div><div class="line">&gt;   <span class="number">0000000</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  <strong>Example1</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: N = <span class="number">5</span>, mines = [[<span class="number">4</span>, <span class="number">2</span>]]</div><div class="line">&gt;   Output: <span class="number">2</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11111</span></div><div class="line">&gt;   <span class="number">11011</span></div><div class="line">&gt;   In the above grid, the largest plus sign can only be order <span class="number">2</span>.  One of them is marked in bold.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>  <strong>Example2</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: N = <span class="number">2</span>, mines = []</div><div class="line">&gt;   Output: <span class="number">1</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   There is no plus sign of order <span class="number">2</span>, but there is of order <span class="number">1</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>  <strong>Example3</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   Input: N = <span class="number">1</span>, mines = [[<span class="number">0</span>, <span class="number">0</span>]]</div><div class="line">&gt;   Output: <span class="number">0</span></div><div class="line">&gt;   Explanation:</div><div class="line">&gt;   There is no plus sign, so <span class="keyword">return</span> <span class="number">0</span>.</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li><p>思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   动态规划，分别记录<span class="number">4</span>个方向上的最大连续<span class="number">1</span>的个数。比如”<span class="number">1001111</span>”， 每个位置出现的最大连续<span class="number">1</span>的个数分别为：”<span class="number">1001234</span>”，有了<span class="number">4</span>个方向的最长连续<span class="number">1</span>，order就是这四个方向的最小值，遍历每个位置的order，求出最大order即可。</div><div class="line">&gt;   设置<span class="number">4</span>个状态转移矩阵，lf[][],rt[][],dn[][],up[][]</div><div class="line">&gt;   如果当前的grid[i][j]=<span class="number">1</span>,那么</div><div class="line">&gt;   lf[i][j] = lf[i][j-<span class="number">1</span>]+<span class="number">1</span></div><div class="line">&gt;   rt、dn、up同理。</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(self, N, mines)</span>:</span></div><div class="line">&gt;           grid = [[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           <span class="keyword">for</span> mine <span class="keyword">in</span> mines:</div><div class="line">&gt;               a = mine[<span class="number">0</span>]</div><div class="line">&gt;               b = mine[<span class="number">1</span>]</div><div class="line">&gt;               grid[a][b] = <span class="number">0</span></div><div class="line">&gt;           lf = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           rt = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           dn = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           up = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</div><div class="line">&gt;                   <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</div><div class="line">&gt;                       lf[i][j] = <span class="number">1</span> <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">else</span> lf[i][j<span class="number">-1</span>]+<span class="number">1</span></div><div class="line">&gt;                   <span class="keyword">if</span> grid[j][i]==<span class="number">1</span>:<span class="comment">##trick</span></div><div class="line">&gt;                       dn[j][i] = <span class="number">1</span> <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">else</span> dn[j<span class="number">-1</span>][i]+<span class="number">1</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</div><div class="line">&gt;                   <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</div><div class="line">&gt;                       rt[i][j] = <span class="number">1</span> <span class="keyword">if</span> j==N<span class="number">-1</span> <span class="keyword">else</span> rt[i][j+<span class="number">1</span>]+<span class="number">1</span></div><div class="line">&gt;                   <span class="keyword">if</span> grid[j][i]==<span class="number">1</span>: <span class="comment">##trick</span></div><div class="line">&gt;                       up[j][i] = <span class="number">1</span> <span class="keyword">if</span> j==N<span class="number">-1</span> <span class="keyword">else</span> up[j+<span class="number">1</span>][i]+<span class="number">1</span></div><div class="line">&gt;           re = <span class="number">0</span></div><div class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):<span class="comment">##使用min、max函数会超时</span></div><div class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</div><div class="line">&gt;                   tre = lf[i][j]</div><div class="line">&gt;                   tre = rt[i][j] <span class="keyword">if</span> rt[i][j]&lt;tre <span class="keyword">else</span> tre</div><div class="line">&gt;                   tre = dn[i][j] <span class="keyword">if</span> dn[i][j]&lt;tre <span class="keyword">else</span> tre</div><div class="line">&gt;                   tre = up[i][j] <span class="keyword">if</span> up[i][j]&lt;tre <span class="keyword">else</span> tre</div><div class="line">&gt;                   re = tre <span class="keyword">if</span> tre&gt;re <span class="keyword">else</span> re</div><div class="line">&gt;           <span class="keyword">return</span> re</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote></blockquote>]]></content>
      
      <categories>
          
          <category> -Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Definition of Differential Privacy</title>
      <link href="/2018/05/25/Definition-of-Differential-Privacy/"/>
      <url>/2018/05/25/Definition-of-Differential-Privacy/</url>
      <content type="html"><![CDATA[<p>This post is about the definition of Differential Privacy</p><h2 id="Vector-DP"><a href="#Vector-DP" class="headerlink" title="Vector DP"></a>Vector DP</h2><p>This following details are from<a href="http://www.vldb.org/pvldb/vol7/p919-to.pdf" target="_blank" rel="noopener">[2014-To]</a>.</p><h2 id="DP-Utility-Analysis"><a href="#DP-Utility-Analysis" class="headerlink" title="DP Utility Analysis"></a>DP Utility Analysis</h2><p>This following details are from <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8319407" target="_blank" rel="noopener">[2018-Yang]</a>.</p><p><img src="/2018/05/25/Definition-of-Differential-Privacy/2018-YANG.png" alt="2018-YANG"></p><p><img src="/2018/05/25/Definition-of-Differential-Privacy/2018-YANG1.png" alt="2018-YANG1-7391264"></p><h2 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h2><h3 id="Prupose"><a href="#Prupose" class="headerlink" title="Prupose"></a>Prupose</h3><ul><li>differential privacy aims to ensure that the output of the algorithm does not significantly depend on any particular individual’s data and ensures that an adversary should not be able to confidently infer whether a particular individual is present in a database even with access to every other entry in the database and an unbounded computational power. <a href="http://ceur-ws.org/Vol-1558/paper35.pdf" target="_blank" rel="noopener">[2016-Wang]</a></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[2014-To] A Framework for Protecting Worker Location Privacy in Spatial Crowdsourcing</p><p>[2018-Yang] Density-Based Location Preservation for Mobile Crowdsensing With Differential Privacy</p><p>[2016-Wang] Using Randomized Response for Differential Privacy Preserving Data Collection </p>]]></content>
      
      <categories>
          
          <category> -Differential Privacy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Differential Privacy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Greedy Algorithm</title>
      <link href="/2018/05/23/Greedy-Algorithm/"/>
      <url>/2018/05/23/Greedy-Algorithm/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> -Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Commands</title>
      <link href="/2018/05/23/Hexo-Commands/"/>
      <url>/2018/05/23/Hexo-Commands/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-Basic-Commands"><a href="#Hexo-Basic-Commands" class="headerlink" title="Hexo Basic Commands"></a>Hexo Basic Commands</h1><h2 id="create-a-blog"><a href="#create-a-blog" class="headerlink" title="create a blog"></a>create a blog</h2><p>hexo n “name of blog” </p><h2 id="post-a-blog"><a href="#post-a-blog" class="headerlink" title="post a blog"></a>post a blog</h2><a id="more"></a><p>hexo  clean</p><p>hexo g</p><p>hexo d</p><h2 id="online-markdown"><a href="#online-markdown" class="headerlink" title="online markdown"></a>online markdown</h2><p>hexo server -d</p><h2 id="article-folding"><a href="#article-folding" class="headerlink" title="article folding"></a>article folding</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!-- more --&gt;</div></pre></td></tr></table></figure><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>create a new pages firstly: <strong>hexo new page tags</strong></p><p>opne new page and set its type as “tages”</p><h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><p>create a new pages firstly: <strong>hexo new page categories</strong></p><p>opne new page and set its type as “categories”</p><h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><p><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">[Insert mathematical formula in hexo articles]</a></p><h2 id="Pictures"><a href="#Pictures" class="headerlink" title="Pictures"></a>Pictures</h2><p><a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">[Insert pics in hexo articles]</a></p>]]></content>
      
      <categories>
          
          <category> -Personal Website </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
