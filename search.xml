<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Greedy Algorithm</title>
      <link href="/2018/05/23/Greedy-Algorithm/"/>
      <url>/2018/05/23/Greedy-Algorithm/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> -Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Commands</title>
      <link href="/2018/05/23/Hexo-Commands/"/>
      <url>/2018/05/23/Hexo-Commands/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-Basic-Commands"><a href="#Hexo-Basic-Commands" class="headerlink" title="Hexo Basic Commands"></a>Hexo Basic Commands</h1><h2 id="create-a-blog"><a href="#create-a-blog" class="headerlink" title="create a blog"></a>create a blog</h2><p>hexo n “name of blog” </p><h2 id="post-a-blog"><a href="#post-a-blog" class="headerlink" title="post a blog"></a>post a blog</h2><a id="more"></a><p>hexo  clean</p><p>hexo g</p><p>hexo d</p><h2 id="online-markdown"><a href="#online-markdown" class="headerlink" title="online markdown"></a>online markdown</h2><p>hexo server -d</p><h2 id="article-folding"><a href="#article-folding" class="headerlink" title="article folding"></a>article folding</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>create a new pages firstly: <strong>hexo new page tags</strong></p><p>opne new page and set its type as “tages”</p><h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><p>create a new pages firstly: <strong>hexo new page categories</strong></p><p>opne new page and set its type as “categories”</p>]]></content>
      
      <categories>
          
          <category> -Personal Website </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2018/05/23/DynamicProgramming/"/>
      <url>/2018/05/23/DynamicProgramming/</url>
      <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p><a id="more"></a><p>首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？ 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p><p>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p><p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p><p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p><p><strong>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</strong></p><h3 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746.Min Cost Climbing Stairs"></a>746.Min Cost Climbing Stairs</h3><blockquote><ul><li><p>题目</p><p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p><p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>]</span><br><span class="line">&gt;   Output: <span class="number">6</span></span><br><span class="line">&gt;   Explanation: Cheapest <span class="keyword">is</span> start on cost[<span class="number">0</span>], <span class="keyword">and</span> only step on <span class="number">1</span>s, skipping cost[<span class="number">3</span>].</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: cost = [<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</span><br><span class="line">&gt;   Output: <span class="number">15</span></span><br><span class="line">&gt;   Explanation: Cheapest <span class="keyword">is</span> start on cost[<span class="number">1</span>], pay that cost <span class="keyword">and</span> go to the top.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>典型动态规划，且只需要一维dp数组维护，考虑到可以从index=0|1开始，所以在dp数组前面插入两个0(因为是加法，乘法则插入1)，同时要表示终点，则在dp尾再插入一个0，统计到达top时的cost。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type cost: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           lcost = len(cost)</span><br><span class="line">&gt;           cost.append(<span class="number">0</span>)</span><br><span class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(lcost+<span class="number">3</span>)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(dp)):</span><br><span class="line">&gt;               dp[i] = min(dp[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]) + cost[i<span class="number">-2</span>]</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h3><blockquote><ul><li><p>题意</p><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: <span class="number">2</span></span><br><span class="line">&gt;   Output: <span class="number">2</span></span><br><span class="line">&gt;   Explanation: There are two ways to climb to the top.</span><br><span class="line">&gt;   <span class="number">1.</span> <span class="number">1</span> step + <span class="number">1</span> step</span><br><span class="line">&gt;   <span class="number">2.</span> <span class="number">2</span> steps</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: <span class="number">3</span></span><br><span class="line">&gt;   Output: <span class="number">3</span></span><br><span class="line">&gt;   Explanation: There are three ways to climb to the top.</span><br><span class="line">&gt;   <span class="number">1.</span> <span class="number">1</span> step + <span class="number">1</span> step + <span class="number">1</span> step</span><br><span class="line">&gt;   <span class="number">2.</span> <span class="number">1</span> step + <span class="number">2</span> steps</span><br><span class="line">&gt;   <span class="number">3.</span> <span class="number">2</span> steps + <span class="number">1</span> step</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>跟上面一题很相似了，同样是一维，也需要在首个插入</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type n: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           l = n+<span class="number">1</span></span><br><span class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</span><br><span class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l):</span><br><span class="line">&gt;               dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h3><blockquote><ul><li><p>题意</p><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">&gt;   Output: <span class="number">6</span></span><br><span class="line">&gt;   Explanation: [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>一维dp数组，同样在前面插入0，但是返回的时候，要小心不能返回max(dp)，而是max(dp[1:])，防止input是[-1,-2].</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           l = len(nums)</span><br><span class="line">&gt;           dp = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l+<span class="number">1</span>):</span><br><span class="line">&gt;               dp[i] = max(nums[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>])</span><br><span class="line">&gt;           <span class="keyword">return</span> max(dp[<span class="number">1</span>:])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h3><blockquote><ul><li><p>题目</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">&gt;   Output: <span class="number">4</span></span><br><span class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</span><br><span class="line">&gt;                Total amount you can rob = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&gt;   Output: <span class="number">4</span></span><br><span class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">2</span>), rob house <span class="number">4</span> (money = <span class="number">2</span>) Total amount you can rob = <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>dp状态思考错误，dp[i]表示抢到第i个房子时，目前获取的最大利润</p><p>dp状态转移方程，有点错误。错误以为不能抢劫相邻的房子意味着抢的房子之间必须相隔一个房子，其实可以中间可以相隔多个房子不抢。</p><p>则dp转移方程为：即要不要抢当前的房子</p><p>dp[i] = max( dp[i-1] , dp[i-2] + nums[i] )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           l = len(nums)</span><br><span class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>)]</span><br><span class="line">&gt;           dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l+<span class="number">1</span>):</span><br><span class="line">&gt;               dp[i] = max(nums[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>], dp[i<span class="number">-1</span>])</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><p>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p><p>正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p><p>让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p><p><strong>d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i]</strong></p><p>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p><h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h3><blockquote><ul><li><p>题目</p><p>$$m \times {n}$$的矩阵，从（0，0）位置走到（m，n）位置共有多少走法</p></li><li><p>思路</p><p>二维dp，dp[i][j]记录到达位置（i,j）共有的走法，dp[i][j]=dp[i-1][j]+dp[i][j-1].</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type m: int</span></span><br><span class="line"><span class="string">&gt;           :type n: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">&gt;               dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">&gt;               dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">&gt;                   dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h3><blockquote><ul><li><p>题目</p><p>同样是[m,n]矩阵，但是有1表示障碍，不能过，0为空白可以过去。</p></li><li><p>思路</p><p>dp[i][j]仍然是可能的走法数，但是在初始化时，如果当前是障碍，则dp[][]=0.否则依赖于前面一个。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type obstacleGrid: List[List[int]]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid : <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           m = len(obstacleGrid)</span><br><span class="line">&gt;           n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span> <span class="comment">##update</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m): <span class="comment">##update</span></span><br><span class="line">&gt;               dp[i][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> dp[i<span class="number">-1</span>][<span class="number">0</span>] <span class="keyword">and</span> <span class="keyword">not</span> obstacleGrid[i][<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):<span class="comment">##update</span></span><br><span class="line">&gt;               dp[<span class="number">0</span>][i] = <span class="number">1</span> <span class="keyword">if</span> dp[<span class="number">0</span>][i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>][i] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">&gt;                   <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">&gt;                       dp[i][j] = <span class="number">0</span></span><br><span class="line">&gt;                   <span class="keyword">else</span>:</span><br><span class="line">&gt;                       dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h3><blockquote><ul><li><p>题目</p><p>从矩阵的左上角走到右下角，矩阵上元素值为代价，求最小代价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input:</span><br><span class="line">&gt;   [</span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">&gt;     [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">&gt;   ]</span><br><span class="line">&gt;   Output: <span class="number">7</span></span><br><span class="line">&gt;   Explanation: Because the path <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> minimizes the sum.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>完全捡苹果题目，需要注意的是创建dp数组时，len_row在外层，len_column在内层。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           l1 = len(grid)</span><br><span class="line">&gt;           l2 = len(grid[<span class="number">0</span>])</span><br><span class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l2)] <span class="keyword">for</span> j <span class="keyword">in</span> range(l1)] <span class="comment">###l2在里面，l1在外面</span></span><br><span class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1):</span><br><span class="line">&gt;               dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">&gt;           <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2):</span><br><span class="line">&gt;               dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l1):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,l2):</span><br><span class="line">&gt;                   temp = dp[i][j<span class="number">-1</span>] <span class="keyword">if</span> dp[i][j<span class="number">-1</span>]&lt;dp[i<span class="number">-1</span>][j] <span class="keyword">else</span> dp[i<span class="number">-1</span>][j]</span><br><span class="line">&gt;                   dp[i][j] = temp + grid[i][j]</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h3><blockquote><ul><li><p>题目</p><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;   [</span><br><span class="line">&gt;        [<span class="number">2</span>],</span><br><span class="line">&gt;       [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">&gt;      [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">&gt;     [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">&gt;   ]</span><br><span class="line">&gt;   The minimum path sum from top to bottom is <span class="number">11</span> (i.e., <span class="number">2</span> + <span class="number">3</span> + <span class="number">5</span> + <span class="number">1</span> = <span class="number">11</span>).</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>与捡苹果很相似，有两种想法，首先dp[i][j]表示到达需要的最少步数。那么状态转移方程有两种想法：</p><p>一种是：dp[i][j]出发有两种走法，dp[i+1][j]和dp[i+1][j+1]，更新到达后的状态dp[i+1][j]和dp[i+1][j+1]；</p><p>另一种是dp[i][j]有两种到达的方法，dp[i-1][j]和dp[i-1][j-1]，更新dp[i][j]</p><p>但是觉得第一种方法比较容易，因为第二种要考虑边界</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">import</span> sys</span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> triangle:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           l = len(triangle)</span><br><span class="line">&gt;           dp = [[ sys.maxsize <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle[j])) ] <span class="keyword">for</span> j <span class="keyword">in</span> range(l) ]</span><br><span class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[i])):</span><br><span class="line">&gt;                   dp[i+<span class="number">1</span>][j] = dp[i+<span class="number">1</span>][j] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j] &lt; (dp[i][j]+triangle[i+<span class="number">1</span>][j]) <span class="keyword">else</span> (dp[i][j]+triangle[i+<span class="number">1</span>][j])</span><br><span class="line">&gt;                   dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>] <span class="keyword">if</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] &lt; (dp[i][j]+triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]) <span class="keyword">else</span> (dp[i][j]+triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">&gt;           <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h3><blockquote><ul><li><p>题目</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">&gt;   Output: <span class="number">3</span></span><br><span class="line">&gt;   Explanation: You cannot rob house <span class="number">1</span> (money = <span class="number">2</span>) and then rob house <span class="number">3</span> (money = <span class="number">2</span>),</span><br><span class="line">&gt;                because they are adjacent houses.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">&gt;   Output: <span class="number">4</span></span><br><span class="line">&gt;   Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</span><br><span class="line">&gt;                Total amount you can rob = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>房子排成了一个圆圈，则如果抢了第一家，就不能抢最后一家，因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢。则把数组分成两份，分别使用动态规划求解。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">if</span> len(nums)==<span class="number">1</span>:<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&gt;           l = len(nums)</span><br><span class="line">&gt;           dp1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</span><br><span class="line">&gt;           dp2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</span><br><span class="line">&gt;           dp1[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">&gt;           dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,l):</span><br><span class="line">&gt;               dp1[i] = max(dp1[i<span class="number">-1</span>],dp1[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>])</span><br><span class="line">&gt;               dp2[i] = max(dp2[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>]+nums[i])</span><br><span class="line">&gt;           <span class="keyword">return</span> max(dp1[<span class="number">-1</span>],dp2[<span class="number">-1</span>])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h3><blockquote><ul><li><p>题目</p><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: n = <span class="number">12</span></span><br><span class="line">&gt;   Output: <span class="number">3</span> </span><br><span class="line">&gt;   Explanation: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: n = <span class="number">13</span></span><br><span class="line">&gt;   Output: <span class="number">2</span></span><br><span class="line">&gt;   Explanation: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>这道题就是找零钱。只是零钱的选取是有限的，而这边完美数是无限的，但是要小于n。故遍历零钱数组的操作，需要变成while循环，遍历每一个完美数。</p><p>dp[i]表示最少需要的数字凑成这个数，直到n。两层循环。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment">###LeetCode下Python3是超时，Python2可以</span></span><br><span class="line">&gt;   <span class="keyword">import</span> sys</span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type n: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           dp = [sys.maxsize <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">&gt;               j = <span class="number">1</span></span><br><span class="line">&gt;               <span class="keyword">while</span> j*j&lt;=i:</span><br><span class="line">&gt;                   dp[i] = min(dp[i],dp[i-j*j]+<span class="number">1</span>)</span><br><span class="line">&gt;                   j = j + <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;           </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h3><blockquote><ul><li><p>题目</p><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p></li><li><p>思路</p><p>如果动态规划，则时间复杂度是$O(n^2)$, 第一层循环来更新dp，第二个循环来遍历之前的数字且必须比当前小，不能等于。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           l = len(nums)</span><br><span class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">&gt;                   <span class="keyword">if</span> nums[j]&lt;nums[i] <span class="keyword">and</span> dp[i] &lt; dp[j]+<span class="number">1</span>:</span><br><span class="line">&gt;                       dp[i] = dp[j]+<span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">return</span> max(dp)</span><br><span class="line">&gt;           </span><br><span class="line">&gt;           </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment">###二分查找的复杂度是O(log(n)),则整体复杂度是O(nlong(n))</span></span><br><span class="line">&gt;   <span class="keyword">import</span> bisect</span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           sorted_list = []</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">&gt;               pos = bisect.bisect_left(sorted_list,i)</span><br><span class="line">&gt;               <span class="keyword">if</span> pos==len(sorted_list):</span><br><span class="line">&gt;                   sorted_list.append(i)</span><br><span class="line">&gt;               <span class="keyword">else</span>:</span><br><span class="line">&gt;                   sorted_list[pos] = i</span><br><span class="line">&gt;           <span class="keyword">return</span> len(sorted_list)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h3><blockquote><ul><li><p>题目</p><p>换硬币，但是可能失败，即没有1元银币，导致凑不够。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="number">3</span> (<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">&gt;   <span class="keyword">return</span> -<span class="number">1</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>两层遍历，dp[i]表示凑够i元需要的最少银币数量。疑惑点是如何处理凑不够的情况，返回-1.事实上，只要有提供1元银币，一定可以凑够。那就判断dp[1]是否有更新。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">import</span> sys</span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type coins: List[int]</span></span><br><span class="line"><span class="string">&gt;           :type amount: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           dp = [sys.maxsize <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line">&gt;           re[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">&gt;               <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">&gt;                   <span class="keyword">if</span> coin &lt;= i:</span><br><span class="line">&gt;                       <span class="keyword">if</span> dp[i] &gt; dp[i-coin]+<span class="number">1</span>:</span><br><span class="line">&gt;                           dp[i] = dp[i-coin]+<span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">if</span> dp[<span class="number">-1</span>] == sys.maxsize:</span><br><span class="line">&gt;               <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&gt;           <span class="keyword">else</span>:</span><br><span class="line">&gt;               <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h3><blockquote><ul><li><p>题目</p><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   For num = <span class="number">5</span> you should <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>].</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>可以使用动态规划，时间复杂度是$O(n)$. 显然dp[i]表示数字里面含有的1的个数。但是状态转移如何表示？计算i的时候，如何利用dp[0]-dp[i-1]呢？利用➗2，即右移操作。一个数右移一位，变成较小的数字，失去的是最右的1或者0.则状态转移变成了</p><p>dp[i] = dp[i&gt;&gt;1] + i%2</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type num: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: List[int]</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(num+<span class="number">1</span>)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">&gt;               dp[i] = dp[i//<span class="number">2</span>] + i%<span class="number">2</span></span><br><span class="line">&gt;           <span class="keyword">return</span> dp</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment">###利用Python内置函数。</span></span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type num: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: List[int]</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">return</span> [bin(x).count(<span class="string">'1'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(num+<span class="number">1</span>)]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h3><blockquote><ul><li><p>题目</p><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;   nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;   target = <span class="number">4</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   The possible combination ways are:</span><br><span class="line">&gt;   (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&gt;   (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&gt;   (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">&gt;   (<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">&gt;   (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&gt;   (<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">&gt;   (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Note that different sequences are counted as different combinations.</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Therefore the output is <span class="number">7</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  <strong>Follow up:</strong> What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?</p><ul><li><p>思路</p><p>就是找银币了。但是不同于找硬币，其状态转移是dp[i] = dp[i-j] + 1；该问题的状态转移是dp[i] += dp[i-1]</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :type target: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> target == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;<span class="number">0</span>:</span><br><span class="line">&gt;               dif = <span class="number">1</span> - nums[<span class="number">0</span>]</span><br><span class="line">&gt;               target += dif</span><br><span class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">&gt;                   nums[i] += dif</span><br><span class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</span><br><span class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> nums:</span><br><span class="line">&gt;                   <span class="keyword">if</span> j &lt;= i:</span><br><span class="line">&gt;                       dp[i] += dp[i - j]</span><br><span class="line">&gt;           print(dp)</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a>343. Integer Break</h3><blockquote><ul><li><p>题目</p><p>Given a positive integer <em>n</em>, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given <em>n</em> = 2, return 1 (2 = 1 + 1); given <em>n</em> = 10, return 36 (10 = 3 + 3 + 4).</p><p><strong>Note</strong>: You may assume that <em>n</em> is not less than 2 and not larger than 58.</p></li><li><p>思路</p><p>动态规划时间复杂度$O(n)$.难点在于状态转移方程，dp[i]表示i的因数的最大乘积。想到dp[i] = max( dp[i] , dp[j] <em> (i-j) )，其实本质就是将i先分解成（【j】  </em> 【i-j】），但是j可以再分解，同样i-j也可以再分解，选择大的。</p><p>即max（ j , dp[j] ）* max（i-j ，dp[i-j]）</p><p>故状态转移方程是：</p><p>dp[i] = max ( dp[i] , max（ j , dp[j] ）* max（i-j ，dp[i-j]） )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type n: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">&gt;                   dp[i] = max (dp[i], max(dp[j],j)*max(dp[i-j],i-j))</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><p>接下来，让我们来看看如何解决二维的DP问题。</p><p>平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。</p><p>解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。</p><p>首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是， 到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果， 我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解)</p><p>经过上面的分析，很容易可以得出问题的状态和状态转移方程。 状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么， 状态转移方程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i][j]=A[i][j] + max(S[i-<span class="number">1</span>][j], <span class="keyword">if</span> i&gt;<span class="number">0</span> ; S[i][j-<span class="number">1</span>], <span class="keyword">if</span> j&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>$S[i][j]$有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算$S[i][j]$时，$S[i-1][j]$和$S[i][j-1]$都已经计算出来了。</p><h3 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a><em><u>221. Maximal Square</u></em></h3><blockquote><ul><li><p>题目</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: </span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&gt;   <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&gt;   <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Output: <span class="number">4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>想不到用dp解决。</p><p>dp[i][j]表示以点[i][j]为右下角顶点的正方形的边长。为了构成全1正方形，该点必须是1，那么如何利用已经计算好的dp状态更新当前dp状态呢？即如何根据该点拓展正方形？与它上方，左方和左上方三个点有关。</p><p>当我们判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角，否则该点为右下角的正方形最大就是它自己了。这是定性的判断，那具体的最大正方形边长呢？我们知道，该点为右下角的正方形的最大边长，最多比它的上方，左方和左上方为右下角的正方形的边长多1，最好的情况是是它的上方，左方和左上方为右下角的正方形的大小都一样的，这样加上该点就可以构成一个更大的正方形。但如果它的上方，左方和左上方为右下角的正方形的大小不一样，合起来就会缺了某个角落，这时候只能取那三个正方形中最小的正方形的边长加1了。假设<code>dp[i][j]</code>表示以i,j为右下角的正方形的最大边长，则有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           row = len(matrix)</span><br><span class="line">&gt;           column = len(matrix[<span class="number">0</span>])</span><br><span class="line">&gt;           dp = [ [ <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(column) ] <span class="keyword">for</span> i <span class="keyword">in</span> range(row) ]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">&gt;               dp[i][<span class="number">0</span>] = int(matrix[i][<span class="number">0</span>])</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(column):</span><br><span class="line">&gt;               dp[<span class="number">0</span>][i] = int(matrix[<span class="number">0</span>][i])</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,row):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,column):</span><br><span class="line">&gt;                   <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</span><br><span class="line">&gt;                       dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">&gt;           re = <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">&gt;               re = max(re,max(dp[i]))</span><br><span class="line">&gt;           <span class="keyword">return</span> re * re <span class="comment">### re != max(max(dp))</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h3><blockquote><ul><li><p>题目</p><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: <span class="number">3</span></span><br><span class="line">&gt;   Output: <span class="number">5</span></span><br><span class="line">&gt;   Explanation:</span><br><span class="line">&gt;   Given n = <span class="number">3</span>, there are a total of <span class="number">5</span> unique BST<span class="string">'s:</span></span><br><span class="line"><span class="string">&gt;   </span></span><br><span class="line"><span class="string">&gt;      1         3     3      2      1</span></span><br><span class="line"><span class="string">&gt;       \       /     /      / \      \</span></span><br><span class="line"><span class="string">&gt;        3     2     1      1   3      2</span></span><br><span class="line"><span class="string">&gt;       /     /       \                 \</span></span><br><span class="line"><span class="string">&gt;      2     1         2                 3</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>不会想到用动态规划。但是知道可以dp，有大致的想法，我最初认为dp[i]表示数字1，2，…，i能形成的二叉树的数量。这样在状态转移的时候就有麻烦了。其实，与数字大小无关，即dp[i]也可以是9，10，11，…，i+9形成的二叉树，实际上，dp[i]状态表示的是i个有序上升点能形成的二叉树个数。这样问题就简单了。状态转移：</p><p>dp[i] += dp[j-1] * dp[i-j] 遍历j从1-i，表示以j为顶点形成的二叉树。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type n: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> n</span><br><span class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">&gt;                   dp[i] += dp[j<span class="number">-1</span>] * dp[i-j] <span class="comment">## += 且 j-1</span></span><br><span class="line">&gt;           print(dp)</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h3><blockquote><ul><li><p>题目</p><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="string">'A'</span> -&gt; <span class="number">1</span></span><br><span class="line">&gt;   <span class="string">'B'</span> -&gt; <span class="number">2</span></span><br><span class="line">&gt;   ...</span><br><span class="line">&gt;   <span class="string">'Z'</span> -&gt; <span class="number">26</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: <span class="string">"12"</span></span><br><span class="line">&gt;   Output: <span class="number">2</span></span><br><span class="line">&gt;   Explanation: It could be decoded as <span class="string">"AB"</span> (<span class="number">1</span> <span class="number">2</span>) or <span class="string">"L"</span> (<span class="number">12</span>).</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: <span class="string">"226"</span></span><br><span class="line">&gt;   Output: <span class="number">3</span></span><br><span class="line">&gt;   Explanation: It could be decoded as <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), or <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>).</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>可以想到用dp，但是一直纠结于dp的维数。</p><p>dp[i]表示1-i字符串的decode种类，那么状态转移方程呢？与具体的字符串有关。因为数字只能是一位或者两位，且一位的数字不能是0.那么如果当前的数字是0，那么不能以一位解码；否则可以以该种方式解码，则dp[i] += dp[i-1];如果i-1和i的两位数是合法的，即位于10和26之间，那么是可以以两位数解码，dp[i] += dp[i-2] </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   dp[i] = </span><br><span class="line">&gt;       <span class="number">0</span>                   <span class="keyword">if</span> s[i] and s[i-<span class="number">1</span>][i] invalid</span><br><span class="line">&gt;       dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]   <span class="keyword">if</span> s[i] and s[i-<span class="number">1</span>][i] valid</span><br><span class="line">&gt;       dp[i-<span class="number">1</span>]             <span class="keyword">if</span> s[i] valid</span><br><span class="line">&gt;       dp[i-<span class="number">2</span>]             <span class="keyword">if</span> s[i-<span class="number">1</span>][i] valid</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type s: str</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           l = len(s)</span><br><span class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l + <span class="number">1</span>)]</span><br><span class="line">&gt;           dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt;           dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] !=<span class="string">'0'</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</span><br><span class="line">&gt;               one_digit = s[i]</span><br><span class="line">&gt;               two_digit = int(s[i - <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">&gt;               <span class="keyword">if</span> one_digit != <span class="string">'0'</span>:</span><br><span class="line">&gt;                   dp[i + <span class="number">1</span>] += dp[i]</span><br><span class="line">&gt;               <span class="keyword">if</span> two_digit &lt;= <span class="number">26</span> <span class="keyword">and</span> two_digit &gt;= <span class="number">10</span>:</span><br><span class="line">&gt;                   dp[i + <span class="number">1</span>] += dp[i - <span class="number">1</span>]</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a>368. Largest Divisible Subset</h3><blockquote><ul><li><p>题目</p><p>Given a set of <strong>distinct</strong> positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p><p>If there are multiple solutions, return any subset is fine.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Result: [<span class="number">1</span>,<span class="number">2</span>] (of course, [<span class="number">1</span>,<span class="number">3</span>] will also be ok)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Result: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>题目是很复杂了，而且不会想到用dp，因为这边求解的是list，而非极值。看了网上代码，还是em。</p><p>首先不论返回的list，单纯看最大的可以是多大，因为取余有个性质，i&gt;j&gt;k, i % j = 0，j % k = 0, 那么i % k = 0.所以给了dp状态转移的思路，</p><p>dp[i]表示数字i以及i之前的数组能形成的最大子集，状态的更新只需要考虑i之前的数字能否取余为零</p><p>dp[i] = max( dp[i] , dp[j] +1 ) if i % j == 0</p><p>接下来难点就是如何记录结果list，当然我们可以设置一个二维数组来保存，一旦更新dp的时候，也要更新对应的list，即把i值加上上一个list中。但是我们可以把$O(n^2)$的空间复杂度变成$D(n)$, pre[i]记录i之前能取余且得到最大的子集的元素的下标。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   https:<span class="comment">//www.cnblogs.com/godlei/p/5621990.html</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   如果a%b==<span class="number">0</span>，则a=mb，所以如果把数组排序后如果a%b==<span class="number">0</span>，且b%c==<span class="number">0</span>则a%c==<span class="number">0</span>。这就为用动态规划实现提供了可能性。设置一个数组result，result[i]表示i出包含的满足条件的子集个数。则如果nums[i]%nums[j]==<span class="number">0</span>，则result[i]=result[j]+<span class="number">1</span>;同时由于函数要返回的是一个List，所以我们要保存最长集合的路径。这个功能可以通过设置一个pre数组保存能被nums[i]整除的上一个数的索引。并在保存max值的同时保存max所在的位置maxIndex即可。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: List[int]</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           l = len(nums)</span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">&gt;           nums = sorted(nums)</span><br><span class="line">&gt;           dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]  <span class="comment">##表示集合元素个数,初始是1，表示至少自己单独成为合法的集合</span></span><br><span class="line">&gt;           size_max = <span class="number">1</span></span><br><span class="line">&gt;           index_max = <span class="number">0</span></span><br><span class="line">&gt;           pre = [<span class="number">-1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">&gt;                   <span class="keyword">if</span> nums[i] % nums[j] == <span class="number">0</span> <span class="keyword">and</span> dp[i] &lt; dp[j] + <span class="number">1</span>:</span><br><span class="line">&gt;                       dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">&gt;                       pre[i] = j <span class="comment">##</span></span><br><span class="line">&gt;                       <span class="keyword">if</span> dp[i]&gt;size_max: <span class="comment">## 等于也ok</span></span><br><span class="line">&gt;                           size_max = dp[i]</span><br><span class="line">&gt;                           index_max = i</span><br><span class="line">&gt;           re = []</span><br><span class="line">&gt;           <span class="keyword">while</span> index_max != <span class="number">-1</span>:</span><br><span class="line">&gt;               re.append(nums[index_max])</span><br><span class="line">&gt;               index_max = pre[index_max]</span><br><span class="line">&gt;           <span class="keyword">return</span> re</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote></blockquote><h3 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a>740. Delete and Earn</h3><blockquote><p>题目</p><p>Given an array <code>nums</code> of integers, you can perform operations on the array.</p><p>In each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. After, you must delete <strong>every</strong> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; Example1:</span><br><span class="line">&gt; Input: nums = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">&gt; Output: <span class="number">6</span></span><br><span class="line">&gt; Explanation: </span><br><span class="line">&gt; Delete <span class="number">4</span> to earn <span class="number">4</span> points, consequently <span class="number">3</span> is also deleted.</span><br><span class="line">&gt; Then, delete <span class="number">2</span> to earn <span class="number">2</span> points. <span class="number">6</span> total points are earned.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Example2:</span><br><span class="line">&gt; Input: nums = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt; Output: <span class="number">9</span></span><br><span class="line">&gt; Explanation: </span><br><span class="line">&gt; Delete <span class="number">3</span> to earn <span class="number">3</span> points, deleting both <span class="number">2</span><span class="string">'s and the 4.</span></span><br><span class="line"><span class="string">&gt; Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span></span><br><span class="line"><span class="string">&gt; 9 total points are earned.</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>这道题本质上就是198题House Rober。</p></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">import</span> collections</span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">deleteAndEarn</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type nums: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&gt;           dic = collections.Counter(nums)</span><br><span class="line">&gt;           N = max(nums)</span><br><span class="line">&gt;           new_nums = []</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>): <span class="comment">#防止情况[3,1]</span></span><br><span class="line">&gt;               v = dic[i] <span class="keyword">if</span> i <span class="keyword">in</span> dic.keys() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&gt;               new_nums.append(i*v)</span><br><span class="line">&gt;           dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(new_nums)+<span class="number">1</span>)]</span><br><span class="line">&gt;           dp[<span class="number">1</span>] = new_nums[<span class="number">1</span>]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(new_nums)):</span><br><span class="line">&gt;               dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+new_nums[i])</span><br><span class="line">&gt;           <span class="keyword">return</span> max(dp)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="718-Maximum-Length-of-Repeated-Subarray"><a href="#718-Maximum-Length-of-Repeated-Subarray" class="headerlink" title="718. Maximum Length of Repeated Subarray"></a>718. Maximum Length of Repeated Subarray</h3><blockquote><ul><li><p>题目</p><p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input:</span><br><span class="line">&gt;   A: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">&gt;   B: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">&gt;   Output: <span class="number">3</span></span><br><span class="line">&gt;   Explanation: </span><br><span class="line">&gt;   The repeated subarray with maximum length is [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>经典动态规划。A[i]：表示A的子串0-i，B[j]：表示B的子串0-j</p><p>dp[i][j]：A的子串与B的子串最长重合，状态更新dp[i][j] = dp[i-1][j-1] + 1 if 两个子串的最后字符相同</p></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type A: List[int]</span></span><br><span class="line"><span class="string">&gt;           :type B: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           la = len(A)</span><br><span class="line">&gt;           lb = len(B)</span><br><span class="line">&gt;           dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(la+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(lb+<span class="number">1</span>) ]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(la):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(lb):</span><br><span class="line">&gt;                   <span class="keyword">if</span> A[i]==B[j]:</span><br><span class="line">&gt;                       dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">return</span> max(max(row) <span class="keyword">for</span> row <span class="keyword">in</span> dp)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="801-Minimum-Swaps-To-Make-Sequences-Increasing"><a href="#801-Minimum-Swaps-To-Make-Sequences-Increasing" class="headerlink" title="801. Minimum Swaps To Make Sequences Increasing"></a><em><u>801. Minimum Swaps To Make Sequences Increasing</u></em></h3><blockquote><ul><li><p>题目</p><p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p><p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>.  Note that both elements are in the same index position in their respective sequences.</p><p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing.  (A sequence is <em>strictly increasing</em> if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p><p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Example:</span><br><span class="line">&gt;   Input: A = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>], B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">&gt;   Output: <span class="number">1</span></span><br><span class="line">&gt;   Explanation: </span><br><span class="line">&gt;   Swap A[<span class="number">3</span>] and B[<span class="number">3</span>].  Then the sequences are:</span><br><span class="line">&gt;   A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] and B = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;   which are both strictly increasing.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>思路</p><p>文字  <a href="https://blog.csdn.net/magicbean2/article/details/79826617" target="_blank" rel="noopener">https://blog.csdn.net/magicbean2/article/details/79826617</a> </p><p>图片  <a href="http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-801-minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-801-minimum-swaps-to-make-sequences-increasing/</a></p><p> 这道题实在是太难了，不过看图片还是可以稍微有点顺畅。</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">import</span> sys</span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">minSwap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type A: List[int]</span></span><br><span class="line"><span class="string">&gt;           :type B: List[int]</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           mv = sys.maxsize</span><br><span class="line">&gt;           l = len(A)</span><br><span class="line">&gt;           keep = [mv <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</span><br><span class="line">&gt;           swap = [mv <span class="keyword">for</span> j <span class="keyword">in</span> range(l)]</span><br><span class="line">&gt;           keep[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&gt;           swap[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 初始是1，不是0，因为意味着A[0]和B[0]交换一次</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,l):</span><br><span class="line">&gt;               a1 = A[i<span class="number">-1</span>]</span><br><span class="line">&gt;               b1 = B[i<span class="number">-1</span>]</span><br><span class="line">&gt;               a2 = A[i]</span><br><span class="line">&gt;               b2 = B[i]</span><br><span class="line">&gt;               <span class="keyword">if</span> a1 &lt; a2 <span class="keyword">and</span> b1 &lt; b2:</span><br><span class="line">&gt;                   keep[i] = keep[i<span class="number">-1</span>] <span class="comment"># no swap for both i-1, i</span></span><br><span class="line">&gt;                   swap[i] = swap[i<span class="number">-1</span>] + <span class="number">1</span> <span class="comment"># swap for both i-1, i; swap[i-1] means swap i-1, 1 means swap i</span></span><br><span class="line">&gt;               <span class="keyword">if</span> a1 &lt; b2 <span class="keyword">and</span> b1 &lt; a2:</span><br><span class="line">&gt;                   keep[i] = min(keep[i], swap[i<span class="number">-1</span>])</span><br><span class="line">&gt;                   swap[i] = min(swap[i], keep[i<span class="number">-1</span>]+<span class="number">1</span>)</span><br><span class="line">&gt;           <span class="keyword">return</span> min(keep[<span class="number">-1</span>],swap[<span class="number">-1</span>])</span><br><span class="line">&gt;           </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="787-Cheapest-Flights-Within-K-Stops"><a href="#787-Cheapest-Flights-Within-K-Stops" class="headerlink" title="787. Cheapest Flights Within K Stops"></a>787. Cheapest Flights Within K Stops</h3><blockquote><ul><li><p>题目</p><p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u</code>and arrives at <code>v</code> with a price <code>w</code>.</p><p>Now given all the cities and fights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Example <span class="number">1</span>:</span><br><span class="line">&gt;   Input: </span><br><span class="line">&gt;   n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">500</span>]]</span><br><span class="line">&gt;   src = <span class="number">0</span>, dst = <span class="number">2</span>, k = <span class="number">1</span></span><br><span class="line">&gt;   Output: <span class="number">200</span></span><br><span class="line">&gt;   Explanation: </span><br><span class="line">&gt;   The cheapest price from city <span class="number">0</span> to city <span class="number">2</span> with at most <span class="number">1</span> stop costs <span class="number">200</span>, as marked red in the picture.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Example <span class="number">2</span>:</span><br><span class="line">&gt;   Input: </span><br><span class="line">&gt;   n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">500</span>]]</span><br><span class="line">&gt;   src = <span class="number">0</span>, dst = <span class="number">2</span>, k = <span class="number">0</span></span><br><span class="line">&gt;   Output: <span class="number">500</span></span><br><span class="line">&gt;   Explanation: </span><br><span class="line">&gt;   The cheapest price from city <span class="number">0</span> to city <span class="number">2</span> with at most <span class="number">0</span> stop costs <span class="number">500</span>, as marked blue in the picture.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>dp[i][j]表示从src城市出发，经过i站，到达城市j</p><p>状态转移:</p><p>dp[i][j] = min ( dp[i][j] , dp[i-1][mid]+cost[mid][j] )</p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">import</span> sys</span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n, flights, src, dst, K)</span>:</span></span><br><span class="line">&gt;           mv = <span class="number">1000000</span></span><br><span class="line">&gt;           dp = [ [ mv <span class="keyword">for</span> _ <span class="keyword">in</span> range(n) ] <span class="keyword">for</span> _ <span class="keyword">in</span> range(K+<span class="number">2</span>) ] </span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(K+<span class="number">2</span>):</span><br><span class="line">&gt;               dp[i][src] = <span class="number">0</span> <span class="comment"># 从scr出发到scr，不需要cost</span></span><br><span class="line">&gt;           <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">2</span>):</span><br><span class="line">&gt;               <span class="keyword">for</span> flight <span class="keyword">in</span> flights:</span><br><span class="line">&gt;                  s = flight[<span class="number">0</span>]</span><br><span class="line">&gt;                  d = flight[<span class="number">1</span>]</span><br><span class="line">&gt;                  cost = flight[<span class="number">2</span>]</span><br><span class="line">&gt;                  dp[k][d] = min(dp[k][d],dp[k<span class="number">-1</span>][s]+cost)</span><br><span class="line">&gt;           <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[K+<span class="number">1</span>][dst]==mv <span class="keyword">else</span> dp[K+<span class="number">1</span>][dst]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="790-Domino-and-Tromino-Tiling"><a href="#790-Domino-and-Tromino-Tiling" class="headerlink" title="790. Domino and Tromino Tiling"></a>790. Domino and Tromino Tiling</h3><blockquote><ul><li><p>题目</p><p>We have two types of tiles: a 2x1 domino shape, and an “L” tromino shape. These shapes may be rotated.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   XX  &lt;- domino</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   XX  &lt;- <span class="string">"L"</span> tromino</span><br><span class="line">&gt;   X</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7</strong>.</p><p>  (In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Example:</span><br><span class="line">&gt;   Input: <span class="number">3</span></span><br><span class="line">&gt;   Output: <span class="number">5</span></span><br><span class="line">&gt;   Explanation: </span><br><span class="line">&gt;   The five different ways are listed below, different letters indicates different tiles:</span><br><span class="line">&gt;   XYZ XXZ XYY XXY XYY</span><br><span class="line">&gt;   XYZ YYZ XZZ XYY XXY</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>图片：<a href="http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-790-domino-and-tromino-tiling/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-790-domino-and-tromino-tiling/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   dp[i]表示高度为<span class="number">2</span>，长度为i的形状可能组法。</span><br><span class="line">&gt;   只有xx多米诺时，有两种拼法，用一个xx，但是把它立起来，这样的拼法是dp[i-<span class="number">1</span>];另一种是用两个</span><br><span class="line">&gt;               xx</span><br><span class="line">&gt;   xx，组成正方形xx，这样拼法是dp[i-<span class="number">2</span>]</span><br><span class="line">&gt;   dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>],斐波那契数列。</span><br><span class="line">&gt;   考虑L型多米诺，具体看图，不好描述。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">numTilings</span><span class="params">(self, N)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type N: int</span></span><br><span class="line"><span class="string">&gt;           :rtype: int</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           m = <span class="number">1000000007</span></span><br><span class="line">&gt;           dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">&gt;           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt;           dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">&gt;               dp[i][<span class="number">0</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-2</span>][<span class="number">0</span>] + <span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">1</span>])%m</span><br><span class="line">&gt;               dp[i][<span class="number">1</span>] = (dp[i<span class="number">-2</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>])%m</span><br><span class="line">&gt;           <span class="keyword">return</span> dp[N][<span class="number">0</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h3><blockquote><ul><li><p>题目</p><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: <span class="string">"babad"</span></span><br><span class="line">&gt;   Output: <span class="string">"bab"</span></span><br><span class="line">&gt;   Note: <span class="string">"aba"</span> is also a valid answer.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: <span class="string">"cbbd"</span></span><br><span class="line">&gt;   Output: <span class="string">"bb"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><p>这道题的难点在于，使用下标i和j来表示substring，i和j具体应该如何变化。实际上，i和j分别表示子串的结束字符和开头字符，如果s[i] != s[j]，那么dp[i][j]=false; 否则查看j+1 至 i-1之间是否回文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   dp(i, j) <span class="function">represents whether <span class="title">s</span><span class="params">(i ... j)</span> can form a palindromic substring, <span class="title">dp</span><span class="params">(i, j)</span> is <span class="keyword">true</span> when <span class="title">s</span><span class="params">(i)</span> equals to <span class="title">s</span><span class="params">(j)</span> and <span class="title">s</span><span class="params">(i+<span class="number">1</span> ... j<span class="number">-1</span>)</span> is a palindromic substring. When we found a palindrome, check <span class="keyword">if</span> it's the longest one. Time complexity <span class="title">O</span><span class="params">(n^<span class="number">2</span>)</span>.</span></span><br><span class="line"><span class="function">&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">&gt;           <span class="string">"""</span></span><br><span class="line"><span class="string">&gt;           :type s: str</span></span><br><span class="line"><span class="string">&gt;           :rtype: str</span></span><br><span class="line"><span class="string">&gt;           """</span></span><br><span class="line">&gt;           <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&gt;           re = <span class="string">""</span></span><br><span class="line">&gt;           l = len(s)</span><br><span class="line">&gt;           dp = [ [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(l) ]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">&gt;               dp[i][i] = <span class="keyword">True</span></span><br><span class="line">&gt;           <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,l):</span><br><span class="line">&gt;               <span class="keyword">for</span> i <span class="keyword">in</span> range(j,<span class="number">-1</span>,<span class="number">-1</span>):<span class="comment">#start from (j-1), end in 0, not including -1</span></span><br><span class="line">&gt;                   dp[i][j] = s[i]==s[j] <span class="keyword">and</span> (j-i+<span class="number">1</span>&lt;<span class="number">3</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">&gt;                   <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">&gt;                       re = s[i:j+<span class="number">1</span>] <span class="keyword">if</span> len(re)&lt;(j-i+<span class="number">1</span>) <span class="keyword">else</span> re</span><br><span class="line">&gt;           <span class="keyword">return</span> re</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="764-Largest-Plus-Sign"><a href="#764-Largest-Plus-Sign" class="headerlink" title="764. Largest Plus Sign"></a><em><u>764. Largest Plus Sign</u></em></h3><blockquote><ul><li><p>题目</p><p>In a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>. What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid? Return the order of the plus sign. If there is none, return 0.</p><p>An “<em>axis-aligned plus sign of 1s</em> of order <strong>k</strong>“ has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code> going up, down, left, and right, and made of <code>1</code>s. This is demonstrated in the diagrams below. Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.</p><p><strong>Examples of Axis-Aligned Plus Signs of Order k:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Order <span class="number">1</span>:</span><br><span class="line">&gt;   <span class="number">000</span></span><br><span class="line">&gt;   <span class="number">010</span></span><br><span class="line">&gt;   <span class="number">000</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Order <span class="number">2</span>:</span><br><span class="line">&gt;   <span class="number">00000</span></span><br><span class="line">&gt;   <span class="number">00100</span></span><br><span class="line">&gt;   <span class="number">01110</span></span><br><span class="line">&gt;   <span class="number">00100</span></span><br><span class="line">&gt;   <span class="number">00000</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Order <span class="number">3</span>:</span><br><span class="line">&gt;   <span class="number">0000000</span></span><br><span class="line">&gt;   <span class="number">0001000</span></span><br><span class="line">&gt;   <span class="number">0001000</span></span><br><span class="line">&gt;   <span class="number">0111110</span></span><br><span class="line">&gt;   <span class="number">0001000</span></span><br><span class="line">&gt;   <span class="number">0001000</span></span><br><span class="line">&gt;   <span class="number">0000000</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  <strong>Example1</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: N = <span class="number">5</span>, mines = [[<span class="number">4</span>, <span class="number">2</span>]]</span><br><span class="line">&gt;   Output: <span class="number">2</span></span><br><span class="line">&gt;   Explanation:</span><br><span class="line">&gt;   <span class="number">11111</span></span><br><span class="line">&gt;   <span class="number">11111</span></span><br><span class="line">&gt;   <span class="number">11111</span></span><br><span class="line">&gt;   <span class="number">11111</span></span><br><span class="line">&gt;   <span class="number">11011</span></span><br><span class="line">&gt;   In the above grid, the largest plus sign can only be order <span class="number">2</span>.  One of them is marked in bold.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>Example2</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: N = <span class="number">2</span>, mines = []</span><br><span class="line">&gt;   Output: <span class="number">1</span></span><br><span class="line">&gt;   Explanation:</span><br><span class="line">&gt;   There is no plus sign of order <span class="number">2</span>, but there is of order <span class="number">1</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>Example3</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;   Input: N = <span class="number">1</span>, mines = [[<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">&gt;   Output: <span class="number">0</span></span><br><span class="line">&gt;   Explanation:</span><br><span class="line">&gt;   There is no plus sign, so <span class="keyword">return</span> <span class="number">0</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><p>思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   动态规划，分别记录<span class="number">4</span>个方向上的最大连续<span class="number">1</span>的个数。比如”<span class="number">1001111</span>”， 每个位置出现的最大连续<span class="number">1</span>的个数分别为：”<span class="number">1001234</span>”，有了<span class="number">4</span>个方向的最长连续<span class="number">1</span>，order就是这四个方向的最小值，遍历每个位置的order，求出最大order即可。</span><br><span class="line">&gt;   设置<span class="number">4</span>个状态转移矩阵，lf[][],rt[][],dn[][],up[][]</span><br><span class="line">&gt;   如果当前的grid[i][j]=<span class="number">1</span>,那么</span><br><span class="line">&gt;   lf[i][j] = lf[i][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">&gt;   rt、dn、up同理。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">def</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(self, N, mines)</span>:</span></span><br><span class="line">&gt;           grid = [[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</span><br><span class="line">&gt;           <span class="keyword">for</span> mine <span class="keyword">in</span> mines:</span><br><span class="line">&gt;               a = mine[<span class="number">0</span>]</span><br><span class="line">&gt;               b = mine[<span class="number">1</span>]</span><br><span class="line">&gt;               grid[a][b] = <span class="number">0</span></span><br><span class="line">&gt;           lf = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</span><br><span class="line">&gt;           rt = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</span><br><span class="line">&gt;           dn = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</span><br><span class="line">&gt;           up = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">&gt;                   <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">&gt;                       lf[i][j] = <span class="number">1</span> <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">else</span> lf[i][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">&gt;                   <span class="keyword">if</span> grid[j][i]==<span class="number">1</span>:<span class="comment">##trick</span></span><br><span class="line">&gt;                       dn[j][i] = <span class="number">1</span> <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">else</span> dn[j<span class="number">-1</span>][i]+<span class="number">1</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">&gt;                   <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">&gt;                       rt[i][j] = <span class="number">1</span> <span class="keyword">if</span> j==N<span class="number">-1</span> <span class="keyword">else</span> rt[i][j+<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">&gt;                   <span class="keyword">if</span> grid[j][i]==<span class="number">1</span>: <span class="comment">##trick</span></span><br><span class="line">&gt;                       up[j][i] = <span class="number">1</span> <span class="keyword">if</span> j==N<span class="number">-1</span> <span class="keyword">else</span> up[j+<span class="number">1</span>][i]+<span class="number">1</span></span><br><span class="line">&gt;           re = <span class="number">0</span></span><br><span class="line">&gt;           <span class="keyword">for</span> i <span class="keyword">in</span> range(N):<span class="comment">##使用min、max函数会超时</span></span><br><span class="line">&gt;               <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">&gt;                   tre = lf[i][j]</span><br><span class="line">&gt;                   tre = rt[i][j] <span class="keyword">if</span> rt[i][j]&lt;tre <span class="keyword">else</span> tre</span><br><span class="line">&gt;                   tre = dn[i][j] <span class="keyword">if</span> dn[i][j]&lt;tre <span class="keyword">else</span> tre</span><br><span class="line">&gt;                   tre = up[i][j] <span class="keyword">if</span> up[i][j]&lt;tre <span class="keyword">else</span> tre</span><br><span class="line">&gt;                   re = tre <span class="keyword">if</span> tre&gt;re <span class="keyword">else</span> re</span><br><span class="line">&gt;           <span class="keyword">return</span> re</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote></blockquote>]]></content>
      
      <categories>
          
          <category> -Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Algorithm </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
